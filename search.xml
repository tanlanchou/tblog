<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jwt实现原理</title>
      <link href="/2024/12/05/202412/jwt/"/>
      <url>/2024/12/05/202412/jwt/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然我是一个全栈，但是我居然一直没写过jwt。</p><p>因为我真的没有从头到尾，从前端到后端去负责过一个项目，全部自己做</p><p>以至于我犯了一个低级错误，认为token，也就是jwt生成的token是可以延长时间的。</p><p>哈哈哈哈哈，很尴尬</p><h2 id="JWT-的基本机制"><a href="#JWT-的基本机制" class="headerlink" title="JWT 的基本机制"></a>JWT 的基本机制</h2><p>JWT（JSON Web Token）是一种用于身份验证和信息交换的开放标准。它的基本机制如下：</p><ol><li>组成：JWT 由三部分组成 - 头部（Header）、载荷（Payload）和签名（Signature）</li><li>生成：服务器在用户登录成功后创建 JWT</li><li>传递：服务器将 JWT 返回给客户端</li><li>存储：客户端存储 JWT（通常在本地存储或 Cookie 中）</li><li>使用：客户端在后续请求中携带 JWT（通常在 Authorization 头中）</li><li>验证：服务器验证 JWT 的有效性和完整性</li></ol><h2 id="后端怎么做？或者说jwt原理是什么？"><a href="#后端怎么做？或者说jwt原理是什么？" class="headerlink" title="后端怎么做？或者说jwt原理是什么？"></a>后端怎么做？或者说jwt原理是什么？</h2><p>一般是引入第三方包。</p><p>原理的话，我一开始以为是存储。后面发现不是</p><p>因为看了源码<code>@nestjs/jwt</code>是用 HS256</p><p>也就是通过那个字符串加密解密解决问题</p><p>所以创建，刷新，验证，其实是一种加密算法，减小了存储的压力，但是计算的压力？</p><p>所以也就不存在延长某个token的登录时间，因为一旦生成就是固定的。</p><p>所以，你自己写也不是不行。</p><h2 id="怎么刷新？"><a href="#怎么刷新？" class="headerlink" title="怎么刷新？"></a>怎么刷新？</h2><p>无非就是前端和后端谁做。一般是后端做</p><p>就是请求的时候，验证token之后返回新token</p><p>但是这个时间就很玩味了</p><p>他频繁的请求，你每次都刷新很浪费。</p><p>我一般是超过1个小时，继续请求就刷新token</p><p>反正你了解了机制，按照你的需求考虑吧</p><h2 id="前端接入-JWT"><a href="#前端接入-JWT" class="headerlink" title="前端接入 JWT"></a>前端接入 JWT</h2><p>前端接入 JWT 的基本步骤如下：</p><ol><li>登录：发送用户凭证到服务器，获取 JWT</li><li>存储：将获取的 JWT 存储在本地（如 localStorage 或 sessionStorage）</li><li>请求拦截：使用 Axios 等库设置请求拦截器，自动在每个请求的 header 中添加 JWT</li><li>响应处理：处理 401（未授权）错误，可能需要刷新 token 或重新登录</li><li>登出：清除存储的 JWT</li></ol><p>示例代码（使用 Axios）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 JWT</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">storeJWT</span> = (<span class="params">token</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;jwt&#x27;</span>, token);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 JWT</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getJWT</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;jwt&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">getJWT</span>();</span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> response,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理未授权错误，如刷新 token 或重定向到登录页</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登出</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logout</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;jwt&#x27;</span>);</span><br><span class="line">  <span class="comment">// 重定向到登录页或首页</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：JWT 是无状态的，服务器不能主动使其失效。因此，通常设置较短的过期时间并使用刷新 token 机制来平衡安全性和用户体验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>thx</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> jwt </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sse EventSource 空格</title>
      <link href="/2024/12/04/202412/eventsource_space/"/>
      <url>/2024/12/04/202412/eventsource_space/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>不知道基本的信息的可以看 <a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a></p><p>本质上是一种长链接，所以是服务器单向浏览器（或者说客户端）的一种方式</p><p>但是这次我纠结的是 <code>EventSource</code></p><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>写了一个超简单的接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullUrl = <span class="string">`<span class="subst">$&#123;myUrl&#125;</span>?<span class="subst">$&#123;params.toString()&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(fullUrl);</span><br><span class="line">eventSource.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="keyword">async</span> (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">data</span> === <span class="string">&quot;[DONE]&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">aiReturnDataLoading</span> = <span class="literal">false</span>;</span><br><span class="line">    eventSource.<span class="title function_">close</span>();</span><br><span class="line">    eventSource = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">aiReturnData</span> += event.<span class="property">data</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getBottom</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">eventSource.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>传的是markdown，但是发现markdown是乱的，就是有些不解析。</p><p>打出来以后发现是后端没传空格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-aaaa</span><br></pre></td></tr></table></figure><p>没有空格就没法解析。</p><p>后端直接用了curl给我打出来了，有空格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: \n</span><br></pre></td></tr></table></figure><p><code>\n</code> 前面确实有空格，但是为什么我这里只能收到一个空字符串？</p><p>于是查了下文档也就是阮一峰的哪个</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:  message\n\n</span><br></pre></td></tr></table></figure><p>也就是说 <code>message</code> 前面是有空格的, 于是自己写了一个 <strong>sse</strong> 的服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/stream&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> message =</span><br><span class="line">    <span class="string">&quot;djslkadjlaksjdlkasjdlkasjdlkasjdlkasjdlsajlkjdlakjsdlajldkjaslkd&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; message.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> char = message.<span class="title function_">charAt</span>(index);</span><br><span class="line">      res.<span class="title function_">write</span>(<span class="string">`data: <span class="subst">$&#123;char&#125;</span> \n\n`</span>);</span><br><span class="line">      res.<span class="title function_">write</span>(<span class="string">`data:  \n\n`</span>);</span><br><span class="line">      index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Client disconnected&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>反复修改了 res.write 的空格，然后前端调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/stream&#x27;</span>);</span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>.<span class="property">length</span>)</span><br><span class="line">&#125;;</span><br><span class="line">eventSource.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;EventSource failed:&#x27;</span>, err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>证明了一个事实</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>:空格message\n\n</span><br></pre></td></tr></table></figure><p>必须要有空格，后端给我看了下 <strong>java</strong> 源码，确实没有 <code>append</code> 空格, 不是很理解，不过可以手动了空格以后问题解决</p><p>为了严谨我还是查了下官方文档</p><p><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events">https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events</a></p><p>在 <strong>9.2.6 Interpreting an event stream 中</strong></p><blockquote><p>Collect the characters on the line after the first U+003A COLON character (:), and let be that string. If starts with a U+0020 SPACE character, remove it from .valuevaluevalue</p></blockquote><p>也就是说前面凭借经验的判断还是有问题。</p><p>也就是说，规则是第一个空格会删除，恰好这边后端传过来一个空格，那么就被删除了，就少了一个空格</p><h2 id="最后的解决方案"><a href="#最后的解决方案" class="headerlink" title="最后的解决方案"></a>最后的解决方案</h2><p>因为直接硬加空格可能导致其他问题，所以最后改成传base64搞定。</p><p>不过base64转中文GBK编码，最简单还是用</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> eventsource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信登录流程</title>
      <link href="/2024/12/03/202412/company_wechat_login/"/>
      <url>/2024/12/03/202412/company_wechat_login/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>使用登录的前提是，你配置好了回调，信任域名之类的。</p><h2 id="01-开始"><a href="#01-开始" class="headerlink" title="01. 开始"></a>01. 开始</h2><p><a href="https://developer.work.weixin.qq.com/document/path/91335">https://developer.work.weixin.qq.com/document/path/91335</a></p><p><a href="https://prod-files-secure.s3.us-west-2.amazonaws.com/c58c4e60-4e7d-412f-8331-564f16cae57b/9131eeda-181c-4487-9edd-557f14553944/image.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/c58c4e60-4e7d-412f-8331-564f16cae57b/9131eeda-181c-4487-9edd-557f14553944/image.png" alt="image.png"></a></p><p>这个是企业微信给的一张图</p><p>也就是说 客户端重定向 ⇒ 微信企业后台 ⇒ 返回 code state ⇒ 客户端 code state ⇒ 自己后台 ⇒ 后台到企业微信后台 ⇒ 返回用户信息 ⇒ 返回用户信息到客户端</p><p>这种应该就是静默获取用户信息。</p><h2 id="获取-code-和-state"><a href="#获取-code-和-state" class="headerlink" title="获取 code 和 state"></a>获取 code 和 state</h2><p><a href="https://developer.work.weixin.qq.com/document/path/91022">https://developer.work.weixin.qq.com/document/path/91022</a></p><blockquote><p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=CORPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE&agentid=AGENTID#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=CORPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE&amp;agentid=AGENTID#wechat_redirect</a></p></blockquote><p>按照上面的流程图上面，这一步是不需要自己的后台参与的，但是还是需要传 <a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=CORPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE&agentid=AGENTID#wechat_redirect"><code>REDIRECT_URI</code></a> </p><p>理由是需要验证 参数 <code>CORPID</code> 和 <code>REDIRECT_URI</code> 的合法性</p><p><code>REDIRECT_URI</code>  需要是你配置那个域名，我这边使用的是前端地址，你要用后端也行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const redirectUri = encodeURIComponent(window.location.href);</span><br><span class="line">const weChatAuthUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=&amp;redirect_uri=$&#123;redirectUri&#125;&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE&amp;agentid=#wechat_redirect`;</span><br><span class="line">window.location.href = weChatAuthUrl;</span><br></pre></td></tr></table></figure><p>这样服务就会传给你类似这种连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.3dept.com/cgi-bin/query?action=get&amp;code=AAAAAAgG333qs9EdaPbCAP1VaOrjuNkiAZHTWgaWsZQ&amp;state=</span><br></pre></td></tr></table></figure><p>所以上面的代码他会一直刷新页面，所以这里需要判断是否是在企业微信环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.userAgent.toLowerCase().match(/wxwork/i) == &quot;wxwork&quot;</span><br></pre></td></tr></table></figure><p>然后写一个判断即可</p><h2 id="后端消费code"><a href="#后端消费code" class="headerlink" title="后端消费code"></a>后端消费code</h2><p><a href="https://developer.work.weixin.qq.com/document/path/91023">获取访问用户身份 - 文档 - 企业微信开发者中心 (qq.com)</a></p><blockquote><p><a href="https://qyapi.weixin.qq.com/cgi-bin/auth/getuserinfo?access_token=ACCESS_TOKEN&code=CODE">https://qyapi.weixin.qq.com/cgi-bin/auth/getuserinfo?access_token=ACCESS_TOKEN&amp;code=CODE</a></p></blockquote><p>需要先获取 <code>ACCESS_TOKEN</code></p><p><a href="https://developer.work.weixin.qq.com/document/path/91023#15074">https://developer.work.weixin.qq.com/document/path/91023#15074</a></p><p><a href="https://developer.work.weixin.qq.com/document/path/91039">获取access_token - 文档 - 企业微信开发者中心 (qq.com)</a></p><blockquote><p><a href="https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&corpsecret=SECRET">https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&amp;corpsecret=SECRET</a></p></blockquote><p>这个后端就好写了。</p><p>无非几个请求，唯一觉得神奇的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://qyapi.weixin.qq.com/cgi-bin/user/get?access_token=&quot; + accessToken + &quot;&amp;userid=&quot;</span><br><span class="line">                + userId;</span><br></pre></td></tr></table></figure><p>还是能请求部分用户信息，按理说静默只能获取 <code>userid</code> 啊, 不过不重要。</p><p>代码通了，不过需要处理用户直接刷新的问题</p><h2 id="网页登录"><a href="#网页登录" class="headerlink" title="网页登录"></a>网页登录</h2><p>这个方案是不需要，但是查的时候顺便测试了一下，也可以，场景就是不在企业微信的环境里，通过扫描登录。</p><p>前端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const urlParams = new URLSearchParams(window.location.search);</span><br><span class="line">const user = urlParams.get(&#x27;user&#x27;);</span><br><span class="line">if (user) &#123;</span><br><span class="line">    // 假设user是一个JSON字符串，可以解析它</span><br><span class="line">    const parsedUser = JSON.parse(decodeURIComponent(user));</span><br><span class="line">    this.$store.commit(&#x27;setUser&#x27;, parsedUser);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 重定向到企业微信认证</span><br><span class="line">    const redirectUri = encodeURIComponent(`$&#123;window.location.origin&#125;/wechat/callback`);</span><br><span class="line">    const weChatAuthUrl = `https://open.work.weixin.qq.com/wwopen/sso/qrConnect?appid=wwd93305cfd28429fb&amp;agentid=1000025&amp;redirect_uri=$&#123;redirectUri&#125;&amp;state=STATE`;</span><br><span class="line">    window.location.href = weChatAuthUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 redirectUri  必须是后端的</p><p>后端会接收一个 <code>code</code>，然后通过 <code>code + access_token</code> 获取用户信息，然后生成token或者用户信息，然后做一个浏览器的重定向给前端。</p><p>代码量其实差别不大，甚至代码差别也不大</p><p>这个方案的问题在于信息直接 <strong>get</strong> 传很丑陋, 虽然这玩意儿也不是什么秘密. 毕竟你 <strong>F12</strong> 或者拦截也能看得到，但是直接 <strong>url</strong> 里面传还是…</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="https://developer.work.weixin.qq.com/document/path/90315#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E8%AF%95">https://developer.work.weixin.qq.com/document/path/90315#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E8%AF%95</a></p><p>企业微信可以调试，详情见连接.</p><p>这点我觉得比钉钉好多了。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
            <tag> javascrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitlocker命令行解锁</title>
      <link href="/2024/12/02/202412/bitlocker/"/>
      <url>/2024/12/02/202412/bitlocker/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>需求是不用命令行或者不能直接点击右键U盘输入密码</p><p>因为用户不希望点除这个软件以外的东西.</p><p>所以需要在软件内解锁bitlocker</p><p>目前4种办法</p><ol><li>unlocker-bitlocker</li></ol><p>最简单的方案, 直接一个powershell 传参解决</p><p>缺点, 非专业版没有这玩意儿, 操作系统兼容要先想好.</p><p>前提是客户系统支持bitlocker, 并且允许安装, 如果不允许或者系统直接不能安装bitlocker</p><p>是不能使用这个方法的</p><p>而且还需要支持powershell, 并且允许升级</p><p>还有其他类似的方案, 但是前提也都是开启了bitlocker功能</p><p>还有一个版本在里面, 不同版本的unlocker-bitlocker 高兼容低</p><p>但是低版本无法兼容高版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-BitLockerVolumeInternal</span> : The management information stored on the drive contained an unknown <span class="built_in">type</span>. <span class="keyword">If</span> you are <span class="keyword">using</span> an old version of Windows, try accessing the drive from the latest version. (Exception from HRESULT: 0x8031009B) At C:\Windows\system32\WindowsPowerShell\v1.0\<span class="keyword">Module</span>s\BitLocker\BitLocker.psm1:1198 char:40 + ... umeInternal = Get-BitLockerVolumeInternal -MountPoint $MountPoint[$i] + </span><br></pre></td></tr></table></figure><ol><li>manage-dbe</li></ol><p>两种方案</p><ol><li>命令行输入</li></ol><p><a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/manage-bde-unlock">https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/manage-bde-unlock</a></p><p>也只能命令行输入, 因为 manage-bde -unlock F: -password 不支持 管道输入, 也就是 manage-bde does not support piping passwords</p><ol><li>通过秘钥进行恢复</li></ol><p>需要用户上传秘钥, 证书等等方式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> X: <span class="literal">-RecoveryPassword</span> &lt;恢复秘钥&gt;</span><br><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> D: <span class="literal">-RecoveryPassword</span> <span class="number">123456</span><span class="literal">-789012-345678-901234-567890-123456-789012-345678</span></span><br><span class="line"></span><br><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> X: <span class="literal">-KeyProtector</span> &lt;密钥文件路径&gt;</span><br><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> D: <span class="literal">-KeyProtector</span> F:\mykey.bek</span><br><span class="line"></span><br><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> X: <span class="literal">-Cert</span></span><br><span class="line"></span><br><span class="line">manage<span class="literal">-bde</span> <span class="literal">-unlock</span> X:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传后, 通过密码或者其他方式关联秘钥, 然后输入解锁</p><p>可以做, 但是不支持没绑定过的u盘和只知道密码的u盘</p><ol><li>通过windows api 自己写</li><li>第三方 目前没有找到免费且支持命令行解锁的</li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> bitlocker </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setInterval 浏览器执行频率</title>
      <link href="/2024/03/11/javascript/setInterval_browser_execution_frequency/"/>
      <url>/2024/03/11/javascript/setInterval_browser_execution_frequency/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>在写一个东西的时候需要在某个时间定时执行一些任务, 在浏览器.</p><p>东西很快就写好了.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//todo something</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>结果发现一些问题, <code>setInterval</code> 在5分钟后浏览器会降低js定时器的执行频率（1分钟一次）</p><p>于是不能准确的执行我想要做的事情, 具体详情可以看下面文章</p><p><a href="https://developer.chrome.com/blog/timer-throttling-in-chrome-88?hl=zh-cn">从 Chrome 88 开始，系统会对链接的 JS 计时器施加严格的节流限制  |  Blog  |  Chrome for Developers</a></p><p><a href="https://www.zdnet.com/article/chrome-javascript-timer-throttling-googles-tests-show-it-saves-up-to-2-hours-battery-life/">Chrome JavaScript timer throttling: Google’s tests show it saves up to 2 hours’ battery life</a></p><p>经过我查询, 需要解决问题有3个办法.</p><ol><li>settimeout</li><li>webworker</li><li>浏览器解决</li></ol><p>一个一个看. </p><h3 id="01-settimeout"><a href="#01-settimeout" class="headerlink" title="01. settimeout"></a>01. settimeout</h3><p><code>settimeout</code> 解决就是不通过 <code>setInterval</code> 每次执行, 而是 <code>settimeout</code> 执行完成, 再启动一个 <code>settimeout</code> , 从而避过这个问题</p><p>我从一开始就觉得这个方案解决不了, 因为浏览器全局设置导致了这个问题, 不会因为你重新设置避过</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">startOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toTimeString</span>().<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">8</span>))</span><br><span class="line">      <span class="title function_">startOrder</span>();</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">startOrder</span>();</span><br><span class="line">  </span><br><span class="line"><span class="number">14</span>:<span class="number">02</span>:<span class="number">42</span></span><br><span class="line"><span class="number">14</span>:<span class="number">03</span>:<span class="number">24</span></span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">24</span></span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">24</span></span><br><span class="line"><span class="number">14</span>:<span class="number">06</span>:<span class="number">24</span></span><br></pre></td></tr></table></figure><p>但是这个可以解决系统过于繁忙导致的加速执行的问题.</p><p>比如说原计划 </p><ol><li>500毫秒执行一次</li></ol><p>但是某一次执行太久, 导致阻塞, 执行了600毫秒. 下一次执行实在1秒处. 实际上两次执行的间隔是400毫秒.</p><p>可以使用 <code>settimeout</code> 这种方式来保证每次执行都是 500毫秒.</p><p>但是他也无法解决整个浏览器的设置问题, 也就是5分钟后 1分钟执行一次的问题</p><h3 id="02-webworker"><a href="#02-webworker" class="headerlink" title="02. webworker"></a>02. webworker</h3><p>webworker 能奏效的原因是因为他不受限制, 也就是浏览器没有给他限制. 所以直接把 setimeout, setInterval 写在 webworker 中. 从而绕过限制.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">使用 Web Workers - Web API 接口参考 | MDN</a></p><p>这种方式明确有效. 如果不想自己写</p><p><a href="https://github.com/ctubio/HackTimer_fork">https://github.com/ctubio/HackTimer_fork</a></p><h3 id="03-浏览器设置"><a href="#03-浏览器设置" class="headerlink" title="03. 浏览器设置"></a>03. 浏览器设置</h3><p>来源于下面这个链接</p><p><a href="https://www.zdnet.com/article/chrome-javascript-timer-throttling-googles-tests-show-it-saves-up-to-2-hours-battery-life/">Chrome JavaScript timer throttling: Google’s tests show it saves up to 2 hours’ battery life</a></p><p>但是我没有测试 因为通过这种方式绕过去实际操作性太小了.</p><p>你总不可能让所有客户都这样搞吧.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端埋点</title>
      <link href="/2024/02/23/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/"/>
      <url>/2024/02/23/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h2 id="1-首先需要知道什么是埋点"><a href="#1-首先需要知道什么是埋点" class="headerlink" title="1. 首先需要知道什么是埋点"></a>1. 首先需要知道什么是埋点</h2><blockquote><p>所谓“埋点”，是数据采集领域（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个icon点击次数、观看某个视频的时长等等。</p><p>埋点的技术实质，是先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。</p></blockquote><p>网站分析、用户行为分析、产品数据分析等领域，以帮助企业了解用户行为习惯、优化产品设计、改进用户体验，从而提升产品的用户满意度和市场竞争力</p><p>其实异常捕获也算是一种埋点.</p><p>所以对于前端来说, APP, 小程序, 网页可能都需要埋点. 如果你使用的是各种框架就又需要注意框架里应该怎么埋点</p><h2 id="2-最传统的方式-也就是手动去埋"><a href="#2-最传统的方式-也就是手动去埋" class="headerlink" title="2. 最传统的方式, 也就是手动去埋."></a>2. <strong>最传统的方式, 也就是手动去埋.</strong></h2><p>进入页面, 你根据页面生命周期, 去算, 点击了哪些, 去布置事件, 也可以拿<code>performance</code>数据</p><p>存在对象里, 存在localstorage, indexdb里</p><p>然后在特定时间或者事件点, 上传服务器.</p><p>觉得太麻烦就用别的统计, 比如当年我用过的百度</p><p><a href="https://tongji.baidu.com/web5/welcome/login">百度统计——一站式智能数据分析与应用平台</a></p><p>引入即可获得页面上的活动.</p><h2 id="3-可视化埋点"><a href="#3-可视化埋点" class="headerlink" title="3. 可视化埋点"></a>3. 可视化埋点</h2><p>传统手动埋点的问题在于麻烦, 就是沟通麻烦, 程序员你开发也麻烦. 所以有可视化埋点这个功能.</p><p>很美好, 就是产品用可视化的方式, 点击软件, 网页, 然后选择要怎么埋点. 然后就不需要程序员写代码了</p><p><a href="https://manual.sensorsdata.cn/sa/1.17/zh_cn/app-7541658.html">App 可视化全埋点使用指南</a></p><p><a href="https://juejin.cn/post/6844903878371049480">可视化埋点技术揭秘 - 掘金</a></p><p>好处, 灵活, 不用开发人员就可以搞. </p><p>坏处</p><ol><li>大概率要接入第三方api, 可能收费</li><li>性能不明</li><li>特殊场景无法处理</li><li>兼容性不明</li><li>特殊平台可能不可用, 比如说你使用uniapp这种方案, 你怎么接入第三方埋点呢? 可能还是只能接入页面埋点, 关注一下整体性能, 但是无法实现可视化埋点.</li></ol><p>最大的问题在于, 很多项目早期是不需要埋点的, 到达一定规模才开始做这件事, 这个时候代价就比较大了</p><p>如果只是简单的使用埋点功能, 我觉得ok. 省的开发了</p><p>大方向上主要是这两个分类, 无非就是自己开发或者引入另一套系统</p><h2 id="4-应该怎么埋点-埋点的具体方案是什么"><a href="#4-应该怎么埋点-埋点的具体方案是什么" class="headerlink" title="4. 应该怎么埋点? 埋点的具体方案是什么?"></a>4. 应该怎么埋点? 埋点的具体方案是什么?</h2><p>前面是大方向, 那么当业务来了, 究竟需要怎么去埋点?</p><p><a href="https://juejin.cn/post/6978131459655598094">Vue埋点初探 | 前端埋点 | PV埋点| 交互埋点 - 掘金</a></p><p>在上面这篇文章中提出了几个方案</p><ul><li><strong>命令式埋点</strong>是用比较常见的方式，在用户产生行为的地方使用js方法进行数据上报，优点是埋点方式比较简单，缺点是与业务耦合度较高</li><li><strong>声明式埋点</strong>是在具体DOM元素上进行数据绑定，只需组件开发人员在sdk上制定埋点方案，业务开发人员设置数据即可，优点是埋点代码与具体的交互和业务逻辑解耦</li><li><strong>可视化埋点</strong>是通过可视化工具配置埋点，需要另外配套一个平台控制埋点的埋入，优点是自动生成埋点代码嵌入到页面中，减轻业务开发人员的埋点负担，目前做得好得例如<a href="https://link.juejin.cn/?target=https://github.com/mixpanel">Mixpanel</a></li><li><strong>无埋点</strong>是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是完全无需业务参与，完全与业务解耦，目前比较流行的例如<a href="https://link.juejin.cn/?target=https://www.growingio.com/">GrowingIO</a></li></ul><p>这个东西在词汇上很混乱</p><p><a href="https://zhuanlan.zhihu.com/p/79439716">带你了解埋点、无埋点、全埋点</a></p><p><a href="https://mtj.baidu.com/static/userguide/book/chapter5/what.html">什么是无埋点技术 · 百度移动统计帮助文档</a></p><p>无埋点和可视化埋点有点冲突.</p><p>总之可以理解为他给出了4种方案</p><ol><li>自己纯手写</li><li>自己写库(你叫sdk也可以), 然后初级程序员调用库埋点, 本质上和第一种没区别, 只是增加了分工</li><li>可视化配置埋点</li><li>全部收集</li></ol><p>可视化埋点我刚才说了, 优缺点.</p><p>全部收集, 也就是用户所有动作都捕捉, 页面滑动, 滚动条滚动, 点击, 双击…….</p><p>这种收集简单粗暴, 但是数据可能没有针对性. 因为数据多, 压力可能稍微大一点.</p><h2 id="05-自己实现的具体方案"><a href="#05-自己实现的具体方案" class="headerlink" title="05. 自己实现的具体方案"></a>05. 自己实现的具体方案</h2><p>很多时候还是要自己写, 去买别人的.</p><p>这种情况下怎么快速的高效的埋点?</p><p><strong>页面pv,</strong> 这个主要是受收集页面加载时间, 性能, 报错, 用户停留时间等等</p><p>这个就看框架生命周期了, 如果是原生的dom也有生命周期.</p><p>操作的记录</p><p>vue 用自定义指令解决问题</p><p><a href="https://cn.vuejs.org/guide/reusability/custom-directives">Vue.js</a></p><p>也就是所谓的声明式</p><p>react 我不是很了解. 但是高阶组件(也就是闭包) 我觉得可以解决.</p><p>ag 就完全不熟悉了.</p><p>剩下的”痛点” 就在于如果让产品快速自定义, 形成一个文档很麻烦. 这也就是为什么很多时候 可视化埋点方便的点.</p><p><a href="https://hughfenghen.github.io/posts/2018/05/01/vue-directive-track/">基于vue directive实现声明式埋点方案 | 风痕 · 術&amp;思</a></p><p>这篇文章的做法是, 写chrome插件, userscipt. </p><p>可以解决部分问题</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 埋点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rss数据对比</title>
      <link href="/2024/02/23/rss%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/02/23/rss%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>做事儿的目的在于我需要对比两个 <code>xml</code>, 也就是 <code>rss</code> 之间的差异</p><p>最开始是自己做对比, 但是还是觉得太麻烦.</p><p><code>xml</code> 对比在 <code>npmjs</code> 上没有找到特别好的工具, 于是走了歪路, <strong>xml ⇒ json ⇒ diff</strong></p><p>通过 <code>rss-parser</code> 获取 <code>rss</code> 数据源, 然后回直接转为 <code>json</code> 数据, 也就是 <code>object</code></p><p><a href="https://www.npmjs.com/package/rss-parser">npm: rss-parser</a></p><p>然后就可以对比两个 <code>json</code></p><p><a href="https://github.com/andreyvit/json-diff">https://github.com/andreyvit/json-diff</a></p><p>json-diff工具在比较两个JSON文件或对象后，会生成一个差异报告。这个报告将详细列出两者之间的差异，包括添加、删除和修改的内容。这样，您可以清楚地了解数据的变化情况。</p><p><code>json-diff</code> 最好的地方在于他可以明确告诉你添加删除修改</p><p>比如 <strong>[1,2,3,4,5,6]</strong> 对比 <strong>[2,3,4,5,6,7]</strong></p><p>一般的对比工具会告诉你 <code>1 ≠ 2</code> 这里有变化, 其实是删除了1, 新增了7.</p><p>我没有看他对比的算法, 大概率会复杂很多</p><p>有了这两个工具的帮助, 这件事儿就简单多了</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> rss </tag>
            
            <tag> diff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nestjs modules mailer</title>
      <link href="/2024/02/23/nestjs-modules-mailer/"/>
      <url>/2024/02/23/nestjs-modules-mailer/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://nest-modules.github.io/mailer/docs/mailer.html">How to use? · NestJS - Mailer (nest-modules.github.io)</a></p><p><a href="https://github.com/yanarp/nestjs-mailer?tab=readme-ov-file">yanarp&#x2F;nestjs-mailer：一个简单的实现示例，使用基于nodemailer构建的nest js的mailer模块，🌈使用邮件模板。 (github.com)</a></p><p><a href="https://github.com/leemunroe/responsive-html-email-template">https://github.com/leemunroe/responsive-html-email-template</a></p><h2 id="目标和基本使用"><a href="#目标和基本使用" class="headerlink" title="目标和基本使用"></a>目标和基本使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @nestjs-modules/mailer nodemailer</span><br><span class="line">npm install --save-dev @types/nodemailer</span><br></pre></td></tr></table></figure><p>在 module 中引入</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MailerModule</span>.<span class="title function_">forRootAsync</span>(&#123;</span><br><span class="line">      <span class="attr">imports</span>: [<span class="title class_">ConfigModule</span>],</span><br><span class="line">      <span class="attr">useFactory</span>: <span class="keyword">async</span> (<span class="attr">configService</span>: <span class="title class_">ConfigService</span>) =&gt; (&#123;</span><br><span class="line">        <span class="attr">transport</span>: &#123;</span><br><span class="line">          <span class="attr">service</span>: configService.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_SERVICE&#x27;</span>),</span><br><span class="line">          <span class="attr">auth</span>: &#123;</span><br><span class="line">            <span class="attr">user</span>: configService.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_USERNAME&#x27;</span>),</span><br><span class="line">            <span class="attr">pass</span>: configService.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_PASSWORD&#x27;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">defaults</span>: &#123;</span><br><span class="line">          <span class="attr">from</span>: configService.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_FROM&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="attr">inject</span>: [<span class="title class_">ConfigService</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>我的目的是使用QQ邮箱发送邮件, 这样配置就ok了. 接下来就可以调用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">sendMail</span>(<span class="attr">to</span>: <span class="built_in">string</span>, <span class="attr">subject</span>: <span class="built_in">string</span>, <span class="attr">template</span>: <span class="built_in">string</span>, <span class="attr">html</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">mailerService</span>.<span class="title function_">sendMail</span>(&#123;</span><br><span class="line">            to,</span><br><span class="line">            <span class="attr">from</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_FROM&#x27;</span>),</span><br><span class="line">            subject,</span><br><span class="line">            html,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="模版的使用"><a href="#模版的使用" class="headerlink" title="模版的使用"></a>模版的使用</h2><p>首先你可以不使用模版, 就用html, 模版也是编译成html, 只能说模版在多个模版情况下, 你好做一点.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">sendMail</span>(<span class="attr">to</span>: <span class="built_in">string</span>, <span class="attr">subject</span>: <span class="built_in">string</span>, <span class="attr">template</span>: <span class="built_in">string</span> = <span class="string">&quot;diff&quot;</span>, <span class="attr">context</span>: <span class="built_in">any</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;      </span><br><span class="line">    <span class="keyword">let</span> html = templates[template];</span><br><span class="line">    <span class="keyword">if</span>(context) &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(context);</span><br><span class="line">        keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            html = html.<span class="title function_">replace</span>(<span class="string">`&#123;&#123;<span class="subst">$&#123;key&#125;</span>&#125;&#125;`</span>, context[key]);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">mailerService</span>.<span class="title function_">sendMail</span>(&#123;</span><br><span class="line">        to,</span><br><span class="line">        <span class="attr">from</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="title function_">get</span>(<span class="string">&#x27;MAIL_FROM&#x27;</span>),</span><br><span class="line">        subject,            </span><br><span class="line">        html</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用模版功能</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">template</span>: &#123;</span><br><span class="line">  <span class="attr">dir</span>: __dirname + <span class="string">&#x27;/mail.template&#x27;</span>,</span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">new</span> <span class="title class_">EjsAdapter</span>(), </span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">strict</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>就这样, 选择你需要的模版引擎, 我这里用 <code>ejs</code>, 因为我熟悉. <code>context</code> 传值就<strong>ok</strong>了</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> 后端 </tag>
            
            <tag> nestjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存大赏.</title>
      <link href="/2023/12/14/browser/cache/"/>
      <url>/2023/12/14/browser/cache/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-强制缓存"><a href="#01-强制缓存" class="headerlink" title="01. 强制缓存"></a>01. 强制缓存</h3><p><a href="https://blog.csdn.net/weixin_44765930/article/details/129819711">https://blog.csdn.net/weixin_44765930/article/details/129819711</a></p><p>这篇文章详细解释了什么是强制缓存.</p><blockquote><p>Cache-Control</p><p>Cache-Control是HTTP&#x2F;1.1中定义的缓存控制字段，常见的取值如下：<br>public：响应可以被任意缓存（包括客户端和代理服务器）缓存。<br>private：响应只能被客户端缓存，不能被代理服务器缓存。<br>max-age：指定缓存的有效期，单位为秒。<br>no-cache：表示需要协商缓存，浏览器每次都需要向服务器发送请求，确认资源是否有更新。<br>no-store：禁止缓存，每次都需要向服务器发送请求获取最新资源。</p><p>Expires</p><p>Expires是HTTP&#x2F;1.0中定义的缓存控制字段，它表示资源的过期时间，是一个GMT格式的日期字符串。当浏览器发送请求时，会比较当前时间和Expires字段的值，如果当前时间在过期时间之前，就直接从缓存中获取资源。</p></blockquote><p>这里说一下他没说到的点.</p><p>max-age 设置为0, 也表示不缓存.</p><p>强制缓存优先级 &gt; 协商缓存, 但是强制缓存内部也是有优先级的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Expires: Wed, 14 Dec 2023 12:00:00 GMT</span><br></pre></td></tr></table></figure><p><code>Cache-Control</code> 中的 max-age 指令将优先于 <code>Expires</code></p><p>在向下兼容的这种考虑下, 是需要使用 <code>Expires</code> 的.</p><h3 id="02-破坏缓存"><a href="#02-破坏缓存" class="headerlink" title="02. 破坏缓存"></a>02. 破坏缓存</h3><p>当设置了强制缓存, 但是文件更新了, 怎么办?</p><p>本地测试, <strong>ctrl + f5</strong> 或者直接清理浏览器缓存, <strong>f12</strong> 强制不用缓存</p><p>开发端, 老办法是用版本号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/your/resource/style.css?version=123456&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变化就会强制更新, 现代的框架, vue, react, ag 每次更新其实都是会重新打包, 都有完全不同的hash, 自然也就不存在缓存问题了.</p><h3 id="03-协商缓存"><a href="#03-协商缓存" class="headerlink" title="03. 协商缓存"></a>03. 协商缓存</h3><p>协商缓存的好处在于可以实时获取最新的资源, 降低了服务器压力(没有强制缓存多), 又没有缓存的压力.</p><blockquote><p>Last-Modified: 服务器通过 Last-Modified 头部返回资源的最后修改时间。浏览器在后续请求中可以使用 If-Modified-Since 头部将上一次收到的最后修改时间发送给服务器。服务器根据这个时间判断资源是否有更新。</p><p>ETag 是服务器生成的唯一标识符，用于表示资源的版本。浏览器在后续请求中可以使用 If-None-Match 头部将上一次收到的 ETag 发送给服务器。服务器根据这个标识判断资源是否有更新。</p></blockquote><p>换句话说, 如果服务器资源没有变化, 就发一次请求, 但是这次请求只是做一个对比, 减少了请求的压力.</p><p>如果服务器资源有变化, 就发两次请求, 第一次请求返回304, 第二次请求返回最新资源.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Last-Modified: Wed, 14 Dec 2023 12:00:00 GMT</span><br></pre></td></tr></table></figure><p>根据 Last-Modified 或者 ETag 和服务器做对比</p><h3 id="04-我们应该怎么设置缓存"><a href="#04-我们应该怎么设置缓存" class="headerlink" title="04. 我们应该怎么设置缓存."></a>04. 我们应该怎么设置缓存.</h3><p>这里就要区分 API 还是静态资源.</p><p>API 一般是不缓存的, 因为它是有状态的, 所以每次请求都需要重新获取数据.</p><p>静态资源缓存, 现在也和后端无关, 因为前端是一个独立项目.</p><p>只有某些特殊的资源, 比如 CDN, 一些特殊的固定 css, js 这些资源是由后端主动缓存</p><p>拿 express 举例子</p><p><a href="https://stackoverflow.com/questions/42418503/how-do-i-return-304-unmodified-status-with-express-js">https://stackoverflow.com/questions/42418503/how-do-i-return-304-unmodified-status-with-express-js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/static/styles.css&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置 Cache-Control 头，表示缓存有效时间为1小时</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;max-age=3600&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 Expires 头，表示资源过期时间为当前时间 + 1小时</span></span><br><span class="line">  <span class="keyword">const</span> expires = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  expires.<span class="title function_">setHours</span>(expires.<span class="title function_">getHours</span>() + <span class="number">1</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Expires&#x27;</span>, expires.<span class="title function_">toUTCString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后每次再检查. 简单的方式是些中间件.</p><p>现在正常大部分情况其实都是现代js框架, 一般都是用 docker 内部就是 nginx 做服务, 那么就需要前端在 ngixn.conf 中设置.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.css$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;max-age=3600&quot;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Expires <span class="string">&quot;Thu, 01 Jan 1970 00:00:01 GMT&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$uri</span> <span class="regexp">~* /special\.css)</span> &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;no-store&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是其他人的设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$sent_http_content_type</span> <span class="variable">$expires</span> &#123;</span><br><span class="line">    <span class="attribute">default</span>                    <span class="literal">off</span>;</span><br><span class="line">    <span class="comment">#text/html                  epoch; # 不缓存</span></span><br><span class="line">    text/<span class="attribute">css</span>                   <span class="number">30d</span>; <span class="comment"># 缓存30天，长时缓存可以设置为max</span></span><br><span class="line">    application/<span class="attribute">javascript</span>     <span class="number">30d</span>;</span><br><span class="line">    ~image/                    30d;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来实现这些设置.</p><h3 id="05-Web-Storage"><a href="#05-Web-Storage" class="headerlink" title="05. Web Storage"></a>05. Web Storage</h3><p>这个其实就是 localstorage, sessionstorage 这两种东西.</p><p>可以简单的存一点儿东西, 比如 token, 虽然他比 cookie 大. 但是大的不多, 一般不超过 5M.</p><p>存点关键信息ok, 但是如果要存大量数据, 就不合适了.</p><p>他的好处在于浏览器支持广泛, 设置IE8都支持. 使用和设置简单</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage">https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage</a></p><p>两者区别在于, sessionStorage 浏览器关闭的时候会清除. localStorage 则是永久存储, 除非手动删除.</p><h3 id="06-indexDB"><a href="#06-indexDB" class="headerlink" title="06. indexDB"></a>06. indexDB</h3><p>之前我写过一个 </p><p><a href="https://tanlanchou.github.io/tblog/2023/11/02/%5BQ103%5DIndexDB_Base/">https://tanlanchou.github.io/tblog/2023/11/02/%5BQ103%5DIndexDB_Base/</a></p><p><a href="https://github.com/tanlanchou/indexdb_book_store">https://github.com/tanlanchou/indexdb_book_store</a></p><p>现代浏览器基本上都支持了, 兼容性我没有所有都试过, 如果有要么自己封装, 别人封装应该也有.</p><p>好处是大, 根据你硬盘来算的, 基本不用考虑大小.</p><p>但是操作是真的不舒服, 不支持sql. 写个分页真的给我累瘫了..</p><p>总体没什么毛病.</p><h3 id="07-service-worker"><a href="#07-service-worker" class="headerlink" title="07. service worker"></a>07. service worker</h3><blockquote><p>Service Worker 是一个在 Web 应用程序背后运行的脚本，它可以拦截和处理网络请求、管理缓存以及推送通知。Service Worker 被设计为一个独立的线程，与网页主线程分离，因此可以在后台执行任务而不阻塞用户界面。</p><ol><li>不能访问／操作dom</li><li>会自动休眠，不会随浏览器关闭所失效(必须手动卸载)</li><li>离线缓存内容开发者可控</li><li>必须在https或者localhost下使用</li><li>所有的api都基于promise</li></ol></blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API</a></p><p>他可以拦截请求, 并且设置缓存.</p><p>serviceWorker 我了解的比较少, 反正要搞 pwa, 后面学习一下</p><h3 id="08-总结"><a href="#08-总结" class="headerlink" title="08. 总结"></a>08. 总结</h3><p>木有.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> cache </tag>
            
            <tag> Cache-Control </tag>
            
            <tag> Expires </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端 docker 项目如何动态加载环境变量</title>
      <link href="/2023/12/07/zaxiang/front_docker_env/"/>
      <url>/2023/12/07/zaxiang/front_docker_env/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>首先我们需要明白一个前提, 前端打包出来的东西是 html, css, js, 字体, 图片……</p><p>他是没有能力访问服务器的环境变量的. 所以如果要动态使用环境变量, 我大概想了一想, 有3种方式.</p><ol><li>nginx 插件有能力访问环境变量</li><li>node 环境</li><li>shell</li></ol><p>第一种办法思来想去太麻烦了, 首先Nginx配置一直是让我脑壳疼的东西. 还有就是有些链接和配置是没有转发的, 现在又需要转发太麻烦了.</p><p>第二种被否了, 因为如果包含node环境, 包太大, 而且启动的时候build 太慢.</p><p>所以我选择了第三种</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝 update.env.sh 到容器</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> update.env.sh /usr/share/nginx/update.env.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 update.env.sh 可执行权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/share/nginx/update.env.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/usr/share/nginx/update.env.sh &amp;&amp; nginx -g &#x27;daemon off;&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后 <strong>shell</strong> 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sed -i &quot;s|proxy_pass http://.*:.*;|proxy_pass &quot;$VUE_APP_MODEL_BASE_URL&quot;/;|g&quot; /etc/nginx/conf.d/default.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找包含指定内容的文件</span></span><br><span class="line">file_path=$(grep -rl &#x27;location.protocol.indexOf(&quot;s&quot;)&lt;0?&#x27; /usr/share/nginx/html)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否找到一个文件</span></span><br><span class="line">if [ -z &quot;$file_path&quot; ]; then</span><br><span class="line">  echo &quot;未找到符合条件的文件。&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否找到多个文件</span></span><br><span class="line">file_count=$(echo &quot;$file_path&quot; | wc -l)</span><br><span class="line">if [ &quot;$file_count&quot; -gt 1 ]; then</span><br><span class="line">  echo &quot;找到多个符合条件的文件，请检查。&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换文件内容</span></span><br><span class="line">sed -i &#x27;s|Nr=window.location.protocol.indexOf(&quot;s&quot;)&lt;0?&quot;[^&quot;]*&quot;:&quot;[^&quot;]*&quot;|Nr=window.location.protocol.indexOf(&quot;s&quot;)&lt;0?&quot;&#x27;$VUE_APP_NOVNC_BASE_URL&#x27;&quot;:&quot;&#x27;$VUE_APP_NOVNC_BASE_URLS&#x27;&quot;|&#x27; &quot;$file_path&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;替换完成。&quot;</span><br></pre></td></tr></table></figure><p>解决问题.</p><p>这个方法本来也很麻烦的, 得益于 chatgpt, 写这种脚本简直不要太轻松.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> docker </tag>
            
            <tag> shell </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端请求模拟</title>
      <link href="/2023/12/07/zaxiang/mock/"/>
      <url>/2023/12/07/zaxiang/mock/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>这个迭代后端很麻烦, 所以接口不太可能第一时间提供给我.</p><p>于是我先开会约定了接口, 就开始找网上的模拟解决办法.</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li>能够模拟请求</li><li>能够模拟数据</li></ol><p>模拟的原因很简单, 我不想后端来了我又需要改很多代码.</p><p>所以最好的方式就是其他都一样, 只是请求的具体代码变一下.</p><p>简单的方式自己写 <code>settimeout</code>, 然后 <code>promise</code> 封装一下. </p><p>但是我怕我想不全, 而且网上应该有轮子, 于是找到了它</p><p><code>axios-mock-adapter</code></p><p>模拟请求搞定了, 还要模拟数据, 这一步其实可以不用. 如果要使用的话 <code>Mock.js</code> 我简单测试了一下也够用了.</p><h2 id="axios-mock-adapter"><a href="#axios-mock-adapter" class="headerlink" title="axios-mock-adapter"></a>axios-mock-adapter</h2><p><a href="https://www.npmjs.com/package/axios-mock-adapter">npm: axios-mock-adapter</a></p><p>他好用的点在于它可以直接拦截, 不入侵你原有的代码, 你原有的代码该怎么写就怎么写</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">import</span>(<span class="string">&#x27;axios-mock-adapter&#x27;</span>), <span class="keyword">import</span>(<span class="string">&#x27;@/api/system&#x27;</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MockAdapter</span> = results[<span class="number">0</span>].<span class="property">default</span></span><br><span class="line">    <span class="keyword">const</span> mock = <span class="keyword">new</span> <span class="title class_">MockAdapter</span>(service)</span><br><span class="line">    <span class="keyword">const</span> systemApi = results[<span class="number">1</span>].<span class="property">default</span></span><br><span class="line"></span><br><span class="line">    mock.<span class="title function_">onGet</span>(systemApi.<span class="property">getSystemVerify</span>).<span class="title function_">reply</span>(<span class="number">200</span>, &#123; <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">data</span>: &#123; <span class="attr">machineCode</span>: <span class="string">&#x27;djalksdjlaksjd123111sda&#x27;</span> &#125; &#125;)</span><br><span class="line">    mock.<span class="title function_">onPost</span>(systemApi.<span class="property">getSystemUpload</span>).<span class="title function_">reply</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = config.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查是否有文件被上传</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="title function_">has</span>(<span class="string">&#x27;file&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件</span></span><br><span class="line">        <span class="keyword">const</span> file = data.<span class="title function_">get</span>(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">200</span>, &#123; <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">data</span>: &#123; <span class="attr">expireDate</span>: <span class="string">&#x27;2025-01-01 11:22:33&#x27;</span>, <span class="attr">mateMaxNum</span>: <span class="number">100</span> &#125; &#125;]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">500</span>, &#123; <span class="attr">error</span>: <span class="string">&#x27;No file provided&#x27;</span> &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    mock.<span class="title function_">onAny</span>().<span class="title function_">passThrough</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我就是在请求的位置加了一段代码.</p><p>上传和获取的接口就被我模拟了, 其他地方正常写</p><p>这段代码的逻辑就是,  当遇到 <code>systemApi.getSystemVerify</code> 和 <code>systemApi.getSystemUpload</code> 这两个 <strong>API</strong> 的时候拦截, 其他 <strong>pass</strong></p><p>这是他最常用最简单的功能</p><p>他还有各种玩法, 比如模拟网络超时, 网络错误, 正则匹配路径, 甚至还可以做单元测试.</p><p>这种在定了接口但是没有API的时候太好用.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> axios-mock-adapter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己实现一个 bind</title>
      <link href="/2023/12/07/shuati/001_bind/"/>
      <url>/2023/12/07/shuati/001_bind/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JavaScript 中，<code>bind</code> 方法是用来改变函数的 <code>this</code> 指向的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你直接写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myBind</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron url启动, 注册表, 打包</title>
      <link href="/2023/12/07/electron/electron_caiken_01/"/>
      <url>/2023/12/07/electron/electron_caiken_01/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>最近一直在做 electron 项目, 遇到了一些问题, 这里记录一下</p><h3 id="01-url启动"><a href="#01-url启动" class="headerlink" title="01. url启动."></a>01. url启动.</h3><p>首先原生就有方法能够写, 本质上就是在注册表写入.</p><p><a href="https://github.com/tanlanchou/tblog/blob/view/img/Snipaste_2023-12-07_11-41-01.png?raw=true" title="自定义协议" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/tanlanchou/tblog/blob/view/img/Snipaste_2023-12-07_11-41-01.png?raw=true" alt="自定义协议"></a></p><p>上图自定义协议</p><p><a href="https://github.com/tanlanchou/tblog/blob/view/img/Snipaste_2023-12-07_11-41-37.png?raw=true" title="软件路径" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/tanlanchou/tblog/blob/view/img/Snipaste_2023-12-07_11-41-37.png?raw=true" alt="软件路径"></a></p><p>上图具体软件路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">setAsDefaultProtocolClient</span>(protocol[, path, args])</span><br></pre></td></tr></table></figure><blockquote><p>app.setAsDefaultProtocolClient(protocol[, path, args])</p><p>protocol string - The name of your protocol, without :&#x2F;&#x2F;. For example, if you want your app to handle electron:&#x2F;&#x2F; links, call this method with electron as the parameter.</p><p>path string (optional) Windows - The path to the Electron executable. Defaults to process.execPath</p><p>args string[] (optional) Windows - Arguments passed to the executable. Defaults to an empty array<br>Returns boolean - Whether the call succeeded.</p></blockquote><p>其实这个方法是最好的, 因为他不需要其他操作. 你写就好了. 并且跨平台.</p><p>但是他有一个缺点, 就是必须软件启动一次以后, 因为他是在你主进程里面, 比如我这个软件就不行, 因为必须支持不打开就能触发.</p><p>所以我尝试了另一种方式. <code>nsis</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;nsis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;oneClick&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;perMachine&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowToChangeInstallationDirectory&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deleteAppDataOnUninstall&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./installer.nsh&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>下面是 installer.nsh 内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!macro customInstall</span><br><span class="line">  DeleteRegKey HKCR &quot;ipc.vnc.loader&quot;</span><br><span class="line">  WriteRegStr HKCR &quot;ipc.vnc.loader&quot; &quot;&quot; &quot;URL:ipc.vnc.loader&quot;</span><br><span class="line">  WriteRegStr HKCR &quot;ipc.vnc.loader&quot; &quot;URL Protocol&quot; &quot;&quot;</span><br><span class="line">  WriteRegStr HKCR &quot;ipc.vnc.loader\shell&quot; &quot;&quot; &quot;&quot;</span><br><span class="line">  WriteRegStr HKCR &quot;ipc.vnc.loader\shell\Open&quot; &quot;&quot; &quot;&quot;</span><br><span class="line">  WriteRegStr HKCR &quot;ipc.vnc.loader\shell\Open\command&quot; &quot;&quot; &quot;$INSTDIR\$&#123;APP_EXECUTABLE_FILENAME&#125; %1&quot;</span><br><span class="line">!macroend</span><br><span class="line"></span><br><span class="line">!macro customUnInstall</span><br><span class="line">  DeleteRegKey HKCR &quot;ipc.vnc.loader&quot;</span><br><span class="line">!macroend</span><br></pre></td></tr></table></figure><p>就可以了, 这种写法同样万金油, 只是麻烦.</p><h3 id="02-icon"><a href="#02-icon" class="headerlink" title="02. icon"></a>02. icon</h3><p>更改图标, 查了很多资料, 在 <strong>electron-builder.json</strong> 中 win 下面加了 icon 还是会报错, 会使用默认图片.</p><p>后来在看这个issue的时候 <a href="https://github.com/ElectronNET/Electron.NET/issues/292">https://github.com/ElectronNET/Electron.NET/issues/292</a> 给了我启发.</p><p>也就是说, 打包以后他其实是在打包下的一个目录. 于是我测试了一下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../dist/icon.ico&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>解决.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> electron </tag>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>url 通过协议启动应用程序</title>
      <link href="/2023/12/01/javascript/url_open_software/"/>
      <url>/2023/12/01/javascript/url_open_software/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="01-url-如何关联到应用程序"><a href="#01-url-如何关联到应用程序" class="headerlink" title="01. url 如何关联到应用程序?"></a>01. url 如何关联到应用程序?</h1><p>做过html肯定都知道下面这段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:xxx@xxx.com&quot;</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>href</code>属性，我们可以指定一个url，当用户点击这个链接的时候，浏览器就会打开一个新的浏览器窗口，并且打开一个新的邮件客户端，并将邮件地址填入其中。</p><p>那么，url 如何关联到应用程序呢？</p><h1 id="02-协议怎么来的"><a href="#02-协议怎么来的" class="headerlink" title="02. 协议怎么来的?"></a>02. 协议怎么来的?</h1><p>这里需要区分5个不同的平台, 也就是 windows, mac, linux, android, ios</p><ol><li>windows 在注册表中注册你的自定义 URL 协议，指定应用程序的处理器</li><li>mac 在应用程序的 Info.plist 文件中注册自定义 URL 协议，指定应用程序的处理器</li><li>linux 通过注册 MIME 类型和关联它们的处理程序来实现</li><li>android AndroidManifest.xml 文件, 注册 <intent-filter></li><li>ios 同样Info.plist</li></ol><p>也就是说,你的程序在安装的时候,需要注册一个协议,然后在程序中指定这个协议,当用户点击这个协议的时候,就会打开你的程序.</p><h1 id="03-html-如何知道协议是否打开"><a href="#03-html-如何知道协议是否打开" class="headerlink" title="03. html 如何知道协议是否打开?"></a>03. html 如何知道协议是否打开?</h1><p>无法知道, 至少没有一个通用的接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:xxx@xxx.com&quot;</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是没有返回值的, 网上查询有一个方案.</p><p><a href="https://github.com/ismailhabib/custom-protocol-detection">https://github.com/ismailhabib/custom-protocol-detection</a></p><p>他的方案其实是通过 hack 方式.</p><blockquote><p>Firefox: try to open the handler in a hidden iframe and catch exception if the custom protocol is not available.</p><p>Chrome: using window onBlur to detect whether the focus is stolen from the browser. When the focus is stolen, it assumes that the custom protocol launches external app and therefore it exists.</p><p>IEs and Edge in Win 8&#x2F;Win 10: the cleanest solution. IEs and Edge in Windows 8 and Windows 10 does provide an API to check the existence of custom protocol handlers.</p><p>Other IEs: various different implementation. Worth to notice that even the same IE version might have a different behavior (I suspect due to different commit number). It means that for these IEs, the implementation is the least reliable.</p></blockquote><p>他代码最近更新的也是5年前的. 而且更新的是 package.json.</p><p>但是我测试了国内使用的大部分浏览器的最新版本, 居然是可用的(包括最新版本chrome). 并不像我查询的其他文章说不可用.</p><p>还能说使用风险还是很大.</p><p>我也看了百度盘的方案, 方案就是协议里传参数, 都和服务器进行通信.</p><p>其实百度盘页面点下载, 打开F12 其实就知道了.</p><h3 id="04-总结"><a href="#04-总结" class="headerlink" title="04. 总结"></a>04. 总结</h3><p>最优情况还是使用百度的方案, 最稳定, 有就一定有, 不怕浏览器兼容性问题.</p><p>前提是需要软件是你自己的, 如果不是你自己的, 就只能看别人是否实现这一套或者你加一个启动器..</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IndexDB API</title>
      <link href="/2023/11/02/%5BQ103%5DIndexDB_Base/"/>
      <url>/2023/11/02/%5BQ103%5DIndexDB_Base/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-什么是IndexDB"><a href="#01-什么是IndexDB" class="headerlink" title="01. 什么是IndexDB?"></a>01. 什么是IndexDB?</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API</a></p><blockquote><p>IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。然而，不像 RDBMS 使用固定列表，IndexedDB 是一个基于 JavaScript 的面向对象数据库。IndexedDB 允许你存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。你只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。</p></blockquote><p>其实没得选, 如果要在浏览器存储大量东西,你只能选 IndexDB.</p><p>他可以异步, 支持事务, 有索引, 可以跨域. 而且是 NoSql.</p><p>还有就是他数据是结构化的, 说人话就是, 他理论上没有限制, 你可以存任何东西.</p><h3 id="02-浏览器支持问题"><a href="#02-浏览器支持问题" class="headerlink" title="02. 浏览器支持问题"></a>02. 浏览器支持问题</h3><p><a href="https://caniuse.com/?search=indexdb">https://caniuse.com/?search=indexdb</a></p><p>理论上只要你不兼容 IE, 问题都不大, 如果要兼容IE, 需要考虑 IndexDB不同版本的写法兼容性问题</p><h3 id="03-大小"><a href="#03-大小" class="headerlink" title="03. 大小"></a>03. 大小</h3><p>不同浏览器大小不同, 但是也不好测试.</p><p>因为你需要看每个浏览器自己的公告, 并且你也不知道随着更新是否会有调整, 每个版本都可能不太一样.</p><p>查了半天也没有谁去做了一个统计.</p><p>也可以通过下面代码进行检测.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">storage</span>.<span class="title function_">estimate</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">estimate</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> usedSpaceInMB = estimate.<span class="property">usage</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> totalSpaceInMB = estimate.<span class="property">quota</span> / <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只是这个代码也有问题</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageManager/estimate">https://developer.mozilla.org/zh-CN/docs/Web/API/StorageManager/estimate</a></p><blockquote><p>安全上下文: 此项功能仅在一些支持的浏览器的安全上下文（HTTPS）中可用。</p></blockquote><p>测试的时候需要注意</p><h3 id="04-文档"><a href="#04-文档" class="headerlink" title="04. 文档"></a>04. 文档</h3><p>首先推荐看文档</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API</a></p><p>这个比较复杂, 简单使用看阮一峰的也行</p><p><a href="https://www.ruanyifeng.com/blog/2018/07/indexeddb.html">https://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p><p>弄懂, 简单使用是没问题了.</p><h3 id="05-Indexdb-amp-IDBFactory"><a href="#05-Indexdb-amp-IDBFactory" class="headerlink" title="05. Indexdb &amp; IDBFactory"></a>05. Indexdb &amp; IDBFactory</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBFactory">https://developer.mozilla.org/zh-CN/docs/Web/API/IDBFactory</a></p><p>IDBFactory 对象表示 IndexedDB 工厂。 它提供打开和关闭数据库的方法。</p><p>也就是 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(name, version)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">deleteDatabase</span>(name)</span><br></pre></td></tr></table></figure><p>需要注意的是, 如果 <code>open</code> 的时候, 数据库不存在, 会自动创建.</p><p><code>open</code> 和 <code>deleteDatabase</code> 都会返回 <code>IDBOpenDBRequest</code></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest">https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest</a></p><p><code>IDBOpenDBRequest</code> 需要注意下面4个事件.</p><ol><li><code>blocked</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest">https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest</a></li><li><code>upgradeneeded</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/upgradeneeded_event">https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/upgradeneeded_event</a></li><li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/error_event">https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/error_event</a></li><li><code>success</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/success_event">https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/success_event</a></li></ol><p><code>blocked</code></p><blockquote><p>当一个网页或应用程序尝试打开一个已经被其他网页或应用程序打开并正在执行写入事务的数据库时，会触发 blocked 事件。</p></blockquote><p>所以这个事件的应用场景就需要考虑了, 我目前要写的场景是不需要这个事件的.</p><p>如果有这个多网页使用 indexDB 的情况, 就需要考虑了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;blocked&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>upgradeneeded</code></p><blockquote><p>The upgradeneeded event is fired when an attempt was made to open a database with a version number higher than its current version. </p></blockquote><p>字面意思, 在尝试用一个更高版本版本号打开数据库的时候, 就会触发这个事件.</p><p>其实还有一个情况, 就是首次打开的时候.</p><h3 id="05-IDBFactory"><a href="#05-IDBFactory" class="headerlink" title="05. IDBFactory"></a>05. IDBFactory</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase">https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase</a></p><p>IDBDatabase 就是当你使用 open 数据库之后的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onsuccess = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    db = event.<span class="property">target</span>.<span class="property">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他可以做什么？</p><p>首先获取这个数据库的基本信息</p><ol><li>name 数据库名称</li><li>version 数据库版本</li><li>objectStoreNames 表名称合集</li></ol><p>其次，也就是最主要的</p><ol><li>close()</li><li>createObjectStore()</li><li>deleteObjectStore()</li><li>transaction()</li><li>versionchange</li></ol><p>这里主要说前三个，第四个后面继续看。</p><p><code>close</code> 就是关闭数据库链接。在适当的时候关闭数据库，避免阻塞，内存过高等问题</p><p><code>createObjectStore</code> 创建表</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/createObjectStore">https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/createObjectStore</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createObjectStore</span>(name)</span><br><span class="line"><span class="title function_">createObjectStore</span>(name, options)</span><br></pre></td></tr></table></figure><p>创建一下试一试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"><span class="keyword">const</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;user&quot;</span>, &#123;</span><br><span class="line"><span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line"><span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectStore.<span class="title function_">add</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;tommy&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>, <span class="attr">sex</span>: <span class="number">1</span> &#125;);</span><br><span class="line">objectStore.<span class="title function_">add</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;tommy1&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;19&quot;</span>, <span class="attr">sex</span>: <span class="number">0</span> &#125;);</span><br><span class="line">objectStore.<span class="title function_">add</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;tommy2&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;20&quot;</span>, <span class="attr">sex</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">db.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>需要注意的是，建议 <code>autoIncrement</code> 设置，不然你需要自己设置 <code>id</code>.</p><p>其次，<code>createObjectStore</code> 只能在 <code>upgradeneeded</code> 阶段使用，不然会报错的.</p><p>这样就创建了一个表，并且添加了3条数据。</p><p><code>deleteObjectStore</code> 删除表</p><p>最开始有点懵，因为删除也不能直接在 <code>onsuccess</code>, 会报错，如果想要在 <code>upgradeneeded</code> 使用，难道我不更改版本就不能删除吗？</p><p>问了AI之后，给了一个方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库并获取数据库连接</span></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.<span class="title function_">open</span>(<span class="string">&quot;myDatabase&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行版本更改事务</span></span><br><span class="line">    <span class="keyword">var</span> versionChange = db.<span class="title function_">setVersion</span>(<span class="number">2</span>); <span class="comment">// 使用setVersion来创建版本更改事务</span></span><br><span class="line"></span><br><span class="line">    versionChange.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 在版本更改事务中删除 Object Store</span></span><br><span class="line">        <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&quot;myObjectStore&quot;</span>)) &#123;</span><br><span class="line">            db.<span class="title function_">deleteObjectStore</span>(<span class="string">&quot;myObjectStore&quot;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Object Store &#x27;myObjectStore&#x27; deleted.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Object Store &#x27;myObjectStore&#x27; not found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        versionChange = versionChange.<span class="property">transaction</span>;</span><br><span class="line">        versionChange.<span class="property">oncomplete</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Object Store deleted successfully.&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        versionChange.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error deleting Object Store: &quot;</span> + versionChange.<span class="property">error</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是我在 MDN 中搜索的时候，没有发现这个方法，于是 google 了一下这不是标准方法。</p><p><a href="https://stackoverflow.com/questions/9521689/getting-a-setversion-is-not-a-function-error-when-using-indexeddb">https://stackoverflow.com/questions/9521689/getting-a-setversion-is-not-a-function-error-when-using-indexeddb</a></p><p>MDN 官方例子当中确实也是版本变更的时候才删除 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/deleteObjectStore">https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/deleteObjectStore</a></p><p><code>versionchange</code></p><blockquote><p>The event is fired when a database structure change (upgradeneeded event send on an IDBOpenDBRequest or IDBFactory.deleteDatabase) was requested elsewhere (most probably in another window&#x2F;tab on the same computer). versionchange</p></blockquote><p>也就是说如果其他页面触发升级, 那么这个页面也会收到通知.</p><h3 id="06-IDBDatabase-transaction-method"><a href="#06-IDBDatabase-transaction-method" class="headerlink" title="06. IDBDatabase: transaction() method"></a>06. IDBDatabase: transaction() method</h3><p>事务，他可以做什么？</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction">https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">transaction</span>(storeNames)</span><br><span class="line"><span class="title function_">transaction</span>(storeNames, mode)</span><br><span class="line"><span class="title function_">transaction</span>(storeNames, mode, options)</span><br></pre></td></tr></table></figure><p><code>mode</code></p><ol><li><code>readonly</code></li><li><code>readwrite</code></li><li><code>versionchange</code></li></ol><p>模式3种，1,2 是打开事务以后， 读写还是只读，这里需要说一下，理论上 <code>readwrite</code> 可以全覆盖 <code>readonly</code>. 但是别一直使用 <code>readwrite</code></p><blockquote><p>一次只能打开一个读写事务，它会锁定数据库，防止其他事务同时访问。<br>当有读写事务处于活动状态时，只读事务将被阻塞，直到读写事务完成。</p></blockquote><p>不管是性能上，还是阻塞上，如果只需要读取，都应该选取 <code>readonly</code>.</p><p><code>versionchange</code> 是我看文档不明白的一个点，为什么需要这个模式？ 而且写测试代码没用</p><blockquote><p>这种类型的事务允许读取、修改和删除数据。也能够创建和删除Stores（数据表）和索引。这种类型的事务会在一个upgradeneeded事件被触发的时候自动创建，不能够手动创建。</p></blockquote><p>versionchange 可以执行数据库结构的升级、创建新的对象仓库、添加索引、执行数据迁移等操作</p><p>ok，上代码测试一下。</p><p>首先是 <code>readonly</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;readonly&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">`user`</span>);</span><br><span class="line"><span class="keyword">const</span> results = objectStore.<span class="title function_">getAll</span>();</span><br><span class="line">results.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &amp;&amp; r.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">name</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是正常的, 在只读情况尝试了一下 <code>add</code>, 直接报错</p><blockquote><p>Uncaught DOMException: Failed to execute ‘add’ on ‘IDBObjectStore’: The transaction is read-only.</p></blockquote><p>另外一个模式, <code>readwrite</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;readwrite&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">`user`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;tommy3&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>, <span class="attr">sex</span>: <span class="number">1</span> &#125;;</span><br><span class="line">objectStore.<span class="title function_">add</span>(data);</span><br><span class="line">db.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>同样的代码, 如果用在读写上. ok.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore">IDBObjectStore - Web APIs | MDN (mozilla.org)</a></p><p>这里包含了其他还能做的操作, 你使用事务, 最终还是要落在这上面.</p><p>需要注意的是 <code>readwrite</code> 其实也是可以读的, 但是建议分开, 原因刚才说清楚了.</p><p><code>versionchange</code> </p><blockquote><p>Allows any operation to be performed, including ones that delete and create object stores and indexes. Transactions of this mode cannot run concurrently with other transactions. Transactions in this mode are known as “upgrade transactions.”</p><p>允许执行任何操作，包括删除和创建对象存储和索引的操作。此模式的事务不能与其他事务并发运行。此模式的事务称为“升级事务”。</p><p>There is also another type of transactions: . It can do anything, but you can’t generate it manually.versionchange A transaction can be automatically created by IndexedDB while opening the database for the handler. After creating the transaction, it is necessary to add an item to the store as follows:</p><p>还有另一种类型的交易：。它可以做任何事情，但你不能手动生成它。versionchange</p><p>在为处理程序打开数据库时，IndexedDB可以自动创建事务。创建事务后，需要向存储中添加一个项目，如下所示：</p></blockquote><p>也就是说在触发数据库升级的时候, 自动触发这个事务.</p><p>我最开始有一个误解， 就是不同版本的数据库, 意味着本地有多个数据库, 你可以访问 <strong>version: 1</strong>, 也可以访问 <strong>version:2</strong></p><p>所以之前找了很久关于数据库迁移的问题, 后来明白了其实只能访问最新版本, 也不存在迁移数据这种做法(除非你是迁移 ObjectStore).</p><p>下面是我写的一个列子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onupgradeneeded</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">const</span> transaction = event.<span class="property">currentTarget</span>.<span class="property">transaction</span>;</span><br><span class="line">  <span class="keyword">const</span> roleObjectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;role&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span>, <span class="attr">autoIncrement</span>: <span class="literal">true</span>, &#125;);</span><br><span class="line">  roleObjectStore.<span class="title function_">add</span>(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;admin&quot;</span>, <span class="attr">createTime</span>: <span class="string">&quot;2023-11-11&quot;</span> &#125;);</span><br><span class="line">  roleObjectStore.<span class="title function_">add</span>(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;teacher&quot;</span>, <span class="attr">createTime</span>: <span class="string">&quot;2023-11-11&quot;</span> &#125;);</span><br><span class="line">  roleObjectStore.<span class="title function_">add</span>(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;student&quot;</span>, <span class="attr">createTime</span>: <span class="string">&quot;2023-11-11&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">  myStore.<span class="title function_">openCursor</span>().<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">      <span class="keyword">const</span> updateData = cursor.<span class="property">value</span>;</span><br><span class="line">      updateData.<span class="property">phone</span> = <span class="string">`0000000`</span> + updateData.<span class="property">id</span>;</span><br><span class="line">      cursor.<span class="title function_">update</span>(updateData).<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;updateData.name&#125;</span>更新了数据`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cursor.<span class="title function_">continue</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Entries all displayed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行了这个代码以后, 老版本的数据库就无法访问了.</p><h3 id="07-IDBTransaction"><a href="#07-IDBTransaction" class="headerlink" title="07. IDBTransaction"></a>07. IDBTransaction</h3><p>也就是 <code>trans1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trans1 = db.<span class="title function_">transaction</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;readwrite&quot;</span>);</span><br></pre></td></tr></table></figure><p>有5个属性</p><ol><li><code>db IDBDatabase</code> 对象的引用</li><li><code>durability</code> 定义了事务的持久化行为，即事务对数据库状态的持久性影响（但是是只读的，其实我不知道有什么用）</li><li><code>error</code> 如果事务在执行过程中遇到错误，<code>error</code> 属性会返回一个表示该错误的 <code>DOMError</code> 对象。</li><li><code>mode</code> 你创建事务的是 <code>mode</code></li><li><code>objectStoreNames</code> 包含此事务中所有对象仓库名称的数组。</li></ol><p>3个方法</p><ol><li>abort() 就是直接中断事务， 然后回滚，然后会触发 <code>abort</code> 事件</li><li>commit() 提交事务</li><li>objectStore() 返回 <code>IDBObjectStore</code> 对象</li></ol><p>commit 是我比较疑惑的一个点，因为之前我从来没有使用 commit 但是依然可以正常提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;readwrite&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">`user`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;tommy3&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>, <span class="attr">sex</span>: <span class="number">1</span> &#125;;</span><br><span class="line">objectStore.<span class="title function_">add</span>(data);</span><br><span class="line">db.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>我可以不停的添加，但是我并没有写 <code>transaction.commit()</code>， </p><blockquote><p>Note that commit() doesn’t normally have to be called — a transaction will automatically commit when all outstanding requests have been satisfied and no new requests have been made. commit() can be used to start the commit process without waiting for events from outstanding requests to be dispatched.</p></blockquote><p>没必要显式调用。</p><p><strong>三个事件</strong></p><ol><li><code>abort</code> 事务报错和取消的时候触发</li><li><code>complete</code> 事务完成之后触发</li><li><code>error</code></li></ol><h3 id="08-IDBObjectStore"><a href="#08-IDBObjectStore" class="headerlink" title="08. IDBObjectStore"></a>08. IDBObjectStore</h3><p>操作数据的核心接口, 包含一堆属性和方法</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore">https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore</a></p><p>这个没什么好说的, 其实你挨个试一试就知道怎么用了. </p><p>唯一值得一说的是游标. 确实在大量数据遍历的时候, 还是建议使用一下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">openCursor</span>()</span><br><span class="line"><span class="title function_">openCursor</span>(query)</span><br><span class="line"><span class="title function_">openCursor</span>(query, direction)</span><br></pre></td></tr></table></figure><p>这里是具体游标的返回, 可以直接编辑或者删除, 详情看下面的链接</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor">https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor</a></p><h3 id="09-总结"><a href="#09-总结" class="headerlink" title="09. 总结"></a>09. 总结</h3><p>其实到这里, 基本使用就应该没有问题. 该知道的方法就都该知道了.</p><p>剩下就是灵活应用的问题了.</p><p>自己写一个应用吧</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> indexDB </tag>
            
            <tag> 浏览器存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript this 指向</title>
      <link href="/2023/09/03/%5BQ102%5Djavascript_this_link/"/>
      <url>/2023/09/03/%5BQ102%5Djavascript_this_link/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-this-指向"><a href="#01-this-指向" class="headerlink" title="01. this 指向"></a>01. this 指向</h3><p>首先都知道的, function 中 this 指向基于调用者, 谁调用你 this 指向谁.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br></pre></td></tr></table></figure><p>做一个最简单的测试, 输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="02-bind-call-apply-改变-this"><a href="#02-bind-call-apply-改变-this" class="headerlink" title="02. bind, call, apply 改变 this"></a>02. bind, call, apply 改变 this</h3><p>如果全是正常 fucntion 那么肯定 this 全部指向 window.</p><p>但是你一颗使用 bind, call, apply 改变 this 指向.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">bind</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">call</span>(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = a.<span class="title function_">apply</span>(&#123;&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br></pre></td></tr></table></figure><p>详细语法看下面链接</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a></p><h3 id="03-new"><a href="#03-new" class="headerlink" title="03. new"></a>03. new</h3><p>new 关键字, 创建一个对象, 并且让这个对象继承构造函数的原型, 详情可见 <a href="/tblog/2023/07/03/js_new/">javascript new 做了什么？</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">d_v</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d1 = <span class="keyword">new</span> <span class="title function_">d</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`const d1 = new d();`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;window this.d_v:&quot;</span>, <span class="variable language_">this</span>.<span class="property">d_v</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;window d1.d_v:&quot;</span>, d1.<span class="property">d_v</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">func, ...params</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的对象，并且把原型链副浅拷贝到新的对象中</span></span><br><span class="line">    <span class="comment">//func.prototype </span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="comment">//调用 func, 并且以 obj为this.</span></span><br><span class="line">    <span class="keyword">const</span> result = func.<span class="title function_">apply</span>(obj, params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> o = result || obj;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d2 = <span class="title function_">_new</span>(d);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`const d2 = _new(d);`</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;window this.d_v:&quot;</span>, <span class="variable language_">this</span>.<span class="property">d_v</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;window d1.d_v:&quot;</span>, d1.<span class="property">d_v</span>);</span><br></pre></td></tr></table></figure><h3 id="04-嵌套-function"><a href="#04-嵌套-function" class="headerlink" title="04. 嵌套 function"></a>04. 嵌套 function</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">f_v</span> = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">f</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">e</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">e_v</span> = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">h_v</span> = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">e</span>();</span><br><span class="line">    <span class="title function_">h</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g this.f_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">f_v</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g this.e_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">e_v</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g this.h_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">h_v</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g1 = <span class="keyword">new</span> <span class="title function_">g</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window this.f_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">f_v</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window this.e_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">e_v</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window this.h_v:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">h_v</span>);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g this.f_v: undefined</span><br><span class="line">g this.e_v: 7</span><br><span class="line">g this.h_v: undefined</span><br><span class="line">window this.f_v: 5</span><br><span class="line">window this.e_v: undefined</span><br><span class="line">window this.h_v: 8</span><br></pre></td></tr></table></figure><ol><li>new g() 将 function g 内部 this 只想 g 的原型链</li><li>f() 内部 this 指向 window</li><li>e() 箭头函数指向 g 原型链</li><li>h() 函数 this 指向 window</li></ol><p>也就是说函数嵌套下层函数 this 指向是 window</p><h3 id="05-箭头函数"><a href="#05-箭头函数" class="headerlink" title="05. 箭头函数"></a>05. 箭头函数</h3><p>上面的例子已经说明了 this 指向的规则,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>里面 this 指向上层.</p><h3 id="06-object"><a href="#06-object" class="headerlink" title="06. object"></a>06. object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">getB</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getB`</span>, <span class="variable language_">this</span>.<span class="property">b</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getA</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getA`</span>, <span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getB</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getB1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getB1`</span>, <span class="variable language_">this</span>.<span class="property">b</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i.<span class="title function_">getA</span>();</span><br><span class="line">i.<span class="title function_">getB1</span>();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><h3 id="07-简单总结"><a href="#07-简单总结" class="headerlink" title="07. 简单总结."></a>07. 简单总结.</h3><p>this 你用 function 大都指向 window.</p><p>除非你使用 object 或者 使用 apply, new 之类的方式改变 this 指向.</p><p>但是如果你改变指向的下层, 你继续使用function 他还是会指向 window.</p><p>这个使用使用箭头函数, 指向上层.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex 属性详解</title>
      <link href="/2023/09/01/%5BQ101%5DFlex_attr/"/>
      <url>/2023/09/01/%5BQ101%5DFlex_attr/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>写这个的目的是为了详细解释一下 flex 每个属性的意义和用法, 原因是因为突然发觉我自己对于 flex 细节并不是完全清楚</p><h3 id="01-flex-direction"><a href="#01-flex-direction" class="headerlink" title="01. flex-direction"></a>01. flex-direction</h3><p>flex-direction 决定主轴的方向（即项目的排列方向）</p><p>首先需要注意的是主轴的方向, 默认是水平方向, 即从左到右, 水平方向是主轴, 垂直方向是交叉轴</p><p><a href="/img/bg2015071004.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/img/bg2015071004.png" alt="alt text"></a></p><p>也就是上图中 main axis, 交叉轴是 cross axis.</p><p>两个可以相互交换</p><p>也就是说 main axis 为交叉轴, cross axis 为主轴.</p><p>其中 flex-direction 属性有 4 个取值</p><ul><li>row-reverse </li><li>column-reverse</li><li>row</li><li>column</li></ul><p>默认值是 row, 也就是普通的水平排列, 如果 column 就是垂直排列.</p><p>如果是反转 row-reverse, column-reverse .</p><p>row-reverse 就是从右到左, column-reverse 就是从下到上</p><p>只是需要注意的是 row-reverse 是真的全部从右到左, 整个布局都是右对齐了.</p><p>但是 column-reverse 只是数据从下到上, 对齐方式还是从上到下</p><h3 id="02-flex-wrap"><a href="#02-flex-wrap" class="headerlink" title="02. flex-wrap"></a>02. flex-wrap</h3><p>flex-wrap 决定如果一行排不下, 是否换行.</p><p>flex-wrap 属性有 3 个取值</p><ul><li>nowrap</li><li>wrap-reverse</li><li>wrap</li></ul><p>默认值是 nowrap, 也就是不换行.<br>wrap-reverse 就是从下到上, 也就是从左到右<br>wrap-reverse 换行, 从上到下, 从左到右.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: row;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:white</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>flex-warp: nowrap</code> 时, 也就是默认值. 不管我有多少个 <code>box</code>, 都只会在一行显示, 他只会按比例缩小每一个 <code>box</code>.</p><p>如果采用 <code>flex-warp: wrap</code>, 也就是自动换行. 这个时候就会出现换行的情况. 排不下了就自动换.</p><p><code>wrap-reverse</code> 自动换行, 只是第一行在左下方, 也是从左到右.</p><h3 id="03-flex-flow"><a href="#03-flex-flow" class="headerlink" title="03. flex-flow"></a>03. flex-flow</h3><p>这个比较简单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是前面两个的结合</p><h3 id="04-justify-content"><a href="#04-justify-content" class="headerlink" title="04. justify-content"></a>04. justify-content</h3><p>justify-content 属性定义了项目在主轴上的对齐方式.</p><p>只是主轴的对齐方式, 这个和 flex-direction 有关.</p><p>justify-content 属性有 6 个取值,</p><ul><li>flex-start</li><li>flex-end</li><li>center</li><li>space-between</li><li>space-around</li><li>space-evenly</li></ul><p>默认值是 flex-start, 也就是从左到右</p><p>flex-end 就是从右到左</p><p>center 就是居中</p><p>space-between 就是两端对齐, 也就是两边留白, 中间对齐</p><p>space-around 就是两边留白, 两边对齐, 中间对齐</p><p>space-evenly 就是两边留白, 两边对齐, 中间对齐</p><p><a href="/image/image.png" title="Alt text" class="gallery-item" style="box-shadow: none;"> <img src="/image/image.png" alt="Alt text"></a></p><h3 id="05-align-items"><a href="#05-align-items" class="headerlink" title="05. align-items"></a>05. align-items</h3><p><code>align-items</code> 属性定义项目在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>flex-start 交叉轴的起点对齐.</p><p>flex-end 交叉轴的终点对齐.</p><p>center 交叉轴的中点对齐.</p><p>baseline 项目的第一行文字的基线对齐.</p><p>stretch 如果项目未设置高度或设为auto, 将占满整个容器的高度.</p></blockquote><p><a href="/image/image01.png" title="Alt text" class="gallery-item" style="box-shadow: none;"> <img src="/image/image01.png" alt="Alt text"></a></p><p>这里只是针对交叉轴, 需要明白之前那张图,没有设置高度的情况下, 默认是占满整个容器的高度.</p><p>所以交叉轴就是在这个高度下去浮动.</p><p>这里 baseline 比较特殊, 他是根据文字的基线去对齐.</p><p>这个在需要文字,图片,icon 对齐的时候就有用了.</p><blockquote><p>stretch 如果项目未设置高度或设为auto, 将占满整个容器的高度.</p></blockquote><p><code>stretch</code> 是默认值, 不管你是否设置 <code>align-items</code>, 都会触发.</p><p>也就是说 <code>flex</code> 容器如果设置了高度, 比如 <strong>600px</strong> , <code>flex</code> 容器内容有三行. 那么每个容器都是 <strong>200px</strong> 高度</p><h3 id="06-align-content"><a href="#06-align-content" class="headerlink" title="06. align-content"></a>06. align-content</h3><p>这个其实是我当时的一个疑惑点</p><blockquote><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p></blockquote><p>首先什么事多个轴线? 不是有多个主轴或者多个交叉轴. 而是单行的情况, 就认为没有交叉轴,也就是只有主轴.</p><p>所以 <code>align-content</code> 换句话说,就是单行情况下不生效. 至少两行才能生效</p><p>那么 <code>align-items</code> 和 <code>align-content</code> 有什么区别呢?</p><p><code>align-items</code> 是针对单个容器内容在交叉轴的对齐方式.</p><p><code>align-content</code> 的设置对象是所有行.</p><blockquote><p>flex-start：与交叉轴的起点对齐。</p><p>flex-end：与交叉轴的终点对齐。</p><p>center：与交叉轴的中点对齐。</p><p>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</p><p>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p><p>stretch（默认值）：轴线占满整个交叉轴。</p></blockquote><p>可以看下这个图</p><p><a href="/img/image02.png" title="Alt text" class="gallery-item" style="box-shadow: none;"> <img src="/img/image02.png" alt="Alt text"></a></p><h3 id="07-容器总结"><a href="#07-容器总结" class="headerlink" title="07. 容器总结"></a>07. 容器总结</h3><p>上面的所有属性都是基于容器的</p><ol><li><code>flex-direction</code> 主轴方向</li><li><code>flex-warp</code> 容器是否换行和换行的方式</li><li><code>flex-flow</code> 是上面两个属性的合并</li><li><code>justify-content</code> 主轴对齐方式</li><li><code>align-items</code> 交叉轴对齐方式</li><li><code>align-content</code> 交叉轴多行对齐方式</li></ol><p>上面已经能做很多事情了</p><p>比如我们常用的垂直居中， 就只需要 </p><p><code>justify-content</code> 主轴对齐方式<br><code>align-items</code> 交叉轴对齐方式</p><p>两个对齐就ok了。</p><h3 id="08-order"><a href="#08-order" class="headerlink" title="08. order"></a>08. order</h3><p>这个属性是我之前完全忽略的属性</p><blockquote><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p></blockquote><p>经过一个简单的测试 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;order:99&quot;</span>&gt;</span>5(order 99)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;order:100&quot;</span>&gt;</span>6(order 100)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是说 <code>order</code> 排序越小越在前面，但是前提是在有order设置里面。也就是说，如果我将 order 设置为0 或者不设置，那么他们永远是根据dom顺序来。设置 <code>order</code> 只能排后面</p><h3 id="09-flex-grow"><a href="#09-flex-grow" class="headerlink" title="09. flex-grow"></a>09. flex-grow</h3><p>flex-grow 放大比例</p><blockquote><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p></blockquote><p>这个属性是针对剩余空间的，如果空间不足，那么就按照比例分配</p><p>于是我按照这个思路写了一个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-direction</span>: row;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>:<span class="number">1px</span> solid black</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-grow</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;flex-grow: 3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果我发现不对， 因为3并没有其他的两倍，但是下面这个链接又是ok的</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow">https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow</a></p><p>这点我非常疑惑，后续再研究吧。</p><h3 id="10-flex-shrink"><a href="#10-flex-shrink" class="headerlink" title="10. flex-shrink"></a>10. flex-shrink</h3><blockquote><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p></blockquote><p>怎么理解呢？</p><blockquote><p>子元素当父元素宽度不够用时，自己调整自己所占的宽度比，这个flex-shrink设置为1时，表示所有子元素大家同时缩小来适应总宽度。当flex-shrink设置为0时，表示大家都不缩小适应</p></blockquote><p>和 <code>flex-grow</code> 类似, 只是有一个前提, 如果空间不够的话.</p><p>比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, .<span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#00f</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;flex-shrink:2&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有就是也出现了, 并没有等比缩小. 这个具体还要后面学习</p><h3 id="11-flex-basis"><a href="#11-flex-basis" class="headerlink" title="11. flex-basis"></a>11. flex-basis</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis">https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis</a></p><blockquote><p>CSS 属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空</p></blockquote><h3 id="12-flex"><a href="#12-flex" class="headerlink" title="12. flex"></a>12. flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br></pre></td></tr></table></figure><h3 id="13-align-self"><a href="#13-align-self" class="headerlink" title="13. align-self"></a>13. align-self</h3><blockquote><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p></blockquote><p>这个没什么好说的, 如果你前面理解了后面也理解了.</p><h3 id="14-总结"><a href="#14-总结" class="headerlink" title="14. 总结."></a>14. 总结.</h3><p>flex 分为主轴和交叉轴, 两者可相互交换, 可以使用 flex-dirction 进行控制.</p><p>flex 默认不换行, 你可以使用 flex-wrap 进行换行控制.</p><p>flex-flow 对上面两个进行组合. flex-flow: flex-direction flex-wrap</p><p>justify-content 控制主轴对齐方式.</p><p>align-items 控制交叉轴对齐方式.</p><p>align-content 控制多根轴线的对齐方式(也就是整体项目, 而不是单独某个box)</p><p>上面就是 flex 项目整体的操作, 接下来是每个容器操作</p><p>order 可以规定容器显示顺序</p><p>flex-grow 可以规定容器放大比例</p><p>flex-shrink 可以规定容器缩小比例</p><p>flex-basis 可以规定容器初始大小</p><p>flex 可以规定容器放大缩小比例和初始大小</p><p>align-self 可以规定容器单独交叉轴对齐方式</p><p>大概得语法就是这样了, 后续我会基于我的疑惑点在学习</p><p><a href="https://www.cnblogs.com/cblx/p/12272729.htm">https://www.cnblogs.com/cblx/p/12272729.htm</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> flex </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号网页踩坑？</title>
      <link href="/2023/09/01/%5Bwechat%5Dwechat_website/"/>
      <url>/2023/09/01/%5Bwechat%5Dwechat_website/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-开发者工具提示未关注该测试号？"><a href="#01-开发者工具提示未关注该测试号？" class="headerlink" title="01. 开发者工具提示未关注该测试号？"></a>01. 开发者工具提示未关注该测试号？</h3><p><a href="https://learnku.com/laravel/t/7831/the-developer-tooltip-does-not-pay-attention-to-the-test-number">https://learnku.com/laravel/t/7831/the-developer-tooltip-does-not-pay-attention-to-the-test-number</a></p><p>虽然是五年前的回答, 但是能解决问题</p><p>扫码关注即可.</p><h3 id="02-如果获取-openId"><a href="#02-如果获取-openId" class="headerlink" title="02. 如果获取 openId"></a>02. 如果获取 openId</h3><p>首先你需要知道 openId 和 unionid 的区别</p><p>网上随意一篇文章就能解释清楚</p><p><a href="https://blog.csdn.net/naocan10211050/article/details/123865184">https://blog.csdn.net/naocan10211050/article/details/123865184</a></p><p>一个多应用唯一，一个单应用唯一。</p><p>如何获取，流程大致是</p><ol><li>用户关注公众号</li><li>用户点击网页授权</li><li>服务器获取到 code</li><li>服务器通过 code 获取 openId</li></ol><p>至于具体代码，有很多sdk，不想自己写就用sdk就好。</p><h3 id="03-本地调试"><a href="#03-本地调试" class="headerlink" title="03. 本地调试"></a>03. 本地调试</h3><p>首先你需要有 appId 和 appSecret，其次你关注了测试号，是开发者。</p><p>然后在</p><p><a href="/%5Cimg%5C528c7feafa5a997a4d00099ac5926804.png" title="Alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C528c7feafa5a997a4d00099ac5926804.png" alt="Alt text"></a></p><p>这个位置输入你的测试地址，可以是本地地址，在测试的时候。</p><p>如果需要调试服务端，比如你已经部署上去了，想调试，但是服务又必须登录。</p><p>可以改host或者使用nginx。</p><p>我一般用host，然后在微信开发者工具中调试。</p><h3 id="04-返回。"><a href="#04-返回。" class="headerlink" title="04. 返回。"></a>04. 返回。</h3><p>很多时候做网页上的东西，不设置返回。</p><p>但是手机上必须要，不管是小程序还是网页。</p><p>经常找不到返回只能靠手机的返回快捷键，导致小程序或者网页直接退出。</p><h3 id="05-总结"><a href="#05-总结" class="headerlink" title="05. 总结"></a>05. 总结</h3><p>目前大概这么多，这方面经验不算丰富。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 公众号 </tag>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows docker 安装遇到的坑</title>
      <link href="/2023/08/29/wsl_can_not_boot/"/>
      <url>/2023/08/29/wsl_can_not_boot/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>公司电脑 docker windows 安装完成以后, 打开docker报错, wsl报错</p><p>于是命令行查看 wsl –list 发现安装了 wsl, 只是没有分发版本</p><p>那就安装呗, 于是遇到了第一个问题</p><p><strong>microsoft store 打不开, 一直转圈</strong></p><p>于是各种查资料, 比如改 dns, 改网络设置, 改一系列的, 加代理也不行.</p><p>搞的沉默了.</p><p>于是算了直接命令行安装吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -d Ubuntu-20.04</span><br></pre></td></tr></table></figure><p>能下载, 但是安装报错, 还是 WSL 报错, 真的沉默了.</p><p>于是为了解决问题, 继续查为什么 WSL 不行, 试一试 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure><p>结果无法启动, 为什么无法启动, google一查, 是因为 windows update 没有打开.</p><p>以为问题解决了, 结果无法打开, 因为没有权限..</p><p>直接注册表也不行 </p><p><strong>HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesWaaSMedicSvc</strong></p><p>没有 wuauserv 完全控制权限。</p><p>根源是权限来源不对，改成对应权限组就ok了</p><p>详情可以看下这篇文章 </p><p><a href="https://www.bilibili.com/read/cv11939860/">https://www.bilibili.com/read/cv11939860/</a></p><p>允许 update 以后， 商店也能打开了。</p><p>解决</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> windows </tag>
            
            <tag> update </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 createVNode &amp; render</title>
      <link href="/2023/08/27/vue3_plugin/"/>
      <url>/2023/08/27/vue3_plugin/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>之前用 Vue2.x 写了一个 loading，思路是</p><p>写一个 vue 文件 &#x3D;&gt; 使用 Vue.extend 创建虚拟dom &#x3D;&gt; 写一个 install 插件，插件中写方法调用 vue 文件中的开关 </p><p>然后就可以在 vue 或者其他文件中使用了。</p><p>Vue3 区别不大，只是 API 有变化</p><h3 id="01-CreateVnode-amp-render"><a href="#01-CreateVnode-amp-render" class="headerlink" title="01. CreateVnode &amp; render"></a>01. CreateVnode &amp; render</h3><p>Vue2.x extend 没有了，他的作用是继承，并且创建和宣传了组件。</p><p>在 Vue3.x 中使用 <code>CreateVnode</code> &amp; <code>render</code> 来代替</p><p><code>CreateVnode</code> 创建虚拟dom，<code>render</code> 渲染真实dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode, render &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> loading <span class="keyword">from</span> <span class="string">&quot;./Index.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = <span class="title function_">createVNode</span>(loading);</span><br><span class="line"><span class="keyword">const</span> mountNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="title function_">render</span>(o, mountNode);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mountNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$loading</span> = &#123;</span><br><span class="line">      <span class="attr">show</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        o.<span class="property">component</span>.<span class="property">exposed</span>.<span class="property">enableFlg</span>.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">hide</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        o.<span class="property">component</span>.<span class="property">exposed</span>.<span class="property">enableFlg</span>.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就创建了。</p><h3 id="02-exposed"><a href="#02-exposed" class="headerlink" title="02. exposed"></a>02. exposed</h3><p>之前 <strong>Vue2.x</strong> 是直接可以访问属性的，但是 <strong>Vue3.x</strong> 是不行的，需要设置 <code>defineExpose</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test11111&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;enableFlg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        test</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, defineExpose &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> enableFlg = <span class="title function_">ref</span>(<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineExpose</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    enableFlg</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="03-app-config-globalProperties"><a href="#03-app-config-globalProperties" class="headerlink" title="03. app.config.globalProperties"></a>03. app.config.globalProperties</h3><p><a href="https://cn.vuejs.org/api/application.html#app-config-globalproperties">https://cn.vuejs.org/api/application.html#app-config-globalproperties</a></p><blockquote><p>这是对 Vue 2 中 Vue.prototype 使用方式的一种替代，此写法在 Vue 3 已经不存在了。与任何全局的东西一样，应该谨慎使用。</p><p>如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show&quot;</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> show = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  instance.<span class="property">proxy</span>.<span class="property">$loading</span>.<span class="title function_">show</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> close = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  instance.<span class="property">proxy</span>.<span class="property">$loading</span>.<span class="title function_">hide</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 插件 </tag>
            
            <tag> createVNode </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 npm install 需要 sudo</title>
      <link href="/2023/08/27/sudo_npm_install/"/>
      <url>/2023/08/27/sudo_npm_install/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>其实以前我在linxu下开发都是直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install</span><br></pre></td></tr></table></figure><p>但是有时候会遇到一个问题，在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start </span><br></pre></td></tr></table></figure><p>或者其他命令的时候会遇到 <code>permission</code> 问题, 这个时候我一般选用两种解决办法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install</span><br><span class="line">sudo chmod -R 755 /path/to/your/project/node_modules</span><br></pre></td></tr></table></figure><p>问题解决。</p><p>但是这次我想知道是为什么，这些问题原因都是因为我必须 <code>sudo npm install</code> 导致的, 那么为什么需要 <code>sudo</code></p><h3 id="01-为什么需要-sudo"><a href="#01-为什么需要-sudo" class="headerlink" title="01. 为什么需要 sudo"></a>01. 为什么需要 sudo</h3><p>正常只是访问，安装当前项目是不需要 sudo 的，但是有一个东西是全局的，就是全局安装的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx -g</span><br></pre></td></tr></table></figure><p>你项目中可能有一些依赖，一些共享的东西，在安装过程中就遇见了。</p><p>然而全局安装一般安装地址是在 <code>/usr/local</code> 这种系统目录下，所以需要 <code>sudo</code></p><h3 id="02-解决办法"><a href="#02-解决办法" class="headerlink" title="02. 解决办法"></a>02. 解决办法</h3><p>就是移动全局安装包的位置</p><p><a href="https://blog.csdn.net/m0_59757074/article/details/130893787">https://blog.csdn.net/m0_59757074/article/details/130893787</a></p><p>我查看了这篇文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.npm-global</span><br><span class="line">npm config set prefix &#x27;~/.npm-global&#x27;</span><br><span class="line">export PATH=~/.npm-global/bin:$PATH</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>搞定。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>箭头函数有prototype吗？为什么？</title>
      <link href="/2023/08/20/%5BQ001%5DArrowFunctionvsFunction/"/>
      <url>/2023/08/20/%5BQ001%5DArrowFunctionvsFunction/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-x3D-gt-有没有原型链"><a href="#01-x3D-gt-有没有原型链" class="headerlink" title="01. () &#x3D;&gt; 有没有原型链"></a>01. () &#x3D;&gt; 有没有原型链</h3><p>这个我居然真不知道，真没有注意到这个问题</p><p>首先我知道箭头函数是直接绑定父级别 this 的, 也就类似于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _this = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _this.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是他确实没原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//&#123;constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>因为this指向上层的原因, 所以他不能作为构造函数</p><ul><li>箭头函数没有自己的 this，而是继承父作用域的 this</li><li>不支持 call bind，改变 this 指向。</li><li>不绑定 arguments</li><li>没有 prototype 属性</li></ul><h3 id="02-为什么不能-new"><a href="#02-为什么不能-new" class="headerlink" title="02. 为什么不能 new"></a>02. 为什么不能 new</h3><p>首先需要知道 new 做了什么, <a href="/tblog/2023/07/03/js_new/">new 做了什么？</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">func, ...params</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的对象，并且把原型链副浅拷贝到新的对象中</span></span><br><span class="line"><span class="comment">//func.prototype </span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//调用 func, 并且以 obj为this.</span></span><br><span class="line"><span class="keyword">const</span> result = func.<span class="title function_">apply</span>(obj, params);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = result || obj;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 new 其实就是复制原型链，到func当中执行，然后返回那个对象。</p><p>但是你 箭头函数，没有 prototype，你怎么复制？</p><p>如果你要强行 new 也不是不行，自己写 new 函数，以作用域当原型链..</p><p>只是没什么意义</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.extend</title>
      <link href="/2023/08/19/Vue_extends/"/>
      <url>/2023/08/19/Vue_extends/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-什么是-Vue-extend"><a href="#01-什么是-Vue-extend" class="headerlink" title="01. 什么是 Vue.extend"></a>01. 什么是 Vue.extend</h3><blockquote><p>Vue.extend 返回的是一个扩展实例构造器，也就是预设了部分选项的Vue实例构造器</p></blockquote><p>在实际的过程中，我尝试了使用 <code>Vue.extend</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm1 = <span class="keyword">new</span> <span class="title class_">MyComponent</span>();</span><br><span class="line">vm1.$mount(<span class="string">&#x27;#app1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm2 = <span class="keyword">new</span> <span class="title class_">MyComponent</span>();</span><br><span class="line">vm2.$mount(<span class="string">&#x27;#app2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>也就是说，你给他一个 options 返回你一个组件，你可以任意使用，比如注册为组件</p><p>这里的好处是什么？你可以动态创建组件，比如使用插件</p><p>比如我想写一个全局 loading 函数，那么我需要先写一个组件，然后通过 $mount 绑定到节点。</p><p>其中一种办法就是使用 Vue.extend 创建组件，然后 $mount.</p><p>然后通过一个js去调用他，上面那个就是一个简单的绑定的例子。</p><h3 id="02-Vue2-写一个loading"><a href="#02-Vue2-写一个loading" class="headerlink" title="02. Vue2 写一个loading"></a>02. Vue2 写一个loading</h3><p>首先写一个loading</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;centered-div&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; loadingMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: <span class="string">&quot;loading-components&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">loadingMessage</span>: <span class="string">&#x27;.&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">t</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">flag</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> max = <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">t</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">loadingMessage</span>.<span class="property">length</span> &gt;= max)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">loadingMessage</span> = <span class="string">&#x27;.&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">loadingMessage</span> += <span class="string">&#x27;.&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">t</span> !== <span class="literal">null</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">t</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">t</span> = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.container</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.centered-div</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后重点来了。</p><p>使用  Vue.extend(loading), 然后 new &amp; mount， 最后 append 到 body 上。</p><p>然后注册插件即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> loading <span class="keyword">from</span> <span class="string">&#x27;./loading-components.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(loading)</span><br><span class="line"><span class="keyword">const</span> myLoading = <span class="keyword">new</span> <span class="title function_">app</span>().$mount(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(myLoading.<span class="property">$el</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">        vm.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$loading</span> = &#123;</span><br><span class="line">            <span class="attr">show</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                loading.<span class="property">flag</span> = <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hide</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                loading.<span class="property">flag</span> = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 mian.js 中 Vue.use(…)</p><p>就可以调用了。</p><h3 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h3><p><strong>src\core\global-api\extend.ts</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title class_">Vue</span>.<span class="property">extend</span> = <span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">any</span></span>): <span class="keyword">typeof</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Super</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">SuperId</span> = <span class="title class_">Super</span>.<span class="property">cid</span></span><br><span class="line">    <span class="keyword">const</span> cachedCtors = extendOptions.<span class="property">_Ctor</span> || (extendOptions.<span class="property">_Ctor</span> = &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[<span class="title class_">SuperId</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedCtors[<span class="title class_">SuperId</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name =</span><br><span class="line">      <span class="title function_">getComponentName</span>(extendOptions) || <span class="title function_">getComponentName</span>(<span class="title class_">Super</span>.<span class="property">options</span>)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; name) &#123;</span><br><span class="line">      <span class="title function_">validateComponentName</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, options: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">    &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">Component</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">cid</span> = cid++</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="title class_">Super</span>.<span class="property">options</span>, extendOptions)</span><br><span class="line">    <span class="title class_">Sub</span>[<span class="string">&#x27;super&#x27;</span>] = <span class="title class_">Super</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="title function_">initProps</span>(<span class="title class_">Sub</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="title function_">initComputed</span>(<span class="title class_">Sub</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">extend</span> = <span class="title class_">Super</span>.<span class="property">extend</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">mixin</span> = <span class="title class_">Super</span>.<span class="property">mixin</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">use</span> = <span class="title class_">Super</span>.<span class="property">use</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">    <span class="comment">// can have their private assets too.</span></span><br><span class="line">    <span class="variable constant_">ASSET_TYPES</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span><br><span class="line">      <span class="title class_">Sub</span>[<span class="keyword">type</span>] = <span class="title class_">Super</span>[<span class="keyword">type</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      <span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">components</span>[name] = <span class="title class_">Sub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">    <span class="comment">// later at instantiation we can check if Super&#x27;s options have</span></span><br><span class="line">    <span class="comment">// been updated.</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">superOptions</span> = <span class="title class_">Super</span>.<span class="property">options</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">extendOptions</span> = extendOptions</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">sealedOptions</span> = <span class="title function_">extend</span>(&#123;&#125;, <span class="title class_">Sub</span>.<span class="property">options</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache constructor</span></span><br><span class="line">    cachedCtors[<span class="title class_">SuperId</span>] = <span class="title class_">Sub</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Sub</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完其实就是一个继承</p><p>根据你传入的组件，然后新建一个构造函数，然后把父组件的属性都继承给你。</p><p>最后你 new 返回的值， 他会调用 this._init</p><p><strong>src\core\instance\init.ts</strong></p><p>也就是说，开始了组件创建的流程</p><h3 id="04-总结"><a href="#04-总结" class="headerlink" title="04. 总结"></a>04. 总结</h3><p>因为在写 Vue3 代码的时候，想要创建一个全局 loading，在 http 请求的时候调用。</p><p>突然想如果是 Vue2 会怎么写，于是就顺便看了下 Vue.extend 源码。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 插件 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 setup</title>
      <link href="/2023/07/31/vue3_setup/"/>
      <url>/2023/07/31/vue3_setup/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="怎么实现的？"><a href="#怎么实现的？" class="headerlink" title="怎么实现的？"></a>怎么实现的？</h3><p>之前在 <a href="/tblog/2023/06/20/vue_setup_created_before_created/">beforeCreate, created vs setup</a> 当中说过 setup 函数。</p><p>在 <strong>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts</strong> mountComponent 函数。</p><p>我们可以快速过一下他怎么实现的。</p><p>首先为什么会调用 <strong>mountComponent</strong> , 这个其实不管是 Vue2 还是 Vue3, 都是通过 patch 的调用，对比之后需要创建组件，才会调用。</p><p><strong>mountComponent</strong> 做了什么?</p><ol><li>获取组件实例 instance</li><li>如果是 keepalive 组件的话，将默认的渲染方法，加入到 KeepAliveContext 当然的 render 当中</li><li>setupComponent 执行, 解析 solt, props 然后执行 setup 函数，处理返回值，异步，function, 或者直接返回。 然后处理返回值，如果是 function 的话，就会替换默认 render。</li><li>调用 setupRenderEffect 渲染节点</li></ol><p>也就是说 <code>setupComponent</code> 调用, <code>setupRenderEffect</code> 渲染.</p><p>setupRenderEffect 做了些事情。</p><p>创建一个 componentUpdateFn 函数，通过 effect 函数，用来调度 componentUpdateFn, 调度的源码分析在 <a href="/tblog/2023/07/08/Vue3_queue/">vue3 任务调度源码解析</a>。 </p><p>简单理解就是，通过 proxy 劫持 set &#x3D;&gt; 触发到 scheduler 也就是</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">      componentUpdateFn,</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">      instance.<span class="property">scope</span> <span class="comment">// track it in component&#x27;s effect scope</span></span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p>中的 <code>() =&gt; queueJob(update)</code> 然后统一调度 <code>componentUpdateFn</code></p><p>componentUpdateFn 其实本质上是使用 patch 去对比，不过区分了是否有 <code>instance.isMounted</code>, 从而触发不同的生命周期</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance;</span><br><span class="line">   <span class="comment">// beforeMount hook</span></span><br><span class="line">   <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">       <span class="title function_">invokeArrayFns</span>(bm)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="title function_">patch</span>(</span><br><span class="line">       <span class="literal">null</span>,</span><br><span class="line">       subTree,</span><br><span class="line">       container,</span><br><span class="line">       anchor,</span><br><span class="line">       instance,</span><br><span class="line">       parentSuspense,</span><br><span class="line">       isSVG</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// mounted hook</span></span><br><span class="line">   <span class="keyword">if</span> (m) &#123;</span><br><span class="line">       <span class="title function_">queuePostRenderEffect</span>(m, parentSuspense)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line"></span><br><span class="line">   <span class="comment">// beforeUpdate hook</span></span><br><span class="line">   <span class="keyword">if</span> (bu) &#123;</span><br><span class="line">       <span class="title function_">invokeArrayFns</span>(bu)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">patch</span>(</span><br><span class="line">       prevTree,</span><br><span class="line">       nextTree,</span><br><span class="line">       <span class="comment">// parent may have changed if it&#x27;s in a teleport</span></span><br><span class="line">       <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>!)!,</span><br><span class="line">       <span class="comment">// anchor may have changed if it&#x27;s in a fragment</span></span><br><span class="line">       <span class="title function_">getNextHostNode</span>(prevTree),</span><br><span class="line">       instance,</span><br><span class="line">       parentSuspense,</span><br><span class="line">       isSVG</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (u) &#123;</span><br><span class="line">       <span class="title function_">queuePostRenderEffect</span>(u, parentSuspense)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及一个知识点. <code>queuePostRenderEffect</code> 并不是立刻执行的， 而是一个会加入队列，然后最后调用，先进先出。</p><p>所以 updated 或者 mounted 最后是这种结果</p><p>组件1 beforeMounted, 子组件1 beforeMounted &#x3D;&gt; 子组件1 mounted &#x3D;&gt; 组件1 mounted。</p><p>这大概就是 setup 的执行过程。</p><p>并且在需要注意的是，如果自定义了 render , 那么每次更新都会调用。 setup 函数只会在 mountComponent 的时候调用一次。</p><p>大概是这样.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 源码 </tag>
            
            <tag> setup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 登录</title>
      <link href="/2023/07/19/uniapp_login/"/>
      <url>/2023/07/19/uniapp_login/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>总是要登录的，每个平台的登录方式都不一样。</p><p>h5, app 只需要 token 就可以了，其他小程序，比如wx小程序，就是由他自己的流程，也就是说，如何去统一不同的登录方式？</p><p>如何整合，比如我是小程序和app都在使用，那么手机号就是很重要的点，但是尴尬的是，我并没有购买短信发送服务，只是似乎可以都不用短信，而是直接通过平台获取手机号(除了h5)</p><h3 id="01-获取手机号"><a href="#01-获取手机号" class="headerlink" title="01. 获取手机号"></a>01. 获取手机号</h3><p>uniapp 一键登录 <a href="https://ask.dcloud.net.cn/article/37965">https://ask.dcloud.net.cn/article/37965</a></p><p>单次收费 0.02</p><p>微信小程序 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html</a></p><blockquote><p>目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）；<br>该能力使用时，用户可选择绑定号码，或自主添加号码。平台会基于中国三大运营商提供的短信等底层能力对号码进行验证，但不保证是实时验证；<br>请开发者根据业务场景需要自行判断并选择是否使用，必要时可考虑增加其他安全验证手段。<br>开发者需合理使用，若被发现或用户举报开发者不合理地要求用户提供手机号等个人信息，中断了正常的使用流程，影响了用户的使用体验，微信有权依据《微信小程序平台运营管理规范》对该小程序进行处理。常见违规事例和具体解析；</p></blockquote><p>也就是说个人开发者是无法获取到手机号的，而且必须认证.</p><p>而且要收费，单次 0.03</p><p>支付宝小程序 <a href="https://opendocs.alipay.com/mini/api/getphonenumber">https://opendocs.alipay.com/mini/api/getphonenumber</a></p><blockquote><p>目前只支持商家会员卡功能的 alipay.user.info.share（支付宝会员授权信息查询接口）和小程序获取会员手机号功能的 getPhoneNumber 获取用户手机号，其他应用功能暂无法获取敏感信息，详见 用户信息申请流程。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my.<span class="title function_">getPhoneNumber</span>(<span class="title class_">Object</span> object)</span><br></pre></td></tr></table></figure><p>抖音小程序 <a href="https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/guide/open-capabilities/acquire-phone-number-acquire/">https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/guide/open-capabilities/acquire-phone-number-acquire/</a></p><p>和微信一个路子，不允许个人开发者使用，只允许企业开发者，并且通过了认证的开发者</p><p>看到这里，其实个人开发者通过手机号支持全平台的路子已经很麻烦了，你需要去找没有小程序有企业的朋友或者自己搞一个企业(虽然不贵，但是很麻烦)，而且微信和UNIAPP平台还要收费。</p><p>所以这个手机号登录流程暂时放弃了。</p><h3 id="02-邮箱登录"><a href="#02-邮箱登录" class="headerlink" title="02. 邮箱登录"></a>02. 邮箱登录</h3><p>发送邮件是免费的，可以直接使用个人的邮箱服务来发送邮件，拿 outlook 举例</p><p><a href="https://support.microsoft.com/zh-cn/office/%E4%BB%A5-outlook-com-%E5%8F%91%E9%80%81%E9%99%90%E5%88%B6-279ee200-594c-40f0-9ec8-bb6af7735c2e">https://support.microsoft.com/zh-cn/office/%E4%BB%A5-outlook-com-%E5%8F%91%E9%80%81%E9%99%90%E5%88%B6-279ee200-594c-40f0-9ec8-bb6af7735c2e</a></p><p>每日上限是 5000 封邮件，虽然用户会麻烦一些，但是可以在做商业程序的时候，再一个一个打通通道。</p><p>也就是，小程序用户不需要登录，只是需要获取平台的唯一ID. 当有整合需求，比如同时开始使用 app 或者其他小程序平台登录，那么就需要邮箱验证，或者通过 APP 生成token的方式整合。</p><h3 id="03-微信登录"><a href="#03-微信登录" class="headerlink" title="03. 微信登录"></a>03. 微信登录</h3><p>这种方式就是暂时不考虑其他小程序平台，但是兼容了APP，微信小程序</p><h3 id="03-登录"><a href="#03-登录" class="headerlink" title="03. 登录"></a>03. 登录</h3><p><a href="https://zh.uniapp.dcloud.io/api/plugins/login.html#">https://zh.uniapp.dcloud.io/api/plugins/login.html#</a></p><p><a href="https://zh.uniapp.dcloud.io/api/plugins/provider.html">https://zh.uniapp.dcloud.io/api/plugins/provider.html</a></p><p>首先看这个，这个是根据程序配置来确定。</p><p>比如在微信小程序中，只支持 weixin 登录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;weixin&#x27;<span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>在 app 当中，不仅仅可以支持 weixin 登录，还有很多其他登录方式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider<span class="punctuation">:</span> <span class="punctuation">[</span>`qq`<span class="punctuation">,</span> `sinaweibo`<span class="punctuation">,</span> `xiaomi`<span class="punctuation">,</span> `univerify`<span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>也就是说 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">getProvider</span>(&#123;</span><br><span class="line">    <span class="attr">service</span>: <span class="string">&#x27;oauth&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个代码是为了获取，当前支持哪些登录方式。</p><p>问题在于每个平台，每个登录方式都不一样，所以需要写很多不一样的代码, 所以需要兼容性处理。</p><p>举个例子，我现在的代码目前打算完全以微信登录为基准，兼容小程序，在这个基础之上我需要做什么？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">getProvider</span>(&#123;</span><br><span class="line">    <span class="attr">service</span>: <span class="string">&#x27;oauth&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">provider</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;weixin&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//这里我确认，支持微信</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail&quot;</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来就是很奇怪的问题了</p><p><a href="https://uniapp.dcloud.net.cn/tutorial/app-oauth-weixin.html">https://uniapp.dcloud.net.cn/tutorial/app-oauth-weixin.html</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p><p>根据文档他们两都是通过一个临时code，然后通过服务器向微信服务器鉴权，但是我在测试的时候直接拿到了数据</p><p>app端 通过微信登录返回数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;authResult&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7200</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;openid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unionid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errMsg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;login:ok&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里直接拿到了 unionid，难道是因为测试基座的问题？这点现在不得而知，那么先实现以下代码。</p><p>首先我有一个用于微信登录的接口 <strong>&#x2F;users&#x2F;login&#x2F;wx&#x2F;dsadas</strong></p><p>然后这个时候就需要 http 请求的接口了。</p><h3 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h3><p><strong>uniapp</strong> 本身有 <code>http.request</code>, 文档在这里 <a href="https://uniapp.dcloud.net.cn/api/request/request.html#">https://uniapp.dcloud.net.cn/api/request/request.html#</a></p><p>当然也可以使用其他请求框架，比如 <code>axios</code>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whiteList <span class="keyword">from</span> <span class="string">&#x27;./whiteList&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ajaxTimes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> baseUrl = <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> requestOptions &#123;</span><br><span class="line">url : <span class="built_in">string</span>;</span><br><span class="line">header? : <span class="built_in">any</span>;</span><br><span class="line">method : <span class="string">&quot;POST&quot;</span> | <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;PUT&quot;</span> | <span class="string">&quot;DELET&quot;</span>,</span><br><span class="line">data? : <span class="built_in">any</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRequest = (options : requestOptions) : <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> header = &#123; ...options.<span class="property">header</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(options.<span class="property">url</span>) === -<span class="number">1</span>) &#123;</span><br><span class="line">header[<span class="string">&quot;token&quot;</span>] = uni.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajaxTimes++;</span><br><span class="line">uni.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;加载中..&quot;</span>,</span><br><span class="line"><span class="attr">mask</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">uni.<span class="title function_">request</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: baseUrl + options.<span class="property">url</span>,</span><br><span class="line"><span class="attr">method</span>: options.<span class="property">method</span> || <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>: options.<span class="property">data</span> || &#123;&#125;,</span><br><span class="line"><span class="attr">timeout</span>: timeout,</span><br><span class="line">header,</span><br><span class="line"><span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(res)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">fail</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(err)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">ajaxTimes--;</span><br><span class="line"><span class="keyword">if</span> (ajaxTimes === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//  关闭正在等待的图标</span></span><br><span class="line">uni.<span class="title function_">hideLoading</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myRequest</span><br></pre></td></tr></table></figure><p><a href="https://uniapp.dcloud.net.cn/api/plugins/login.html#getuserinfo">https://uniapp.dcloud.net.cn/api/plugins/login.html#getuserinfo</a></p><p><a href="https://uniapp.dcloud.net.cn/api/plugins/login.html#getuserprofile">https://uniapp.dcloud.net.cn/api/plugins/login.html#getuserprofile</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 多端 </tag>
            
            <tag> uniapp </tag>
            
            <tag> login </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nestjs 登录和任务</title>
      <link href="/2023/07/19/uniapp_nest_login_list/"/>
      <url>/2023/07/19/uniapp_nest_login_list/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="增加login"><a href="#增加login" class="headerlink" title="增加login"></a>增加login</h3><p>因为现在没有Https证书，在申请当中，所以无法通过 wx 登录进行测试，所以先写一个临时的接口</p><p>于是我新建了一个 <strong>Controller</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过微信ID登录或者创建用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wxId String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> <span class="variable">UserReturn</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">loginWxUserByUnionid</span>(<span class="meta">@Body</span>(<span class="string">&#x27;wxId&#x27;</span>) <span class="attr">wxId</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">UserReturn</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> existUser = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">findUserByWxId</span>(wxId);</span><br><span class="line">  <span class="keyword">if</span> (!!existUser) &#123;</span><br><span class="line">    <span class="comment">//更新用户激活时间</span></span><br><span class="line">    existUser.<span class="property">activeTime</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">updateUser</span>(existUser.<span class="property">id</span>, existUser);</span><br><span class="line">    <span class="comment">//直接拿token, 返回用户</span></span><br><span class="line">    <span class="keyword">const</span> timex = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>().<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">this</span>.<span class="property">jwtService</span>.<span class="title function_">generateToken</span>(existUser.<span class="property">id</span> + timex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">userName</span>: existUser.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">token</span>: token,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newUser = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">  newUser.<span class="property">wxId</span> = wxId;</span><br><span class="line">  newUser.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="title function_">generateRandomName</span>(); <span class="comment">// 生成随机名称</span></span><br><span class="line">  newUser.<span class="property">createTime</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 自动填写创建时间</span></span><br><span class="line">  newUser.<span class="property">activeTime</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 暂未激活，设置为 null</span></span><br><span class="line">  newUser.<span class="property">status</span> = <span class="title class_">UserStatus</span>.<span class="property">wxUser</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> u = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">createUser</span>(newUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> timex = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>().<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">this</span>.<span class="property">jwtService</span>.<span class="title function_">generateToken</span>(u.<span class="property">id</span> + timex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">userName</span>: u.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">token</span>: token,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">generateRandomName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prefix = <span class="string">&#x27;User&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> randomSuffix = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100000</span>).<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">const</span> username = prefix + randomSuffix.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码只要有微信id来，就可以登录或者创建一个用户, 然后通过postman测试一拨，没问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;userName&quot;: &quot;User09292&quot;,</span><br><span class="line">    &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTY5MDA5Njk2OTIzMyIsImlhdCI6MTY5MDA5Njk3MSwiZXhwIjoxNjkwMTAwNTcxfQ.cm_G-jCmMdlmQqDvB0QAA5aFY6Uq8V6tLQzktv9_8lg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-通过-jwt-获取用户"><a href="#02-通过-jwt-获取用户" class="headerlink" title="02. 通过 jwt 获取用户"></a>02. 通过 jwt 获取用户</h3><p>首先这个方法我们需要验证 jwt, 验证token ok。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">CanActivate</span>, <span class="title class_">ExecutionContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JwtCommonService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../auth/jwt.common.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">JwtAuthGuard</span> <span class="keyword">implements</span> <span class="title class_">CanActivate</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> jwtCommonService: JwtCommonService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">canActivate</span>(<span class="attr">context</span>: <span class="title class_">ExecutionContext</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="title function_">switchToHttp</span>().<span class="title function_">getRequest</span>();</span><br><span class="line">    <span class="keyword">const</span> token = request.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!token || !<span class="variable language_">this</span>.<span class="property">jwtCommonService</span>.<span class="title function_">verifyToken</span>(token)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个守卫，因为 list.controller.ts 全部都需要验证，所以在 controller 中加入守卫</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;lists&#x27;</span>)</span><br><span class="line"><span class="meta">@UseGuards</span>(<span class="title class_">JwtAuthGuard</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ListController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> listService: ListService</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在加入守卫以后，我们需要获取用户 User，通过 token，使用 <code>jwtService.decode</code> 就ok了, 只是我不想每个页面都写，所以用拦截器吧。</p><p>具体文档看这里 <a href="https://docs.nestjs.cn/9/interceptors">https://docs.nestjs.cn/9/interceptors</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Injectable</span>,</span><br><span class="line">  <span class="title class_">NestInterceptor</span>,</span><br><span class="line">  <span class="title class_">ExecutionContext</span>,</span><br><span class="line">  <span class="title class_">CallHandler</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JwtService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/jwt&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title class_">NestInterceptor</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> jwtService: JwtService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">intercept</span>(<span class="attr">context</span>: <span class="title class_">ExecutionContext</span>, <span class="attr">next</span>: <span class="title class_">CallHandler</span>): <span class="title class_">Observable</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="title function_">switchToHttp</span>().<span class="title function_">getRequest</span>();</span><br><span class="line">    <span class="keyword">const</span> token = request.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">const</span> decodedToken = <span class="variable language_">this</span>.<span class="property">jwtService</span>.<span class="title function_">decode</span>(token);</span><br><span class="line">      <span class="keyword">if</span> (decodedToken) &#123;</span><br><span class="line">        request.<span class="property">user</span> = decodedToken[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.<span class="title function_">handle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于他不是全部都需要使用，所以还是每个 controller 自己选择使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="meta">@Req</span>() request): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">user</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来验证一下，启动项目，打开PostMan, 测试一下以后我修改了代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Injectable</span>,</span><br><span class="line">  <span class="title class_">NestInterceptor</span>,</span><br><span class="line">  <span class="title class_">ExecutionContext</span>,</span><br><span class="line">  <span class="title class_">CallHandler</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JwtService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/jwt&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title class_">NestInterceptor</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> jwtService: JwtService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">intercept</span>(<span class="attr">context</span>: <span class="title class_">ExecutionContext</span>, <span class="attr">next</span>: <span class="title class_">CallHandler</span>): <span class="title class_">Observable</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="title function_">switchToHttp</span>().<span class="title function_">getRequest</span>();</span><br><span class="line">    <span class="keyword">if</span> (!!request.<span class="property">userId</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> next.<span class="title function_">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> token = request.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">const</span> decodedToken = <span class="variable language_">this</span>.<span class="property">jwtService</span>.<span class="title function_">decode</span>(token);</span><br><span class="line">      <span class="keyword">if</span> (decodedToken) &#123;</span><br><span class="line">        request.<span class="property">userId</span> = decodedToken[<span class="string">&#x27;userId&#x27;</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.<span class="title function_">handle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是只能返回 userId，所以我要修改一下 token 生成的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">generateToken</span>(<span class="attr">user</span>: <span class="title class_">User</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> payload = &#123; user &#125;;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">this</span>.<span class="property">jwtService</span>.<span class="title function_">sign</span>(payload);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">logger</span>.<span class="title function_">log</span>(<span class="string">`Generated token for user <span class="subst">$&#123;user.id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把其他关联的接口修改一下, 然后靠下面的方法就能获取 user 了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Post</span>(<span class="string">&#x27;create&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="meta">@Req</span>() request): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">user</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03-添加任务"><a href="#03-添加任务" class="headerlink" title="03. 添加任务"></a>03. 添加任务</h3><p>在搞定了用户登录和获取以后，现在需要添加任务，首先我们需要验证一下参数。</p><p><a href="https://docs.nestjs.com/techniques/validation">https://docs.nestjs.com/techniques/validation</a> 文档在这里</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">useGlobalPipes</span>(<span class="keyword">new</span> <span class="title class_">ValidationPipe</span>());</span><br></pre></td></tr></table></figure><p>然后新建一个 <strong>create.task.dto.ts</strong> 因为 task，不是所有字段都要检查，和 entity 区分一下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Entity</span>, <span class="title class_">Column</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">IsNotEmpty</span>,</span><br><span class="line">  <span class="title class_">IsString</span>,</span><br><span class="line">  <span class="title class_">Length</span>,</span><br><span class="line">  <span class="title class_">IsDate</span>,</span><br><span class="line">  <span class="title class_">IsOptional</span>,</span><br><span class="line">  <span class="title class_">MinDate</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span>(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="meta">@Column</span>()</span><br><span class="line">  <span class="meta">@IsNotEmpty</span>()</span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  <span class="meta">@Length</span>(<span class="number">5</span>, <span class="number">30</span>)</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>()</span><br><span class="line">  <span class="meta">@IsNotEmpty</span>()</span><br><span class="line">  <span class="meta">@IsDate</span>()</span><br><span class="line">  <span class="attr">curDay</span>: <span class="title class_">Date</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>()</span><br><span class="line">  <span class="meta">@IsNotEmpty</span>()</span><br><span class="line">  <span class="meta">@IsDate</span>()</span><br><span class="line">  <span class="meta">@MinDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">  <span class="attr">taskTime</span>: <span class="title class_">Date</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(&#123; <span class="attr">nullable</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="meta">@IsOptional</span>()</span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  <span class="meta">@Length</span>(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后随意写一个添加task的service，引用, 名字没取好，但是懒得改了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Post</span>(<span class="string">&#x27;create&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="meta">@Body</span>() <span class="attr">task</span>: <span class="title class_">TaskDto</span>, <span class="meta">@Req</span>() request): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="keyword">new</span> <span class="title class_">List</span>();</span><br><span class="line">  list.<span class="property">title</span> = task.<span class="property">title</span>;</span><br><span class="line">  list.<span class="property">curDay</span> = task.<span class="property">curDay</span>;</span><br><span class="line">  list.<span class="property">description</span> = task.<span class="property">description</span>;</span><br><span class="line">  list.<span class="property">taskTime</span> = task.<span class="property">taskTime</span>;</span><br><span class="line">  list.<span class="property">userId</span> = request.<span class="property">user</span>.<span class="property">id</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">create</span>(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jwt 验证我写了一个守卫</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">CanActivate</span>, <span class="title class_">ExecutionContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JwtCommonService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../auth/jwt.common.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">JwtAuthGuard</span> <span class="keyword">implements</span> <span class="title class_">CanActivate</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> jwtCommonService: JwtCommonService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">canActivate</span>(<span class="attr">context</span>: <span class="title class_">ExecutionContext</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="title function_">switchToHttp</span>().<span class="title function_">getRequest</span>();</span><br><span class="line">    <span class="keyword">const</span> token = request.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!token || !<span class="variable language_">this</span>.<span class="property">jwtCommonService</span>.<span class="title function_">verifyToken</span>(token)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后postman 测试一下, 添加成功</p><h3 id="04-编辑任务"><a href="#04-编辑任务" class="headerlink" title="04. 编辑任务"></a>04. 编辑任务</h3><p>类似添加的思路</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Put</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">update</span>(</span><br><span class="line">  <span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) <span class="attr">id</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="meta">@Body</span>() <span class="attr">list</span>: <span class="title class_">TaskDto</span>,</span><br><span class="line">  <span class="meta">@Req</span>() request,</span><br><span class="line">): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> task = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">findOne</span>(id);</span><br><span class="line">  <span class="keyword">if</span> (task === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (task.<span class="property">userId</span> !== request.<span class="property">user</span>.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(<span class="string">&#x27;Forbidden&#x27;</span>, <span class="title class_">HttpStatus</span>.<span class="property">NOT_FOUND</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entity = <span class="keyword">new</span> <span class="title class_">List</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> list) &#123;</span><br><span class="line">    entity[key] = list[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">update</span>(id, entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05-获取"><a href="#05-获取" class="headerlink" title="05. 获取"></a>05. 获取</h3><p>单个获取，就直接验证 token，验证 userId，然后拿取</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findOne</span>(<span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) <span class="attr">id</span>: <span class="built_in">number</span>, <span class="meta">@Req</span>() request): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">findOne</span>(id);</span><br><span class="line">  <span class="keyword">if</span> (result === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(<span class="string">&#x27;404&#x27;</span>, <span class="title class_">HttpStatus</span>.<span class="property">NOT_FOUND</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.<span class="property">userId</span> !== request.<span class="property">user</span>.<span class="property">id</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(<span class="string">&#x27;Forbidden&#x27;</span>, <span class="title class_">HttpStatus</span>.<span class="property">NOT_FOUND</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有，这里其实有一个疑问，就是 todolist 这种类型的应用是否需要分页获取，后来想了一下，就当前端练习一下吧。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;/all/:page&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findAll</span>(<span class="meta">@Param</span>(<span class="string">&#x27;page&#x27;</span>) <span class="attr">page</span>: <span class="built_in">number</span>, <span class="meta">@Req</span>() request): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> userId = request.<span class="property">user</span>.<span class="property">id</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">findAll</span>(userId, &#123;</span><br><span class="line">    page,</span><br><span class="line">    <span class="attr">pageSize</span>: <span class="number">25</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findAll</span>(<span class="attr">userId</span>: <span class="built_in">number</span>, <span class="attr">options</span>: <span class="title class_">IPage</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">List</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listRepository</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">where</span>: &#123;</span><br><span class="line">      userId,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">skip</span>: (options.<span class="property">page</span> - <span class="number">1</span>) * options.<span class="property">pageSize</span>,</span><br><span class="line">    <span class="attr">take</span>: options.<span class="property">pageSize</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下没问题</p><h3 id="06-删除"><a href="#06-删除" class="headerlink" title="06. 删除"></a>06. 删除</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">remove</span>(<span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) <span class="attr">id</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">remove</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07-提醒和过期"><a href="#07-提醒和过期" class="headerlink" title="07. 提醒和过期"></a>07. 提醒和过期</h3><p>需要维护一个轮询，也就是说利用 linux corn 这种机制，然后定期检查是否有需要提醒的任务。</p><p>不仅仅如此，通知有多种方式，比如邮件，比如微信提醒，比如app通知，比如短信，所以需要封装一个抽象类或者接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @nestjs/schedule cron</span><br></pre></td></tr></table></figure><p>然后写一个 service</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cron</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/schedule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TaskCronService</span> &#123;</span><br><span class="line">  <span class="meta">@Cron</span>(<span class="string">&#x27;0 * * * * *&#x27;</span>)</span><br><span class="line">  <span class="title function_">handleCron</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cron Job executed!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主程序注册</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">imports</span>: [</span><br><span class="line">  <span class="title class_">ScheduleModule</span>.<span class="title function_">forRoot</span>(),</span><br><span class="line">],</span><br><span class="line"><span class="attr">providers</span>:[<span class="title class_">TaskCronService</span>],</span><br></pre></td></tr></table></figure><p>就可以开始执行了，现在需要引入其他service, 比如mailService之类的，下面就是代码的成品</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cron</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/schedule&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ListService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;src/list/list.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">UserService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;src/user/user.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MailService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;src/common/mail.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emailContent = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;任务提醒&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;尊敬的用户，您设置的任务已经到了预定的时间：&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;strong&gt;任务名称：&lt;/strong&gt; &#123;taskName&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;strong&gt;任务时间：&lt;/strong&gt; &#123;taskTime&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;strong&gt;任务描述：&lt;/strong&gt; &#123;description&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;请及时完成您的任务。&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;感谢您使用我们的服务！&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TaskCronService</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> listService: ListService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> userService: UserService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> mailService: MailService,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@Cron</span>(<span class="string">&#x27;0 * * * * *&#x27;</span>)</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">handleCron</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了任务&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">const</span> maxDiff = <span class="number">59</span>; <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">listService</span>.<span class="title function_">findAllNormalTask</span>();</span><br><span class="line">    <span class="keyword">const</span> filteredTasks = tasks.<span class="title function_">filter</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> taskTime = task.<span class="property">taskTime</span>;</span><br><span class="line">      <span class="keyword">const</span> timeDifference = <span class="title class_">Math</span>.<span class="title function_">abs</span>(taskTime.<span class="title function_">getTime</span>() - currentTime) / <span class="number">1000</span>; <span class="comment">// 转换为秒</span></span><br><span class="line">      <span class="keyword">return</span> timeDifference &lt;= maxDiff;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前需要支持四种提醒方式</span></span><br><span class="line">    <span class="comment">//1. 邮箱</span></span><br><span class="line">    <span class="comment">//2. app通知</span></span><br><span class="line">    <span class="comment">//3. 微信通知</span></span><br><span class="line">    <span class="comment">//4. 短信通知</span></span><br><span class="line">    <span class="comment">//为了性能，最好发送都是调用其他服务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; filteredTasks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = filteredTasks[i];</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">findUserById</span>(task.<span class="property">userId</span>);</span><br><span class="line">      <span class="keyword">if</span> (user !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!!user.<span class="property">email</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">mailService</span>.<span class="title function_">sendEmail</span>(</span><br><span class="line">            user.<span class="property">email</span>,</span><br><span class="line">            task.<span class="property">title</span>,</span><br><span class="line">            emailContent</span><br><span class="line">              .<span class="title function_">replace</span>(<span class="string">&#x27;&#123;taskName&#125;&#x27;</span>, task.<span class="property">title</span>)</span><br><span class="line">              .<span class="title function_">replace</span>(</span><br><span class="line">                <span class="string">&#x27;&#123;taskTime&#125;&#x27;</span>,</span><br><span class="line">                <span class="title function_">moment</span>(task.<span class="property">taskTime</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>),</span><br><span class="line">              )</span><br><span class="line">              .<span class="title function_">replace</span>(<span class="string">&#x27;description&#x27;</span>, task.<span class="property">description</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!!user.<span class="property">phone</span> &amp;&amp; !!user.<span class="property">phoneCode</span>) &#123;</span><br><span class="line">          <span class="comment">//todo..</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其他的需要做到了再写</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mailService 我使用了 nodemailer，下面是代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ConfigService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/config&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodemailer <span class="keyword">from</span> <span class="string">&#x27;nodemailer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">transporter</span>: nodemailer.<span class="property">Transporter</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> configService: ConfigService</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mailConfig = &#123;</span><br><span class="line">      <span class="attr">host</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;MAIL_HOST&#x27;</span>),</span><br><span class="line">      <span class="attr">port</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="property">get</span>&lt;<span class="built_in">number</span>&gt;(<span class="string">&#x27;MAIL_PORT&#x27;</span>),</span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">auth</span>: &#123;</span><br><span class="line">        <span class="attr">user</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;MAIL_USER&#x27;</span>),</span><br><span class="line">        <span class="attr">pass</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;MAIL_PASS&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">transporter</span> = nodemailer.<span class="title function_">createTransport</span>(mailConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">sendEmail</span>(<span class="attr">to</span>: <span class="built_in">string</span>, <span class="attr">subject</span>: <span class="built_in">string</span>, <span class="attr">content</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> mailOptions = &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="variable language_">this</span>.<span class="property">configService</span>.<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;MAIL_FROM&#x27;</span>),</span><br><span class="line">      to,</span><br><span class="line">      subject,</span><br><span class="line">      <span class="attr">text</span>: content,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">transporter</span>.<span class="title function_">sendMail</span>(mailOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08-总结"><a href="#08-总结" class="headerlink" title="08. 总结"></a>08. 总结</h3><p>这样的话，一个基本的app的api就可以有了，虽然功能很简陋，后续功能后续再补。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> nestjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 引导图和广告</title>
      <link href="/2023/07/18/uniapp_guird/"/>
      <url>/2023/07/18/uniapp_guird/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-缓存"><a href="#01-缓存" class="headerlink" title="01. 缓存"></a>01. 缓存</h3><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html#clearstorage">https://uniapp.dcloud.net.cn/api/storage/storage.html#clearstorage</a></p><blockquote><p>H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理<br>App端为原生的plus.storage，无大小限制，不是缓存，是持久化的<br>各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。<br>微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。<br>支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。<br>百度小程序策略详见、抖音小程序策略详见<br>非App平台清空Storage会导致uni.getSystemInfo获取到的deviceId改变</p></blockquote><p>在 h5 端，每个其实不一样，反正不能存大东西, 如果想要多端兼容，建议还是有服务器，别在这里存东西。</p><ul><li>uni.setStorage</li><li>uni.setStorageSync</li><li>uni.getStorage</li><li>uni.getStorageSync</li><li>uni.getStorageInfo</li><li>uni.getStorageInfoSync</li><li>uni.removeStorage</li><li>uni.removeStorageSync</li><li>uni.clearStorage</li><li>uni.clearStorageSync</li></ul><p>具体的自己看文档.</p><p>为什么要知道这个？引导页面或者开场的广告需要判断显示，是否需要每次都显示，如果不是第一次怎么显示之类的。</p><h3 id="02-有哪些设置项？"><a href="#02-有哪些设置项？" class="headerlink" title="02. 有哪些设置项？"></a>02. 有哪些设置项？</h3><p>manifest.json 中，第一个 <strong>等待首页渲染完毕后再关闭Splash图</strong></p><p><a href="https://uniapp.dcloud.net.cn/tutorial/app-splashscreen.html#">https://uniapp.dcloud.net.cn/tutorial/app-splashscreen.html#</a></p><blockquote><p>勾选“等待首页渲染完毕后再关闭Splash图”，表示需要等待首页渲染完成后再关闭启动界面<br>不勾选“等待首页渲染完毕后再关闭Splash图”，则表示首页加载完成后就会关闭启动界面，此时首页可能没有完成渲染，在部分设备可能&gt;会闪一下白屏，不推荐使用。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;splashscreen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>               <span class="comment">//可选，JSON对象，splash界面配置</span></span><br><span class="line">    <span class="attr">&quot;alwaysShowBeforeRender&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>     <span class="comment">//可选，Boolean类型，是否等待首页渲染完毕后再关闭启动界面</span></span><br><span class="line">    <span class="attr">&quot;autoclose&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  <span class="comment">//可选，Boolean类型，是否自动关闭启动界面</span></span><br><span class="line">    <span class="attr">&quot;waiting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                    <span class="comment">//可选，Boolean类型，是否在程序启动界面显示等待雪花</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;loaded&quot;</span><span class="punctuation">,</span>                  <span class="comment">//可选，字符串类型，可取值titleUpdate、rendering、loaded，uni-app项目已废弃</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;defalt&quot;</span><span class="punctuation">,</span>                 <span class="comment">//可选，字符串类型，可取值default、second，uni-app项目已废弃</span></span><br><span class="line">    <span class="attr">&quot;dealy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>                         <span class="comment">//可选，数字类型，延迟自动关闭启动时间，单位为毫秒，uni-app项目已废弃</span></span><br><span class="line">    <span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                            <span class="comment">//可选，JSON对象，开屏广告配置</span></span><br><span class="line">        <span class="attr">&quot;backaground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#RRGGBB&quot;</span><span class="punctuation">,</span>               <span class="comment">//可选，字符串类型，格式为#RRGGBB，开屏广告背景颜色</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span>                             <span class="comment">//可选，字符串类型，底部图片地址，相对应用资源目录路径</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;androidTranslucent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span>         <span class="comment">//可选，Boolean类型，使用“自定义启动图”启动界面时是否显示透明过渡界面，可解决点击桌面图标延时启动应用的效果</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;app-plus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;splashscreen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>               <span class="comment">//可选，JSON对象，splash界面配置</span></span><br><span class="line">        <span class="attr">&quot;alwaysShowBeforeRender&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>     <span class="comment">//可选，Boolean类型，是否等待首页渲染完毕后再关闭启动界面</span></span><br><span class="line">        <span class="attr">&quot;autoclose&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  <span class="comment">//可选，Boolean类型，是否自动关闭启动界面</span></span><br><span class="line">        <span class="attr">&quot;waiting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                    <span class="comment">//可选，Boolean类型，是否在程序启动界面显示等待雪花</span></span><br><span class="line">        <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;loaded&quot;</span><span class="punctuation">,</span>                  <span class="comment">//可选，字符串类型，可取值titleUpdate、rendering、loaded，uni-app项目已废弃</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;defalt&quot;</span><span class="punctuation">,</span>                 <span class="comment">//可选，字符串类型，可取值default、second，uni-app项目已废弃</span></span><br><span class="line">        <span class="attr">&quot;dealy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>                         <span class="comment">//可选，数字类型，延迟自动关闭启动时间，单位为毫秒，uni-app项目已废弃</span></span><br><span class="line">        <span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                            <span class="comment">//可选，JSON对象，开屏广告配置</span></span><br><span class="line">            <span class="attr">&quot;backaground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#RRGGBB&quot;</span><span class="punctuation">,</span>               <span class="comment">//可选，字符串类型，格式为#RRGGBB，开屏广告背景颜色</span></span><br><span class="line">            <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span>                             <span class="comment">//可选，字符串类型，底部图片地址，相对应用资源目录路径</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;androidTranslucent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span>         <span class="comment">//可选，Boolean类型，使用“自定义启动图”启动界面时是否显示透明过渡界面，可解决点击桌面图标延时启动应用的效果</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="03-swiper"><a href="#03-swiper" class="headerlink" title="03. swiper"></a>03. swiper</h3><p><a href="https://uniapp.dcloud.net.cn/component/swiper.html">https://uniapp.dcloud.net.cn/component/swiper.html</a></p><blockquote><p>一般用于左右滑动或上下滑动，比如banner轮播图。</p><p>注意滑动切换和滚动的区别，滑动切换是一屏一屏的切换。swiper下的每个swiper-item是一个滑动切换区域，不能停留在2个滑动区域之间。</p></blockquote><h3 id="04-引导图"><a href="#04-引导图" class="headerlink" title="04. 引导图"></a>04. 引导图</h3><p>首先需要明白，如果要兼容小程序，不能有超过200k的静态资源，如果需要就智能第三方或者base64显示。</p><p><a href="https://blog.csdn.net/ITold/article/details/124660256">https://blog.csdn.net/ITold/article/details/124660256</a></p><p>base64 又可能造成文件过大的问题，所以还是自己服务器或者图床最理想。</p><p>所以我使用 docker 安装了一个图床 <a href="https://hub.docker.com/r/halcyonazure/lsky-pro-docker">https://hub.docker.com/r/halcyonazure/lsky-pro-docker</a></p><p>于是有了这5张图片</p><p><a href="http://60.205.227.108:8089/i/2023/07/18/64b65e55b284e.jpg">http://60.205.227.108:8089/i/2023/07/18/64b65e55b284e.jpg</a><br><a href="http://60.205.227.108:8089/i/2023/07/18/64b65e5652a1a.jpg">http://60.205.227.108:8089/i/2023/07/18/64b65e5652a1a.jpg</a><br><a href="http://60.205.227.108:8089/i/2023/07/18/64b65e56d5b91.jpg">http://60.205.227.108:8089/i/2023/07/18/64b65e56d5b91.jpg</a><br><a href="http://60.205.227.108:8089/i/2023/07/18/64b65e576749e.jpg">http://60.205.227.108:8089/i/2023/07/18/64b65e576749e.jpg</a><br><a href="http://60.205.227.108:8089/i/2023/07/18/64b65e58a16df.jpg">http://60.205.227.108:8089/i/2023/07/18/64b65e58a16df.jpg</a></p><p>现在可以开始引导</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: 100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">&quot;swiper&quot;</span> <span class="attr">circular</span></span></span><br><span class="line"><span class="tag"><span class="attr">:duration</span>=<span class="string">&quot;duration&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;skipButton&quot;</span>&gt;</span>跳过<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要铺满，所以加入样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.swiper</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.swiper</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>button 右上角</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.skipButton</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="comment">/* 将 bottom 改为 top */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入轮播的指示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indicator-dots=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>增加点击跳过的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;skipButton&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;skip&quot;</span>&gt;</span>跳过<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> skip = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">uni.<span class="title function_">redirectTo</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">url</span>: <span class="string">&#x27;/pages/index/index&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户划过第三张图片的时候，也要跳过，所以需要绑定事件</p><p><a href="https://uniapp.dcloud.net.cn/component/swiper.html">https://uniapp.dcloud.net.cn/component/swiper.html</a></p><p>本来想实现一个右滑进入的，但是有点麻烦，虽然有思路，但是麻烦，所以划到第三张图片1秒后，自动跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@change=<span class="string">&quot;swiperChange&quot;</span></span><br><span class="line"><span class="keyword">const</span> swiperChange = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">detail</span>.<span class="property">current</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">skip</span>();</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，引导页面就ok了，回到首页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = uni.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;launchFlag&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="comment">// 如何已经有，直接去home首页</span></span><br><span class="line">    uni.<span class="title function_">switchTab</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/pages/index/index&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有值，跳到引导页，并存储，下次打开就不会进去引导页</span></span><br><span class="line">    uni.<span class="title function_">setStorage</span>(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;launchFlag&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    uni.<span class="title function_">redirectTo</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/pages/index/guide&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码放在 <code>onLoad</code> 当中，就成型了。</p><h3 id="05-广告"><a href="#05-广告" class="headerlink" title="05. 广告"></a>05. 广告</h3><p>广告就是同样的思路，只是很多广告不需要多张图，所以不需要 <code>swiper</code></p><p>所以需要的是什么？</p><p>一张图片带有连接和按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;coverAd&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;skipButton&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;skip&quot;</span>&gt;</span>跳过(&#123;&#123;timeCount&#125;&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line"><span class="language-javascript">ref</span></span><br><span class="line"><span class="language-javascript">&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> timeCount = <span class="title function_">ref</span>(<span class="number">5</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">to</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">uni.<span class="title function_">redirectTo</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">url</span>: <span class="string">&#x27;/pages/index/index&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">skip</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (!!t) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">clearInterval</span>(t);</span></span><br><span class="line"><span class="language-javascript">t = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;t:&#x27;</span>, t)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">to</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> t = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (timeCount.<span class="property">value</span> &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">timeCount.<span class="property">value</span>--;</span></span><br><span class="line"><span class="language-javascript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">skip</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (!!t) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">clearInterval</span>(t);</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">to</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">7000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.coverAd</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css"><span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">bottom</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">z-index</span>: <span class="number">10</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.coverAd</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.skipButton</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css"><span class="attribute">top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"><span class="comment">/* 将 bottom 改为 top */</span></span></span><br><span class="line"><span class="language-css"><span class="attribute">right</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="language-css"><span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css"><span class="attribute">z-index</span>: <span class="number">999</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暂时没有连接，但是我希望这张图能动一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> scaleIn &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animate-scale</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: scaleIn <span class="number">6s</span> infinite alternate;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-其他的修正"><a href="#06-其他的修正" class="headerlink" title="06. 其他的修正"></a>06. 其他的修正</h3><p>引导轮播图也需要加入倒计时，所以需要考虑代码如何复用。</p><p>新建一个组件，封装一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button class=&quot;skipButton&quot; @click=&quot;skip&quot;&gt;&#123;&#123;txtName&#125;&#125;(&#123;&#123;timeCount&#125;&#125;)&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123;</span><br><span class="line">ref,</span><br><span class="line">defineProps</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">delay: &#123;</span><br><span class="line">type: Number,</span><br><span class="line">required: false, </span><br><span class="line">default: 5, </span><br><span class="line">&#125;,</span><br><span class="line">jump: &#123;</span><br><span class="line">type: String,</span><br><span class="line">required: true, </span><br><span class="line">&#125;,</span><br><span class="line">txtName: &#123;</span><br><span class="line">type: String,</span><br><span class="line">required: false, </span><br><span class="line">default: &quot;跳过&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">delay,</span><br><span class="line">jump,</span><br><span class="line">txtName</span><br><span class="line">&#125; = props;</span><br><span class="line"></span><br><span class="line">const timeCount = ref(delay);</span><br><span class="line"></span><br><span class="line">const to = () =&gt; &#123;</span><br><span class="line">uni.redirectTo(&#123;</span><br><span class="line">url: jump</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const skip = () =&gt; &#123;</span><br><span class="line">if (!!t) &#123;</span><br><span class="line">clearInterval(t);</span><br><span class="line">t = null;</span><br><span class="line">console.log(&#x27;t:&#x27;, t)</span><br><span class="line">&#125;</span><br><span class="line">to();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let t = setInterval(() =&gt; &#123;</span><br><span class="line">if (timeCount.value &gt; 0) &#123;</span><br><span class="line">timeCount.value--;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">skip();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">if (!!t) &#123;</span><br><span class="line">clearInterval(t);</span><br><span class="line">to();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, 7000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.skipButton &#123;</span><br><span class="line">position: fixed;</span><br><span class="line">top: 20px;</span><br><span class="line">/* 将 bottom 改为 top */</span><br><span class="line">right: 20px;</span><br><span class="line">padding: 10px 20px;</span><br><span class="line">background-color: #888;</span><br><span class="line">color: #fff;</span><br><span class="line">border: none;</span><br><span class="line">border-radius: 5px;</span><br><span class="line">font-size: 16px;</span><br><span class="line">cursor: pointer;</span><br><span class="line">z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>但是这个存在一个问题，就是如果页面自行跳转，比如引导页，那么中间是没有停止参数的，那么还需要和组件进行通信。</p><p>vue 组件通信有很多方法, 反正就是通信停止或者外部不要跳转。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 多端 </tag>
            
            <tag> uniapp </tag>
            
            <tag> guid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 调试</title>
      <link href="/2023/07/18/uniapp_tiaoshi/"/>
      <url>/2023/07/18/uniapp_tiaoshi/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>你怎么知道你的代码在其他平台 ok 呢？所以需要调试</p><p>运行 &#x3D;&gt; 可以运行各种模拟调试的方式</p><h3 id="微信小程序调试"><a href="#微信小程序调试" class="headerlink" title="微信小程序调试"></a>微信小程序调试</h3><p>首先你得下载微信小程序的开发工具。</p><p>在这个基础上，调用 运行 &#x3D;&gt; 运行到小程序模拟器 &#x3D;&gt; 选择.</p><p>然后让你选择小程序路径，然后开始调试。</p><p>果然我就发现了自己的一个问题，刚才做的引导图和广告当中发现了问题，图片在小程序中没有撑满。</p><p>使用小程序的调试器调了一下, 发现小程序组件名字不一样，也就是说</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;coverAd&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;animate-scale&quot;</span> <span class="attr">src</span>=<span class="string">&quot; ...</span></span></span><br></pre></td></tr></table></figure><p>所以 css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.coverAd img &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失效了..</p><p>简单改就是增加一个样式 image 就可以了，查了文档以后发现其实还是需要使用组件，而不是直接使用 img</p><p><a href="https://zh.uniapp.dcloud.io/component/image.html">https://zh.uniapp.dcloud.io/component/image.html</a></p><p>调试，直接使用微信开发者工具就可以调试了。</p><h3 id="02-安卓调试"><a href="#02-安卓调试" class="headerlink" title="02. 安卓调试"></a>02. 安卓调试</h3><p>还是一样的操作，只是这次是连接手机，你需要把开发者模式，usb调试模式打开，每个手机方法不同，这个暂不赘述。</p><p>只是我遇到了一个问题</p><blockquote><p>同步资源失败，未得到同步资源的授权，请停止运行后重新运行，并注意手机上的授权提示</p></blockquote><p>这个问题折腾了我半天，网上有各种各样的办法，都不行，最后我发现其实我没有安装 hbuilder 这个app，所以直接找到对应版本app，然后直接拷贝到手机中安装，连接成功。</p><p>目前 console.log 日志会在控制台打出来，仅此而已。。</p><p>远程调试 <a href="https://blog.csdn.net/weixin_42089228/article/details/124362840">https://blog.csdn.net/weixin_42089228/article/details/124362840</a></p><h3 id="03-ios"><a href="#03-ios" class="headerlink" title="03 ios"></a>03 ios</h3><p>没有苹果手机，暂无。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 多端 </tag>
            
            <tag> uniapp </tag>
            
            <tag> 调试 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 简介</title>
      <link href="/2023/07/18/uniapp_base/"/>
      <url>/2023/07/18/uniapp_base/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="过文档"><a href="#过文档" class="headerlink" title="过文档"></a>过文档</h3><p><a href="https://uniapp.dcloud.net.cn/tutorial/page.html#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC">页面简介</a> 主要介绍了</p><ul><li>页面生命周期，包含 <strong>uni-app</strong> 生命周期和 <strong>Vue</strong> 生命周期</li><li>页面调用接口 主要获取页面实例</li><li>页面通讯 主要是通过事件通信</li><li>路由跳转的方法</li></ul><p>在最后说了一下 <strong>nvue 开发与 vue 开发的常见区别</strong></p><p><a href="https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html">https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html</a><br><a href="https://www.zhihu.com/question/405786306">https://www.zhihu.com/question/405786306</a></p><p><a href="https://uniapp.dcloud.net.cn/tutorial/page-component.html">引用</a></p><p>这一章节主要告诉你如何引用组件，js，css，以及插件，建议按照原生方式去写。</p><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-js.html">js 语法</a> </p><p>可以理解为支持 ES6 标准</p><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-css.html">CSS 支持</a> </p><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-uts.html">UTS介绍</a> </p><p>这个还不了解，大意是 uts 可以编译成原生的app源码，比如说安卓 Kotlin，iso swift，效率高</p><p><a href="https://uniapp.dcloud.net.cn/tutorial/compiler.html">编译器</a></p><p>编译器主要是想要讲，如果根据环境变量，以及 <strong>#ifdef</strong> 来有条件的变异，来支持某些平台的特性。</p><p><a href="https://uniapp.dcloud.net.cn/tutorial/CORS.html">跨域</a></p><p><a href="https://uniapp.dcloud.net.cn/tutorial/adapt.html">宽屏适配</a></p><blockquote><p>以目前手机屏幕为主window，在左右上，可新扩展 leftWindow、rightWindow、topWindow，这些区域可设定在一定屏幕宽度范围自动出现或消失。这些区域各自独立，切换页面支持在各自的window内刷新，而不是整屏刷新。</p></blockquote><p>这个还不是很明白</p><p><a href="https://uniapp.dcloud.net.cn/collocation/pages.html">pages.json 页面路由</a></p><blockquote><p>pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等。</p></blockquote><p><a href="https://uniapp.dcloud.net.cn/collocation/manifest.html#">manifest.json 应用配置</a></p><p>其他用到再看。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 多端 </tag>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 引用插件</title>
      <link href="/2023/07/18/uniapp_plus/"/>
      <url>/2023/07/18/uniapp_plus/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>主要是需要一个UI组件，选择使用这个 <a href="https://github.com/FirstUI/FirstUI%EF%BC%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E4%B9%9F%E5%9C%A8%E4%B8%8A%E9%9D%A2">https://github.com/FirstUI/FirstUI，插件的安装方式也在上面</a></p><p>安装以后测试一下</p><p><a href="https://uniapp.dcloud.net.cn/collocation/pages.html#style">https://uniapp.dcloud.net.cn/collocation/pages.html#style</a><br><a href="https://doc.firstui.cn/docs/started.html">https://doc.firstui.cn/docs/started.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载安装时easycom配置</span></span><br><span class="line"><span class="string">&quot;easycom&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;autoscan&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;custom&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;fui-(.*)&quot;</span>: <span class="string">&quot;@/components/firstui/fui-$1/fui-$1.vue&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用npm安装时easycom配置（配置完成后重新编译运行）</span></span><br><span class="line"><span class="string">&quot;easycom&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;autoscan&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;custom&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;fui-(.*)&quot;</span>: <span class="string">&quot;firstui-uni/firstui/fui-$1/fui-$1.vue&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后引用成功</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> vue </tag>
            
            <tag> 多端 </tag>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的todoList</title>
      <link href="/2023/07/14/ss_simple_todo/"/>
      <url>/2023/07/14/ss_simple_todo/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-简单版本"><a href="#01-简单版本" class="headerlink" title="01. 简单版本"></a>01. 简单版本</h3><p><strong>wsml</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;input-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputChange&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入任务&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;inputValue&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;add-button&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;addTask&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;task-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;taskList&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;task-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;task-item-text&quot;</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;task-item-time&quot;</span>&gt;</span>&#123;&#123;item.time&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>wxss</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.input-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.input-text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.add-button</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#007AFF</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-list</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f7f7f7</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-item-text</span> &#123;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-item-time</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wxs</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">inputValue</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">taskList</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">inputChange</span>: <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">inputValue</span>: e.<span class="property">detail</span>.<span class="property">value</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addTask</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = &#123;</span><br><span class="line">      <span class="attr">task</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">inputValue</span>,</span><br><span class="line">      <span class="attr">time</span>: <span class="variable language_">this</span>.<span class="title function_">getRemindTime</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span>.<span class="title function_">concat</span>(task);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskList</span>: newList,</span><br><span class="line">      <span class="attr">inputValue</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getRemindTime</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> remindTime = <span class="keyword">new</span> <span class="title class_">Date</span>(currentTime.<span class="title function_">getTime</span>() + <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 5分钟后提醒</span></span><br><span class="line">    <span class="keyword">return</span> remindTime.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单解释一下，现在就是一个简单的添加文字，到列表的一个过程。</p><p>现在包含了当前时间和提醒时间，以及文字两个字段。</p><p>效果大概就是下图这样</p><p><a href="/%5Cimg%5C2023-07-11-211057.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-11-211057.png" alt="alt text"></a></p><h3 id="02-本地化存储"><a href="#02-本地化存储" class="headerlink" title="02. 本地化存储"></a>02. 本地化存储</h3><p>先限制一下输入，小于3个字符，或者多余40个字符，都不允许输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">inputValue</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">if</span> (txt.<span class="property">length</span> &gt; <span class="number">40</span> || txt.<span class="property">length</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;任务长度不正确&#x27;</span>,</span><br><span class="line"><span class="attr">icon</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到生命周期的页面，发现 onload 这个生命周期最适合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 页面加载时读取本地存储的任务列表数据</span></span><br><span class="line">wx.<span class="title function_">getStorage</span>(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;taskList&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">  <span class="attr">taskList</span>: res.<span class="property">data</span></span><br><span class="line">&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在保存的地方加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存更新后的任务列表数据到本地存储</span></span><br><span class="line">wx.<span class="title function_">setStorage</span>(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;taskList&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: newList</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后把 key 定义为常亮</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;taskList&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="03-删除。"><a href="#03-删除。" class="headerlink" title="03. 删除。"></a>03. 删除。</h3><p><a href="/%5Cimg%5C2023-07-11-211057.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-11-211057.png" alt="alt text"></a></p><p>我想实现卡片式删除，也就是那种左滑删除。那么思路是什么？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-function/translateX">https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-function/translateX</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>); <span class="comment">/* 等同于 translate(10px) */</span></span><br></pre></td></tr></table></figure><p>右边看不见的地方隐藏菜单, 然后就当捕获到事件，就可以显示菜单。</p><p>在此之前，先修改一下样式，毕竟圆滚滚灰色背景不太舒服。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-item-text</span> &#123;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 隐藏溢出内容 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/* 使用省略号代表被截断的文本 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加入了一个白底灰边，然后如果超出文字省略号 **…**， 然后开始创建删除</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;task-item&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;task-item-container&quot;</span> <span class="attr">data-index</span>=<span class="string">&#x27;&#123;&#123;index&#125;&#125;&#x27;</span> <span class="attr">bindtouchstart</span>=<span class="string">&#x27;touchstart&#x27;</span> <span class="attr">bindtouchmove</span>=<span class="string">&#x27;touchmove&#x27;</span> <span class="attr">bindtouchend</span>=<span class="string">&#x27;touchend&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;transform:translateX(-&#123;&#123;item.distance&#125;&#125;px);&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;task-item-text&quot;</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;task-item-time&quot;</span>&gt;</span>&#123;&#123;item.time&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里在外面套了一层 task-item-container ，并且加入了事件和 <code>transform:translateX(-&#123;&#123;item.distance&#125;&#125;px);</code> 以及新增一个删除按钮。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.task-item-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.delete</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在事件中加入，设置的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touchstart</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">_start</span>: e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开始的时候集录起始位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touchmove</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_start</span> - e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br><span class="line">  <span class="keyword">const</span> newTaskList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span>;</span><br><span class="line">  d = d &gt; maxX ? maxX : d;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (d &gt; minDistance) &#123;</span><br><span class="line">    newTaskList[e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>].<span class="property">distance</span> = d;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskList</span>: newTaskList</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTaskList[e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>].<span class="property">distance</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskList</span>: newTaskList</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>移动的过程中，设置最新位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touchend</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`start1:<span class="subst">$&#123;<span class="variable language_">this</span>.data._start&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`pageX:<span class="subst">$&#123;e.changedTouches[<span class="number">0</span>].pageX&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> d = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_start</span> - e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newTaskList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span>;</span><br><span class="line">  d = d &gt; maxX ? maxX : d;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">  <span class="keyword">if</span> (d &gt; minDistance) &#123;</span><br><span class="line">    newTaskList[e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>].<span class="property">distance</span> = d;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">_start</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">taskList</span>: newTaskList</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTaskList[e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>].<span class="property">distance</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">_start</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">taskList</span>: newTaskList</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束代码差不多，只是重置开始位置。</p><p>基本ok以后，需要引入 iconfont. 总得加点图标才好看，我从 iconfont.com 引入，微信小程序无法共享某些css，也就是说每个 page 都是完全单独的样式，就算使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;...&#x27;</span></span><br></pre></td></tr></table></figure><p>然后加入 css</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;delete icon iconfont icon-icon-delete-fill&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看下效果</p><p><a href="/%5Cimg%5C2023-07-12-150046.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-12-150046.png" alt="alt text"></a></p><p>过程就是这样，接下来删除, 首先新增一个删除方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deleteTaskItem</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    wx.<span class="title function_">setStorage</span>(&#123;</span><br><span class="line">      <span class="attr">key</span>: key,</span><br><span class="line">      <span class="attr">data</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskList</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskList</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;删除失败&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加到事件中即可，再加一个提示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;确认删除？删除之后不可恢复&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">confirm</span>) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ok, 就这样，删除也有了。</p><h3 id="04-新增添加页面"><a href="#04-新增添加页面" class="headerlink" title="04. 新增添加页面"></a>04. 新增添加页面</h3><p>现在只输入了名字这个数据，所以要增加一些数据。</p><ul><li>标题</li><li>添加时间</li><li>提醒时间</li><li>描述</li></ul><p>简单就先用这个，我们需要一个新的页面，并且需要路由以及 <code>form</code>, 以及页面之间如何通信？</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html">页面路由</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">navigator</a></li></ul><blockquote><p>框架以栈的形式维护了当前的所有页面</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;pages/add/index&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>首先增加连接，然后根据指南当中在 index 中增加一个链接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=<span class="string">&quot;/pages/add/index&quot;</span>&gt;到添加页面去&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><p>然后 <code>form</code> ，这个时候突然想到，其实还可以使用框架，不用全部自己写…, 于是直接用官方的 <code>weui</code> 吧.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;weui-form&quot;</span> <span class="attr">bindsubmit</span>=<span class="string">&quot;formSubmit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__bd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__text-area&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cells__title&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__title&quot;</span>&gt;</span>添加任务<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__control-area&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cells__group weui-cells__group_form&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cells&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;title-input&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__hd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;weui-label&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;title-input&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;任务标题&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;title&#125;&#125;&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleInput&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;curDay&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__hd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;weui-label&quot;</span>&gt;</span>创建时间<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;curDay&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-input&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;curDay&#125;&#125;&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">picker</span> <span class="attr">mode</span>=<span class="string">&quot;date&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;taskDay&#125;&#125;&quot;</span> <span class="attr">bindchange</span>=<span class="string">&quot;bindTaskDay&quot;</span> <span class="attr">start</span>=<span class="string">&quot;&#123;&#123;curDay&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active weui-cell_select&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-select&quot;</span>&gt;</span>任务日期: &#123;&#123;taskDay&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">picker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">picker</span> <span class="attr">mode</span>=<span class="string">&quot;time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;taskTime&#125;&#125;&quot;</span> <span class="attr">bindchange</span>=<span class="string">&quot;bindTaskTime&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active weui-cell_select&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-select&quot;</span>&gt;</span>任务时间: &#123;&#123;taskTime&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">picker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;description-input&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__hd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;weui-label&quot;</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;description-input&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-input&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;description&#125;&#125;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入描述（选填）&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleDescription&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__ft weui-bottom-fixed-opr-page__tool&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-form__opr-area&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;weui-btn weui-btn_primary&quot;</span> <span class="attr">formType</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我没有加入表单验证组件，懒得去看其他组件了，生成了一些判断.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateHelper = <span class="built_in">require</span>(<span class="string">&#x27;../js/common&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;taskList&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">curDay</span>: dateHelper.<span class="title function_">formatDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()),</span><br><span class="line">    <span class="attr">taskDay</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">taskTime</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">map</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">bindTaskDay</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    detail: &#123;</span></span><br><span class="line"><span class="params">      value</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskDay</span>: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">bindTaskTime</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    detail: &#123;</span></span><br><span class="line"><span class="params">      value</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">taskTime</span>: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleInput</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    detail: &#123;</span></span><br><span class="line"><span class="params">      value</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleDescription</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    detail: &#123;</span></span><br><span class="line"><span class="params">      value</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">description</span>: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">formSubmit</span>(<span class="params">e</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">title</span>,</span><br><span class="line">      <span class="attr">curDay</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">curDay</span>,</span><br><span class="line">      <span class="attr">taskDay</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskDay</span>,</span><br><span class="line">      <span class="attr">taskTime</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">taskTime</span>,</span><br><span class="line">      <span class="attr">description</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">description</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 title</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="property">title</span> || result.<span class="property">title</span>.<span class="title function_">trim</span>().<span class="property">length</span> &lt; <span class="number">3</span> || result.<span class="property">title</span>.<span class="title function_">trim</span>().<span class="property">length</span> &gt; <span class="number">40</span>) &#123;</span><br><span class="line">      wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;标题长度应在3到40个字符之间&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验任务日期</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="property">taskDay</span>) &#123;</span><br><span class="line">      wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;请填写任务日期&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验任务时间</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="property">taskTime</span>) &#123;</span><br><span class="line">      wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;请填写任务时间&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验描述长度</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">description</span> &amp;&amp; result.<span class="property">description</span>.<span class="title function_">trim</span>().<span class="property">length</span> &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;描述长度不能超过100个字符&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> taskList = wx.<span class="title function_">getStorageSync</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!taskList) taskList = [];</span><br><span class="line">    taskList.<span class="title function_">push</span>(result);</span><br><span class="line"></span><br><span class="line">    wx.<span class="title function_">setStorage</span>(&#123;</span><br><span class="line">      <span class="attr">key</span>: key,</span><br><span class="line">      <span class="attr">data</span>: taskList</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空表单数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">curDay</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">taskDay</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">taskTime</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;提交成功&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="/%5Cimg%5C2023-07-13-112344.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-13-112344.png" alt="alt text"></a></p><p>看到这里 title 间距过高，日期选择以后时间间距也有问题，修改一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;weui-form&quot;</span> <span class="attr">bindsubmit</span>=<span class="string">&quot;formSubmit&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding-top: 0px;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">picker</span> <span class="attr">mode</span>=<span class="string">&quot;date&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;taskDay&#125;&#125;&quot;</span> <span class="attr">bindchange</span>=<span class="string">&quot;bindTaskDay&quot;</span> <span class="attr">start</span>=<span class="string">&quot;&#123;&#123;curDay&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taskDay&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_active&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__hd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;weui-label&quot;</span>&gt;</span>任务日期<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;taskDay&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picker</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，增加一个跳转在添加成功以后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateBack</span>();</span><br></pre></td></tr></table></figure><h3 id="05-更新列表页面"><a href="#05-更新列表页面" class="headerlink" title="05. 更新列表页面"></a>05. 更新列表页面</h3><p>当我准备改造的时候，发现 <a href="https://weui.io/#list">https://weui.io/#list</a> 已经实现了这个功能，我之前还自己写。。</p><p>于是我借助他的样式，改了一下。</p><p><a href="/%5Cimg%5C2023-07-13-163917.png" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-13-163917.png"></a></p><p>并且加入了导航</p><p><a href="/%5Cimg%5C2023-07-13-164021.png" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-13-164021.png"></a></p><p>为了解决来回切换，列表不刷新的问题，将原本的 <code>onload</code> 改为 <code>onshow</code>.</p><p>基本上开始有点样子了。</p><p>然后将时间，写一个方法，转换为 刚刚，小时前这种模式，不要动不动就是 <strong>2023-09-20</strong> 之类的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTimeRemaining</span>(<span class="params">endTime</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> targetTime = <span class="keyword">new</span> <span class="title class_">Date</span>(endTime);</span><br><span class="line">  <span class="keyword">const</span> timeDifference = targetTime - currentTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeDifference &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;已过期&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oneMinute = <span class="number">60</span> * <span class="number">1000</span>; <span class="comment">// 1分钟的毫秒数</span></span><br><span class="line">  <span class="keyword">const</span> oneHour = oneMinute * <span class="number">60</span>; <span class="comment">// 1小时的毫秒数</span></span><br><span class="line">  <span class="keyword">const</span> oneDay = oneHour * <span class="number">24</span>; <span class="comment">// 1天的毫秒数</span></span><br><span class="line">  <span class="keyword">const</span> oneMonth = oneDay * <span class="number">30.436875</span>; <span class="comment">// 1个月的毫秒数，按平均每月30.436875天计算</span></span><br><span class="line">  <span class="keyword">const</span> oneYear = oneMonth * <span class="number">12</span>; <span class="comment">// 1年的毫秒数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> years = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeDifference / oneYear);</span><br><span class="line">  <span class="keyword">const</span> months = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeDifference % oneYear) / oneMonth);</span><br><span class="line">  <span class="keyword">const</span> days = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeDifference % oneMonth) / oneDay);</span><br><span class="line">  <span class="keyword">const</span> hours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeDifference % oneDay) / oneHour);</span><br><span class="line">  <span class="keyword">const</span> minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeDifference % oneHour) / oneMinute);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> remainingTime = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (years &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainingTime += <span class="string">`<span class="subst">$&#123;years&#125;</span>年 `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (months &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainingTime += <span class="string">`<span class="subst">$&#123;months&#125;</span>个月 `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (days &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainingTime += <span class="string">`<span class="subst">$&#123;days&#125;</span>天 `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hours &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainingTime += <span class="string">`<span class="subst">$&#123;hours&#125;</span>小时 `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (minutes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainingTime += <span class="string">`<span class="subst">$&#123;minutes&#125;</span>分钟`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> remainingTime.<span class="title function_">trim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我想到了，既然这么像 Vue，那么是不是有可能性，他也有指令。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/query.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/query.html</a></p><p>查了一下发现，他似乎没有这样的东西，只能通过原生的指令去解决问题，或者组件使用 slot, 从而实现封装，有点恶心</p><p>然后继续测试发现不能直接在 <code>&#123;&#123;func&#125;&#125;</code> 这样直接使用方法，最后查到了</p><p><a href="https://blog.csdn.net/weixin_39015132/article/details/82767312">https://blog.csdn.net/weixin_39015132/article/details/82767312</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;filter&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./numberToFixed.wxs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个真的沉默了，太别扭了，这边产生了一个疑问，比如同样一个方法，我在 <code>&#123;&#123;&#125;&#125;</code> 和 js 中都需要使用，那是不是要区分 wxs, 果然要区分，因为。</p><blockquote><p>因为 WXS 中不能调用 javascript 中定义的函数或者变量，也不能调用小程序提供的, API，他的运行环境和 javascript 是隔离的。</p></blockquote><p><a href="https://blog.csdn.net/Umbrella_Um/article/details/107253834">https://blog.csdn.net/Umbrella_Um/article/details/107253834</a> 真的深深的嫌弃</p><p>用 getDate 解决了问题，现在是这样</p><p><a href="/%5Cimg%5C2023-07-13-233949.png" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-13-233949.png"></a></p><h3 id="06-编辑"><a href="#06-编辑" class="headerlink" title="06. 编辑"></a>06. 编辑</h3><p>增加编辑按钮，加入跳转事件</p><p>传值的方法 <a href="https://www.cnblogs.com/bushui/p/11633766.html%EF%BC%8C%E4%B8%8D%E8%BF%87%E4%BE%8B%E5%AD%90%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E3%80%82">https://www.cnblogs.com/bushui/p/11633766.html，不过例子中没有告诉你如何接收。</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__ft&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-swiped-btn weui-btn_primary&quot;</span>  <span class="attr">data-index</span>=<span class="string">&#x27;&#123;&#123;index&#125;&#125;&#x27;</span> <span class="attr">aria-role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;editTaskItem&quot;</span> <span class="attr">url</span>=<span class="string">&quot;javascript:&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-swiped-btn weui-swiped-btn_warn&quot;</span> <span class="attr">data-index</span>=<span class="string">&#x27;&#123;&#123;index&#125;&#125;&#x27;</span> <span class="attr">aria-role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;deleteTaskItem&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">editTaskItem</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">index</span>;</span><br><span class="line">  wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/pages/add/index?index=&#x27;</span> + index,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 add 增加 onLoad</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params">option</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = option.<span class="property">index</span>;</span><br><span class="line">  <span class="keyword">if</span> (!!index) &#123;</span><br><span class="line">    index = <span class="title class_">Number</span>.<span class="built_in">parseInt</span>(index);</span><br><span class="line">    wx.<span class="title function_">getStorage</span>(&#123;</span><br><span class="line">      <span class="attr">key</span>: key,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> d = res.<span class="property">data</span>[index];</span><br><span class="line">        <span class="keyword">if</span> (!!d) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: d.<span class="property">title</span>,</span><br><span class="line">            <span class="attr">curDay</span>: d.<span class="property">curDay</span>,</span><br><span class="line">            <span class="attr">taskDay</span>: d.<span class="property">taskDay</span>,</span><br><span class="line">            <span class="attr">taskTime</span>: d.<span class="property">taskTime</span>,</span><br><span class="line">            <span class="attr">description</span>: d.<span class="property">description</span>,</span><br><span class="line">            <span class="attr">map</span>: d.<span class="property">map</span>,</span><br><span class="line">            <span class="attr">index</span>: index</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//在添加的位置</span></span><br><span class="line"><span class="keyword">let</span> taskList = wx.<span class="title function_">getStorageSync</span>(key);</span><br><span class="line"><span class="keyword">if</span> (!taskList) taskList = [];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">index</span> === -<span class="number">1</span>) &#123;</span><br><span class="line">  taskList.<span class="title function_">push</span>(result);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  taskList[<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">index</span>] = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定。</p><h3 id="07-提醒"><a href="#07-提醒" class="headerlink" title="07. 提醒"></a>07. 提醒</h3><p>这里似乎就有麻烦了，因为微信切到后台以后，只驻留5分钟，如果内存紧张，5分钟都没有，所以在微信里写一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">timerTask</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>似乎是不科学的，也就是说还是需要一个服务端，数据上传，写一个定时任务，然后和微信关联通知，还需要再打开的时候一次性通知用户。</p><p><a href="https://www.zhihu.com/question/52719661">https://www.zhihu.com/question/52719661</a> 这篇文章说了一个清楚。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html</a></p><p>如果想要长期订阅 <a href="https://developers.weixin.qq.com/community/develop/doc/00008a8a7d8310b6bf4975b635a401">https://developers.weixin.qq.com/community/develop/doc/00008a8a7d8310b6bf4975b635a401</a></p><p>todolist 算是民生吗？。</p><p>另外就算需要一个有服务器以及域名，并且支持 https. 或者直接使用微信的云服务。</p><p>这个就后面来了。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> todolist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序入门</title>
      <link href="/2023/07/13/ss_baisc/"/>
      <url>/2023/07/13/ss_baisc/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>小程序入门。</p><h3 id="真入门"><a href="#真入门" class="headerlink" title="真入门"></a>真入门</h3><p>小程序 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/">开发文档</a> ，<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">工具下载地址</a></p><p>最好还是跟着他的工具来。</p><p><a href="/%5Cimg%5C2023-07-10-164309.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-10-164309.png" alt="alt text"></a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">全局配置 app.json</a>，<br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html">sitemap</a></p><p>js，wxml，wxss，json。他主要的四个文件。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/">wxs文档</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/">WXML 语法参考 </a><br>[小程序框架 &#x2F;视图层 &#x2F;WXML]<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/">https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/</a>)</p><p>很疑惑, 有点类似于 Vue 模版语法，但是介绍的又很不全。</p><p>比如我想写一个标题，h1. 试了下似乎没有效果。</p><p>在看文档的过程中 </p><blockquote><p>往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。</p></blockquote><p>不知道我是否可以理解为，他们这些都作为组件提供？后面试了一试大概是这样。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/">https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/</a></p><p>脚本介绍也不是很全，查询了一下，他其实只支持es5，能写es6，因为用 babel  转了。</p><p>最开始看的时候，我连他是否支持 settimeout 都不知道。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html">配置</a></p><ul><li>全局配置 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</li><li>页面配置 每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。</li><li>sitemap 配置</li></ul><p>sitemap 配置类似于以前网页seo用的东西</p><h3 id="02-双向绑定？"><a href="#02-双向绑定？" class="headerlink" title="02. 双向绑定？"></a>02. 双向绑定？</h3><p>在介绍里面说了一个东西, <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html">介绍</a></p><blockquote><p>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p></blockquote><p>这里我就开始好奇了，他的分层是直接从 webview &#x3D;&gt; (逻辑层，视图层)？ 还是中间还有一层？是原生就实现了？</p><p>也就是说 <strong>微信小程序是如何实现双向绑定的?</strong></p><p>我查了半天也没有查到小程序框架源码在哪里，有分析的也是逆向出来的, 这个也太麻烦了。</p><h3 id="03-场景值"><a href="#03-场景值" class="headerlink" title="03. 场景值"></a>03. 场景值</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html">https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html</a></p><p>在页面中你能拿到的东西</p><blockquote><p>场景值用来描述用户进入小程序的路径</p></blockquote><h3 id="04-逻辑层"><a href="#04-逻辑层" class="headerlink" title="04. 逻辑层"></a>04. 逻辑层</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/">https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/</a></p><p>微信代码分为视图层和逻辑层。</p><blockquote><p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。</p></blockquote><p>他这里讲了很多关于生命周期上的东西。</p><p><a href="/%5Cimg%5Cpage-lifecycle.2e646c86.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5Cpage-lifecycle.2e646c86.png" alt="alt text"></a></p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/">api</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">app 钩子</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html">page 钩子</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html">路由</a></li></ul><h3 id="05-视图层-View"><a href="#05-视图层-View" class="headerlink" title="05. 视图层 View"></a>05. 视图层 View</h3><blockquote><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。<br>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。<br>WXML(WeiXin Markup language) 用于描述页面的结构。<br>WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。<br>WXSS(WeiXin Style Sheet) 用于描述页面的样式。<br>组件(Component)是视图的基本组成单元。</p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/">WXML基本语法</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">WXSS基本语法</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/">WXS基本语法</a></p><p><strong>WXSS</strong> 中提到了一个概念，是做移动端开发必须要知道的。</p><blockquote><p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx &#x3D; 375px &#x3D; 750物理像素，1rpx &#x3D; 0.5px &#x3D; 1物理像素。</p></blockquote><p>我比较少参与移动端开发，对于这个的理解就是。</p><p>屏幕的大小以及分辨率，不同设备是完全不一样的。屏幕大像素小，屏幕小像素大，都可能造成极端情况。所以这个是需要做自适应处理的。</p><p>但是平板和手机，或者说电脑端差异过大，简单的使用百分比自适应可能不能达到理想的效果，还是需要更特殊的处理。</p><p>比如不同分辨率下的完全不同的样式，b站在平板就推出了完全不同的客户端来解决问题。</p><p>当然 微信小程序可能使用场景大都在手机端，是否要考虑折叠屏也是一个问题。</p><p>其他的和css差不多，导入，内联，class之类，只是希望他优先级还有一些其他东西差异不要太大。</p><p><strong>wxs</strong> 就是行内脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs <span class="variable language_">module</span>=<span class="string">&quot;m1&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">message</span> = msg;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123;m1.message&#125;&#125; <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">事件系统</a></p><p>说了一大堆，其实说了5件事</p><ol><li>bindtap 绑定方法</li><li>bindtap 可以动态绑定方法 </li><li>事件循环和浏览器类似，可以支持冒泡和捕获(我没有测试有没有自身那个阶段，应该有吧。。)</li><li>支持事件类型，以及事件中有哪些参数，参数具体作用。</li><li>dataset，mark(数据冒泡，这个获取父节点)</li></ol><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/">组件</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html">响应显示区域变化</a></p><p>这里提到了旋转这个概念，这个是需要考虑的，并且提供 Media Query 这个解决方案来解决自适应问题，就是css中 <code>@media</code>. 以及屏幕旋转的钩子事件。</p><p>手机中的屏幕大小问题，我想了一下存在3个方面</p><ol><li>屏幕旋转</li><li>双屏切换，比如折叠机。</li><li>小窗显示(这个要看微信是否支持)</li></ol><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/frameset.html">分栏模式</a></p><p>这里完全不懂，需要测试，当然前期可以完全不管，我大概知道他什么意思。类似于手机直的时候，一种显示，旋转以后另一种显示模式。只是这种是在代码层面，然而为什么在他的描述中似乎只要设置就可以了。</p><h3 id="06-运行时环境"><a href="#06-运行时环境" class="headerlink" title="06. 运行时环境"></a>06. 运行时环境</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html">运行时环境</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html">JavaScript 支持情况</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html">小程序运行机制</a></p><p>这里说说了几点</p><ol><li>运行时究竟在什么环境下运行代码</li><li>javascript 可能有哪些问题，比如说 promise 时序问题，以及某些可能不能使用的语法</li><li>什么是冷启动，什么是热启动，以及小程序销毁的机制</li></ol><h3 id="07-Skyline-渲染引擎"><a href="#07-Skyline-渲染引擎" class="headerlink" title="07. Skyline 渲染引擎"></a>07. Skyline 渲染引擎</h3><p><a href="https://www.zhihu.com/question/546709238">https://www.zhihu.com/question/546709238</a></p><p>这个可以后面看，主要告诉你使用这个引擎以后对于组件，wxss支持。</p><p>详情可以看一下这个知乎回答</p><p><a href="https://www.zhihu.com/question/546709238">如何评价微信小程序新渲染引擎skyline?</a></p><blockquote><p>小程序基于 Webview 的渲染架构</p><p>优点:<br>大量复用 Web 基建，包括 DOM 、CSS 等。</p><p>缺点是：<br>内存占用大：每个 Page() 实例对应一个独立的 Webview （相当于 MPA），那么用户打开的每个小程序都对应 n+1 个 Webview。<br>渲染初始化流水线长：需要加载一个 page-frame.html ，该 page-frame.html 包含所在 bundle 的所有 app + page + component 的渲染函数、样式、WXS，甚至可能会达到 MB 级别。<br>原生组件融合困难：通过所谓 “同层渲染” 的 hack 手段尝试解决原生组件的渲染融合问题，但 bug 巨多，稳定性差。<br>无法在页面之间共享元素：都是不同的渲染实例了，那当然共享元素就做不了。<br>页面跳转呆板：半屏渲染不好做，导航动画比较死板。<br>jsbridge 传递数据效率低。</p></blockquote><blockquote><p>Skyline<br>好处是：</p><p>节约内存占用。<br>flutter 渲染流水线比较精简和可控，可以很好解决局部渲染、原生组件融合等问题。<br>可以在页面间共享显示元素。<br>可以灵活控制页面导航行为和动画。<br>context 之间可以通过结构化克隆交换数据，性能比 jsbridge 高。<br>缺点是：</p><p>需要自己实现 CSS 子集，兼容性较差。<br>flutter 控件与 Webview 控件的行为差异。<br>框架失控风险：<br>微信小程序框架本来就是补丁之上打补丁，不成体系且 BUG 巨多。<br>现在又新增一个渲染上下文和渲染层，侵入业务代码和 BUG 膨胀是不可避免的。<br>微信能否保证在新旧架构下各功能的兼容性和体验？个人表示怀疑。很有可能开发者不得不同时使用 Webview &#x2F; Skyline ，并且同时应对来自两种架构的 BUG 。</p></blockquote><p>并且介绍了支持哪些组件，哪些css。</p><p>以及 Skyline 一些新特性，自定义路由，Worklet 动画，手势，共享元素动画。</p><h3 id="08-自定义组件"><a href="#08-自定义组件" class="headerlink" title="08. 自定义组件"></a>08. 自定义组件</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件基础</a></p><p>包含了怎么写组件，数据如何绑定，solt，样式隔离，如何引入外部样式，如何引入外部样式，虚化组件…</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html">组件间通信与事件</a></p><p>讲了组件如何通过事件触发和page的通信，应该也能和父组件的通信，如何获取组件实例</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html">组件生命周期</a></p><p>这里需要知道，<code>lifetimes</code> 是组件生命周期，<code>pageLifetimes</code> 是页面生命周期</p><p><strong>组件生命周期</strong></p><p><a href="/%5Cimg%5C2023-07-11-155309.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-11-155309.png" alt="alt text"></a></p><p><strong>和组件相关的 page 生命周期</strong></p><p><a href="/%5Cimg%5C2023-07-11-155339.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/%5Cimg%5C2023-07-11-155339.png" alt="alt text"></a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html">behaviors</a></p><p>其实就是 mixins, 算是一种继承的方法</p><blockquote><p>my-behavior 结构为：<br>属性：myBehaviorProperty<br>数据字段：myBehaviorData<br>方法：myBehaviorMethod<br>生命周期函数：attached、created、ready</p></blockquote><p>覆盖规则和Vue没区别，只是有 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/form.html#wx-form-field">内置behavior</a></p><p>其实他还是没给源码… </p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html">relations</a></p><blockquote><p>定义和使用组件间关系</p></blockquote><p>这个不建议使用，强关联了.. 除非真的是强关联。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html">数据监听器</a> 当 this.setData 以后触发 observers</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html">纯数据字段</a> 提供一种不能被渲染只是用于 flag 之类的数据。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/generics.html">抽象组件</a> 看得我头疼。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文档我没有完全看完，后续还有插件，域名管理(只能向审核过的域名发起请求)，worker，存储，文件系统，消息推送等等，不过先了解这些暂时不影响我进行我的第一次开发了。</p><p>扫完整个文档，给我一种感觉，不舒服。</p><p>整个文档没有建议的开发方式，这个ok，但是要给源码啊。。。</p><p>不知道你大概实现，你怎么玩的，怎么去好好开发呢？</p><p>而且文档例子不够多，只能自己查资料，自己试，完全是体力活。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript Array</title>
      <link href="/2023/07/12/es6_array/"/>
      <url>/2023/07/12/es6_array/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>重新复习一下</p><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h3><blockquote><p>Array() 构造函数用于创建 Array 对象。</p><p>调用 Array() 时可以使用或不使用 new。两者都会创建一个新的 Array 实例。</p></blockquote><p><strong>elementN</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure><p><strong>arrayLength</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Array(5) //[undefined,undefined,undefined]undefined,undefined</span><br></pre></td></tr></table></figure><h3 id="2-Array-species"><a href="#2-Array-species" class="headerlink" title="2. Array[@@species]"></a>2. Array[@@species]</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>[<span class="title class_">Symbol</span>.<span class="property">species</span>]</span><br></pre></td></tr></table></figure><p><code>Symbol.specie</code> </p><blockquote><p>species 访问器属性允许子类覆盖对象的默认构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Array1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mapped = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">Array1</span>);</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">Array</span>);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br></pre></td></tr></table></figure><h3 id="3-Array-prototype-unscopables"><a href="#3-Array-prototype-unscopables" class="headerlink" title="3. Array.prototype[@@unscopables]"></a>3. Array.prototype[@@unscopables]</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[@@unscopables]</span><br></pre></td></tr></table></figure><p>其实也就是 <code>Symbol.unscopables</code>, </p><blockquote><p>Symbol.unscopables 属性通常在对象的原型链上定义，用于控制在作用域绑定中应该被忽略的属性。如果一个对象的属性名存在于 Symbol.unscopables 属性中，那么在使用 with 语句时，该属性将被忽略，不会被当作局部变量引入。</p></blockquote><p>也就是定义哪些 with 中无法使用，这个可以忽略，因为 with 是一种问题很大的写法。</p><blockquote><p>可读性和维护性差：with 语句可以引入额外的作用域绑定，从而导致代码的可读性下降。在一个较大的代码块中，难以准确判断变量的来源，增加了代码的维护难度。</p><p>作用域泄漏：with 语句会将对象添加到作用域链的前端，这可能导致意外的变量声明。如果在 with 语句内部使用了未声明的变量，该变量会被添加到全局作用域中，可能引发命名冲突或意外的行为。</p><p>性能问题：with 语句会影响代码的性能。由于引入额外的作用域绑定，JavaScript 引擎在查找变量时需要遍历更长的作用域链，导致代码执行速度变慢。</p><p>不安全的属性访问：使用 with 语句可以直接访问对象的属性，但如果属性不存在，会自动将其认为是全局变量。这种隐式的属性访问会使代码更加脆弱，容易出现错误。</p><p>严格模式不支持：with 语句在严格模式下是被禁止的，如果你的代码要求使用严格模式，就不能使用 with 语句。</p></blockquote><p>所以都别用。</p><h3 id="4-length"><a href="#4-length" class="headerlink" title="4. length"></a>4. length</h3><blockquote><p>length 是 Array 的实例属性，表示该数组中元素的个数。该值是一个无符号 32 位整数，并且其数值总是大于数组最大索引。</p></blockquote><p>一般使用的话，会直接返回数组的长度, 可以判断长度，遍历等操作。</p><p>值得注意的是 length 是可写的，它可以做几件事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">200</span>; <span class="comment">//[undefined * 200]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr1.<span class="property">length</span> = <span class="number">3</span>; <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>写 length 可以做到，裁减 arr，可以创建数组。</p><h3 id="5-Array-prototype-iterator"><a href="#5-Array-prototype-iterator" class="headerlink" title="5. Array.prototype@@iterator"></a>5. Array.prototype<a href="">@@iterator</a></h3><p><code>Symbol.iterator</code> </p><blockquote><p>Symbol.iterator 是 JavaScript 中的一个内置符号（Symbol），它用于定义一个对象的默认迭代器方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; data.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: data[index++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就可以支持 <code>for of</code> 循环。</p><h3 id="6-at"><a href="#6-at" class="headerlink" title="6. at"></a>6. at</h3><blockquote><p>at() 方法接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。</p></blockquote><p>正常情况下，正整数去使用的话和直接 <code>array[index]</code> 是没有区别的.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">o[<span class="number">0</span>] <span class="comment">//1;</span></span><br><span class="line">o.<span class="title function_">at</span>(<span class="number">0</span>) <span class="comment">//1;</span></span><br></pre></td></tr></table></figure><p>但是有些不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">o[o.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">//5;</span></span><br><span class="line">o.<span class="title function_">at</span>(-<span class="number">1</span>) <span class="comment">//5;</span></span><br></pre></td></tr></table></figure><p>他会简化操作。</p><h3 id="7-concat"><a href="#7-concat" class="headerlink" title="7. concat"></a>7. concat</h3><blockquote><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">concat</span>(...item);</span><br></pre></td></tr></table></figure><p>就是合并，不会去重，并且是浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = [[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">const</span> num2 = [<span class="number">2</span>, [<span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = num1.<span class="title function_">concat</span>(num2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers);</span><br><span class="line"><span class="comment">// [[1], 2, [3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 num1 的第一个元素</span></span><br><span class="line">num1[<span class="number">0</span>].<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers);</span><br><span class="line"><span class="comment">// [[1, 4], 2, [3]]</span></span><br></pre></td></tr></table></figure><p>还有就是 <strong>Symbol.isConcatSpreadable</strong></p><blockquote><p>内置的<strong>Symbol.isConcatSpreadable</strong>符号用于配置某对象作为Array.prototype.concat()方法的参数时是否展开其数组元素。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">arr[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line">arr.<span class="title function_">concat</span>(arr1); <span class="comment">//[[1, 2, 3, 4, 5], 6,7,8]</span></span><br></pre></td></tr></table></figure><p>会改变默认行为.</p><p>如果是 Array-like, 就会直接支持 <code>concat</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">3</span>, [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">arr.<span class="title function_">concat</span>(obj2) <span class="comment">//[1,2,3,5,6,7,8]</span></span><br></pre></td></tr></table></figure><h3 id="8-copyWithin"><a href="#8-copyWithin" class="headerlink" title="8. copyWithin"></a>8. copyWithin</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">copyWithin</span>(target)</span><br><span class="line"><span class="title function_">copyWithin</span>(target, start)</span><br><span class="line"><span class="title function_">copyWithin</span>(target, start, end)</span><br></pre></td></tr></table></figure><blockquote><p>copyWithin 是数组的一个方法，用于将数组中的一部分元素复制到数组的指定位置。它修改原始数组，不会创建新的数组副本。</p></blockquote><p>简单的方法却有很多东西.</p><ul><li>所有参数都支持负数， 如果 param &lt; 0，则实际是 param + array.length。</li><li>所有参数都会转为整数, 如果不是整数，比如是 <code>abcd</code> 之类的，会被转为 0</li><li>如果 param &lt; -arr.length, 使用 0</li><li>如果 (target or start) &gt;&#x3D; arr.length, 不会拷贝 </li><li>如果 省略end 或者 end &gt;&#x3D; arr.length, 末尾所有元素都被复制。</li><li>如果 如果 end 位于 start 之前，则不会拷贝任何内容。</li><li>end 如果 end 位于 start 之前，则不会拷贝任何内容。</li></ul><p>对于参数来说他实在是太能兼容了，真的不太想用这个方法。</p><h3 id="9-Array-prototype-entries"><a href="#9-Array-prototype-entries" class="headerlink" title="9. Array.prototype.entries()"></a>9. Array.prototype.entries()</h3><blockquote><p>entries() 方法返回一个新的数组迭代器 (en-US)对象，该对象包含数组中每个索引的键&#x2F;值对。</p></blockquote><p>首先需要知道什么是迭代器, 是实现了一个迭代器协议</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE</a></p><p>协议是上面那个链接</p><p>需要实现 next 方法，并且返回 IteratorResult接口对象。</p><p>接口包含 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">done: boolean,</span><br><span class="line">value: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于返回一个这样的接口对象。</p><h3 id="10-Array-prototype-every"><a href="#10-Array-prototype-every" class="headerlink" title="10. Array.prototype.every()"></a>10. Array.prototype.every()</h3><blockquote><p>every() 方法测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">every</span>(callbackFn, arg);</span><br></pre></td></tr></table></figure><p>callbackFn 表示回调， arg表示 this 指向，可选。</p><p>every 会遍历所有的数组元素，如果 callbackFn 中返回假值，会立刻停止遍历，并且返回 false.</p><p>唯一需要注意的是，every 不会遍历稀疏数组中的空, 这里是我之前不知道的一个概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, undefined, 1].every(v =&gt; v === 1) //false</span><br><span class="line">[1, , 1].every(v =&gt; v === 1) //true</span><br></pre></td></tr></table></figure><p>[1,,1]是稀疏数组，但是[1, undefined, 1]不是。</p><h3 id="11-Array-prototype-fill"><a href="#11-Array-prototype-fill" class="headerlink" title="11. Array.prototype.fill()"></a>11. Array.prototype.fill()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fill</span>(value)</span><br><span class="line"><span class="title function_">fill</span>(value, start)</span><br><span class="line"><span class="title function_">fill</span>(value, start, end)</span><br></pre></td></tr></table></figure><p>功能很简单，就是填充数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// [0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><p>主要再 start 和 end, 和 copyWithin 一样。</p><ul><li>所有参数，基于零的索引，从此开始填充，转换为整数。</li><li>如果 start 为空，就全部填充， 如果 start 不为空， end为空，那么从start开始填充，直到末尾。</li><li>如果 参数 &lt; -array.length 或 参数 被省略，则使用 0。</li><li>如果 start &gt;&#x3D; array.length</li></ul><p>需要注意的是，不管是 every 还是 fill， end值都不是通过 start 计算，而是独立计算。</p><h3 id="12-Array-prototype-filter"><a href="#12-Array-prototype-filter" class="headerlink" title="12. Array.prototype.filter()"></a>12. Array.prototype.filter()</h3><p>很常用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">filter</span>(callbackFn)</span><br><span class="line"><span class="title function_">filter</span>(callbackFn, thisArg)</span><br><span class="line"><span class="title function_">callbackFn</span>(element, index, array)</span><br></pre></td></tr></table></figure><p>thisArg 是替换 callbackFn 中 this 指向。</p><p>返回数组，不过是浅拷贝,同样会出现稀疏数组的问题，会跳过。</p><h3 id="13-Array-prototype-find-Array-prototype-findIndex-Array-prototype-findLast-Array-prototype-findLastIndex"><a href="#13-Array-prototype-find-Array-prototype-findIndex-Array-prototype-findLast-Array-prototype-findLastIndex" class="headerlink" title="13. Array.prototype.find, Array.prototype.findIndex, Array.prototype.findLast, Array.prototype.findLastIndex"></a>13. Array.prototype.find, Array.prototype.findIndex, Array.prototype.findLast, Array.prototype.findLastIndex</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">find</span>(callbackFn);</span><br><span class="line"><span class="title function_">find</span>(callbackFn, thisArg);</span><br><span class="line"><span class="title function_">callbackFn</span>(element, index. arr);</span><br></pre></td></tr></table></figure><p>find 和之前看过的 every, filter 不一样，是能够访问稀疏数组的，也就是为 undefined.</p><p>find 升序迭代数组。返回true, 返回当前 index 的 item.<br>其他总体类似，只是顺序和返回值差别。</p><h3 id="14-Array-prototype-flat"><a href="#14-Array-prototype-flat" class="headerlink" title="14. Array.prototype.flat"></a>14. Array.prototype.flat</h3><blockquote><p>flat() 方法创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。</p></blockquote><p>简单说就是，将多维数组简化成更低维度的数组，不一定是一维数组，需要注意的是返回的是浅拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">flat</span>()</span><br><span class="line"><span class="title function_">flat</span>(depth)</span><br></pre></td></tr></table></figure><blockquote><p>指定要提取嵌套数组的结构深度，默认值为 1。</p></blockquote><p>东西比较简单，一个简单例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//flat</span><br><span class="line">console.log(`---------------flat start---------------`);</span><br><span class="line">const flatTest1 = [1, 2, 3, 4, [5, 6, [7, 8, [9, 10, [11, 12]]]]];</span><br><span class="line">console.log(&quot;empty flatTest1:&quot;, flatTest1.flat());</span><br><span class="line">console.log(`1 flatTest1:`, flatTest1.flat(1));</span><br><span class="line">console.log(`2 flatTest1:`, flatTest1.flat(2));</span><br><span class="line">console.log(`3 flatTest1`, flatTest1.flat(3));</span><br><span class="line">console.log(`4 flatTest1`, flatTest1.flat(4));</span><br><span class="line">console.log(&quot;Infinity flatTest1&quot;, flatTest1.flat(Infinity));</span><br><span class="line"></span><br><span class="line">const flatTest2 = [</span><br><span class="line">1,</span><br><span class="line">2,</span><br><span class="line">,</span><br><span class="line">3,</span><br><span class="line">4,</span><br><span class="line">[5, , 6, [7, , 8, [9, , 10, [11, , 12]]]],</span><br><span class="line">];</span><br><span class="line">console.log(&quot;empty flatTest2:&quot;, flatTest2.flat());</span><br><span class="line">console.log(`1 flatTest2:`, flatTest2.flat(1));</span><br><span class="line">console.log(`2 flatTest2:`, flatTest2.flat(2));</span><br><span class="line">console.log(`3 flatTest2`, flatTest2.flat(3));</span><br><span class="line">console.log(`4 flatTest2`, flatTest2.flat(4));</span><br><span class="line">console.log(&quot;Infinity flatTest2&quot;, flatTest2.flat(Infinity));</span><br><span class="line">console.log(`---------------flat end---------------`);</span><br><span class="line"></span><br><span class="line">index.html:13 ---------------flat start---------------</span><br><span class="line">index.html:15 empty flatTest1: (7) [1, 2, 3, 4, 5, 6, Array(3)]</span><br><span class="line">index.html:16 1 flatTest1: (7) [1, 2, 3, 4, 5, 6, Array(3)]</span><br><span class="line">index.html:17 2 flatTest1: (9) [1, 2, 3, 4, 5, 6, 7, 8, Array(3)]</span><br><span class="line">index.html:18 3 flatTest1 (11) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, Array(2)]</span><br><span class="line">index.html:19 4 flatTest1 (12) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line">index.html:20 Infinity flatTest1 (12) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line">index.html:30 empty flatTest2: (7) [1, 2, 3, 4, 5, 6, Array(4)]</span><br><span class="line">index.html:31 1 flatTest2: (7) [1, 2, 3, 4, 5, 6, Array(4)]</span><br><span class="line">index.html:32 2 flatTest2: (9) [1, 2, 3, 4, 5, 6, 7, 8, Array(4)]</span><br><span class="line">index.html:33 3 flatTest2 (11) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, Array(3)]0: 11: 22: 33: 44: 55: 66: 77: 88: 99: 1010: (3) [11, 空, 12]length: 11[[Prototype]]: Array(0)</span><br><span class="line">index.html:34 4 flatTest2 (12) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line">index.html:35 Infinity flatTest2 (12) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line">index.html:36 ---------------flat end---------------</span><br></pre></td></tr></table></figure><p>我这里测试了多维数组和稀疏数组的情况，基本可以说清楚了。</p><h3 id="15-Array-prototype-flatMap"><a href="#15-Array-prototype-flatMap" class="headerlink" title="15. Array.prototype.flatMap"></a>15. Array.prototype.flatMap</h3><blockquote><p>flatMap() 方法对数组中的每个元素应用给定的回调函数，然后将结果展开一级，返回一个新数组。它等价于在调用 map() 方法后再调用深度为 1 的 flat() 方法（arr.map(…args).flat()），但比分别调用这两个方法稍微更高效一些。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">flatMap</span>(callbackFn)</span><br><span class="line"><span class="title function_">flatMap</span>(callbackFn, thisArg)</span><br></pre></td></tr></table></figure><p>简单说就是调用 Array.prototype.map 之后再调用 flat(1);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//flatMap</span><br><span class="line">console.log(`---------------flatMap start---------------`);</span><br><span class="line">const flatMapest1 = [1, 2, 3, 4, [5, 6, [7, 8, [9, 10, [11, 12]]]]];</span><br><span class="line">console.log(`flatMapest1:`, flatMapest1.flatMap((n) =&gt; &#123;</span><br><span class="line">console.log(n);</span><br><span class="line">return n;</span><br><span class="line">&#125;));</span><br><span class="line">console.log(`---------------flatMap end---------------`);</span><br></pre></td></tr></table></figure><p>一个很简单的例子，就说明情况了。</p><h3 id="16-Array-prototype-forEach"><a href="#16-Array-prototype-forEach" class="headerlink" title="16. Array.prototype.forEach"></a>16. Array.prototype.forEach</h3><p>常用的一种遍历方式，他有几个细节</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">forEach</span>(callbackFn)</span><br><span class="line"><span class="title function_">forEach</span>(callbackFn, thisArg)</span><br></pre></td></tr></table></figure><ol><li>它按索引升序地为数组中的每个元素调用一次提供的 callbackFn 函数</li><li>总是返回 undefined</li><li>当调用 forEach() 时，callbackFn 不会访问超出数组初始长度的任何元素。</li><li>已经访问过的索引的更改不会导致 callbackFn 再次调用它们。</li><li>如果 callbackFn 更改了数组中已经存在但尚未访问的元素，则传递给 callbackFn 的值将是在访问该元素时的值。已经被删除的元素不会被访问。</li><li>除了 throw error 不能中断 forEach</li><li>不会访问稀疏数组</li></ol><h3 id="17-Array-from"><a href="#17-Array-from" class="headerlink" title="17. Array.from()"></a>17. Array.from()</h3><blockquote><p>想要转换成数组的类数组或可迭代对象。</p></blockquote><p>这个就是一个数组的静态方法，会返回一个新的数组实例。</p><p>这里需要知道什么是类数组，</p><ul><li>索引：类数组对象使用数字索引来访问元素，就像数组一样。</li><li>长度：类数组对象具有 length 属性，表示它包含的元素数量。</li><li>迭代：类数组对象可以通过 for 循环或其他迭代方法进行遍历，就像遍历数组一样。</li><li>下标访问：类数组对象可以通过索引直接访问元素，例如 obj[0]。</li></ul><p>还有就是可迭代对象，Symbol.iterator。</p><h3 id="18-Array-fromAsync-实验性质"><a href="#18-Array-fromAsync-实验性质" class="headerlink" title="18. Array.fromAsync() 实验性质"></a>18. Array.fromAsync() 实验性质</h3><p>我测试了一下，最新版本的 edge 是不支持的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fromAsync">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fromAsync</a></p><p>详情看这个吧，不使用也是可以的，你先拿到在 Array.from.</p><h3 id="19-Array-prototype-group-实验性质"><a href="#19-Array-prototype-group-实验性质" class="headerlink" title="19. Array.prototype.group() 实验性质"></a>19. Array.prototype.group() 实验性质</h3><p>看名字就知道是一种数组的分组方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">group</span>(callbackFn)</span><br><span class="line"><span class="title function_">group</span>(callbackFn, thisArg)</span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCallback</span>(<span class="params">&#123; quantity &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> quantity &gt; <span class="number">5</span> ? <span class="string">&quot;ok&quot;</span> : <span class="string">&quot;restock&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result2 = inventory.<span class="title function_">group</span>(myCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果是：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  restock: [</span></span><br><span class="line"><span class="comment">    &#123; name: &quot;asparagus&quot;, type: &quot;vegetables&quot;, quantity: 5 &#125;,</span></span><br><span class="line"><span class="comment">    &#123; name: &quot;bananas&quot;, type: &quot;fruit&quot;, quantity: 0 &#125;,</span></span><br><span class="line"><span class="comment">    &#123; name: &quot;cherries&quot;, type: &quot;fruit&quot;, quantity: 5 &#125;</span></span><br><span class="line"><span class="comment">  ],</span></span><br><span class="line"><span class="comment">  ok: [</span></span><br><span class="line"><span class="comment">    &#123; name: &quot;goat&quot;, type: &quot;meat&quot;, quantity: 23 &#125;,</span></span><br><span class="line"><span class="comment">    &#123; name: &quot;fish&quot;, type: &quot;meat&quot;, quantity: 22 &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以随意命名分组，在 callbackFn 中进行判断，根据返回值来命名组的名字。</p><p>需要值以的是，命名必须是 String or Symbol, 如果不是会被转为 String</p><h3 id="20-Array-prototype-groupToMap-实验性质"><a href="#20-Array-prototype-groupToMap-实验性质" class="headerlink" title="20. Array.prototype.groupToMap() 实验性质"></a>20. Array.prototype.groupToMap() 实验性质</h3><p>和 19 中， group 一样，只是返回值是一个 Map，那么 key 就灵活了。</p><h3 id="21-Array-prototype-includes"><a href="#21-Array-prototype-includes" class="headerlink" title="21. Array.prototype.includes()"></a>21. Array.prototype.includes()</h3><blockquote><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">includes</span>(searchElement)</span><br><span class="line"><span class="title function_">includes</span>(searchElement, fromIndex)</span><br></pre></td></tr></table></figure><ul><li>fromIndex 可以支持负数，fromIndex + array.length， </li><li>如果 fromIndex &gt; array.length return false.</li><li>如果 fromIndex &lt; -array.length fromIndex &#x3D; 0</li></ul><h3 id="22-Array-prototype-indexOf-，Array-prototype-lastIndexOf"><a href="#22-Array-prototype-indexOf-，Array-prototype-lastIndexOf" class="headerlink" title="22. Array.prototype.indexOf()，Array.prototype.lastIndexOf()"></a>22. Array.prototype.indexOf()，Array.prototype.lastIndexOf()</h3><p>其实 includes，find， indexOf 类似，只是 indexOf 是返回索引，也就是Index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">indexOf</span>(searchElement)</span><br><span class="line"><span class="title function_">indexOf</span>(searchElement, fromIndex)</span><br></pre></td></tr></table></figure><ul><li>fromIndex 可以支持负数，fromIndex + array.length， </li><li>如果 fromIndex &gt; array.length return -1.</li><li>如果 fromIndex &lt; -array.length fromIndex &#x3D; 0</li></ul><p>那么lastIndexOf 差别就在于顺序，都知道 indexOf 是第一个出现就返回，那么 indexOf 是升序，lastIndexOf 是降序。</p><h3 id="23-Array-isArray"><a href="#23-Array-isArray" class="headerlink" title="23. Array.isArray()"></a>23. Array.isArray()</h3><h3 id="24-Array-prototype-join"><a href="#24-Array-prototype-join" class="headerlink" title="24. Array.prototype.join()"></a>24. Array.prototype.join()</h3><p>最常用的方法，没什么好讲的。</p><h3 id="25-Array-prototype-keys"><a href="#25-Array-prototype-keys" class="headerlink" title="25. Array.prototype.keys()"></a>25. Array.prototype.keys()</h3><blockquote><p>keys() 方法返回一个新的数组迭代器 (en-US)对象，其中包含数组中每个索引的键。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, , <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> sparseKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(arr);</span><br><span class="line"><span class="keyword">const</span> denseKeys = [...arr.<span class="title function_">keys</span>()];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sparseKeys); <span class="comment">// [&#x27;0&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(denseKeys); <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure><p>差别就在稀疏数组。</p><h3 id="26-Array-prototype-map"><a href="#26-Array-prototype-map" class="headerlink" title="26. Array.prototype.map()"></a>26. Array.prototype.map()</h3><blockquote><p>map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">map</span>(callbackFn)</span><br><span class="line"><span class="title function_">map</span>(callbackFn, thisArg)</span><br><span class="line"><span class="title function_">callbackFn</span>(element, index, arr)</span><br></pre></td></tr></table></figure><p>其实就是根据现有数组，每次遍历调用 callbackFn 返回一个新数组。</p><p>好玩的是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="string">&quot;1&quot;</span>) <span class="comment">//[&#x27;11&#x27;, undefined, &#x27;31&#x27;];</span></span><br></pre></td></tr></table></figure><p>然而加上输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="keyword">return</span> x + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>也就是不会遍历到，但是会输出..</p><h3 id="27-Array-of"><a href="#27-Array-of" class="headerlink" title="27. Array.of"></a>27. Array.of</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>()</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(element0)</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(element0, element1)</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(element0, element1, <span class="comment">/* … ,*/</span> elementN)</span><br></pre></td></tr></table></figure><p>唯一的差别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">7</span>); <span class="comment">// [7]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">7</span>); <span class="comment">// 由 7 个空槽组成的数组</span></span><br></pre></td></tr></table></figure><h3 id="28-Array-prototype-pop-Array-prototype-shift-Array-prototype-unshift-，Array-prototype-push"><a href="#28-Array-prototype-pop-Array-prototype-shift-Array-prototype-unshift-，Array-prototype-push" class="headerlink" title="28. Array.prototype.pop(), Array.prototype.shift(), Array.prototype.unshift()，Array.prototype.push()"></a>28. Array.prototype.pop(), Array.prototype.shift(), Array.prototype.unshift()，Array.prototype.push()</h3><p>pop 删除最后一个值，并且返回值。</p><p>push 方法将指定的元素添加到数组的末尾，并返回新的数组长度。</p><p>shift 删除最新的值，并且返回值</p><p>unshift 方法将指定元素添加到数组的开头，并返回数组的新长度。</p><h3 id="29-Array-prototype-reduce-，Array-prototype-reduceRight"><a href="#29-Array-prototype-reduce-，Array-prototype-reduceRight" class="headerlink" title="29. Array.prototype.reduce()，Array.prototype.reduceRight()"></a>29. Array.prototype.reduce()，Array.prototype.reduceRight()</h3><blockquote><p>reduce() 方法对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p></blockquote><p>看了这个描述就应该知道这个方法的主要目的，球和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">reduce</span>(callbackFn)</span><br><span class="line"><span class="title function_">reduce</span>(callbackFn, initialValue)</span><br><span class="line"><span class="title function_">callbackFn</span>(accumulator,currentValue,currentIndex)</span><br></pre></td></tr></table></figure><p>这里有个概念</p><blockquote><p>每一次运行 reducer 会将先前元素的计算结果作为参数传入</p></blockquote><p>那么第一次运行明显没有初始值，所以如果没有传入 initialValue ，索引0,就是初始值。</p><p>如果传入，那么 initalValue 就是初始值。</p><p>还有一个很重要的东西，就是 reduce 如果数组长度是1, 那么不会调用 callbackFn，如果有 initalValue, 数组没有长度，同上。</p><p>reduce 是一个递归函数，因为他会算出上一次的结果，求和对他来说是最简单的工作，他可以做很多事情，因为他会传入上一次的结果，所以你可以不用在外部新建一个参数，就可以直接做很多事情，而不用自己去写一个必包或者方法。</p><p>比如，我要把一个数组里面的奇数和偶数分开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123; v % <span class="number">2</span> === <span class="number">0</span> ? arr.<span class="title function_">push</span>(): <span class="attr">arr1</span>:<span class="title function_">push</span>() &#125;);</span><br></pre></td></tr></table></figure><p>如果用 reduce</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b,i</span>) =&gt;</span> &#123;</span><br><span class="line">    b % <span class="number">2</span> === <span class="number">0</span> ? a[<span class="number">0</span>].<span class="title function_">push</span>(b) : a[<span class="number">1</span>].<span class="title function_">push</span>(b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;, [[],[]])</span><br></pre></td></tr></table></figure><p>大概是这个意思。</p><p>reduceRight 就是从右到左。</p><h3 id="30-Array-prototype-reverse-，Array-prototype-toReversed"><a href="#30-Array-prototype-reverse-，Array-prototype-toReversed" class="headerlink" title="30. Array.prototype.reverse()，Array.prototype.toReversed()"></a>30. Array.prototype.reverse()，Array.prototype.toReversed()</h3><p>反转数组，没有其他参数。</p><blockquote><p>reverse() 方法就地反转数组中的元素，并返回同一数组的引用。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。换句话说，数组中的元素顺序将被翻转，变为与之前相反的方向。</p></blockquote><p>toReversed 产生新数组，浅拷贝。</p><h3 id="31-Array-prototype-slice"><a href="#31-Array-prototype-slice" class="headerlink" title="31. Array.prototype.slice()"></a>31. Array.prototype.slice()</h3><blockquote><p>slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。</p></blockquote><p>类似于 <code>String.prototype.sub</code>. 截取一段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">slice</span>()</span><br><span class="line"><span class="title function_">slice</span>(start)</span><br><span class="line"><span class="title function_">slice</span>(start, end)</span><br></pre></td></tr></table></figure><p>start &amp; end, 就是开始和结束，结束并不是长度。</p><p>然后 start 和 end 需要跟其他的数组内容一样，</p><ul><li>允许负数，param + array.length</li><li>param &lt; -array.length &#x3D; 0</li><li>start &gt;&#x3D; array.length， 不截取</li><li>end &gt;&#x3D; array.length, 提取到末尾的所有</li><li>end &lt; start, 不提取</li></ul><h3 id="32-Array-prototype-some"><a href="#32-Array-prototype-some" class="headerlink" title="32. Array.prototype.some()"></a>32. Array.prototype.some()</h3><blockquote><p>some() 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。如果在数组中找到一个元素使得提供的函数返回 true，则返回 true；否则返回 false。它不会修改数组。</p></blockquote><p>some 只要一个符合条件，就返回 true, 全部 false，才返回 false.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">some</span>(callbackFn)</span><br><span class="line"><span class="title function_">some</span>(callbackFn, thisArg)</span><br></pre></td></tr></table></figure><p>some() 不会在空槽上运行它的断言函数, 反正不管空槽，也就是不管稀疏数组。</p><h3 id="33-Array-prototype-sort"><a href="#33-Array-prototype-sort" class="headerlink" title="33. Array.prototype.sort()"></a>33. Array.prototype.sort()</h3><blockquote><p>sort() 方法就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sort</span>()</span><br><span class="line"><span class="title function_">sort</span>(compareFn)</span><br></pre></td></tr></table></figure><p>这里有2种情况</p><blockquote><p>如果没有提供 compareFn，所有非 undefined 的数组元素都会被转换为字符串，并按照 UTF-16 码元顺序比较字符串进行排序</p></blockquote><p>具体码可以参考这个链接 <a href="https://www.toolhelper.cn/Encoding/UTF16">https://www.toolhelper.cn/Encoding/UTF16</a></p><p>所有的 undefined 元素都会被排序到数组的末尾，sort() 方法保留空槽。如果源数组是稀疏的，则空槽会被移动到数组的末尾，并始终排在所有 undefined 元素的后面。</p><p>这就是 sort 的逻辑。</p><p>第二种情况，通过 callbackFn 来进行对比</p><blockquote><p>如果提供了 compareFn，所有非 undefined 的数组元素都会按照比较函数的返回值进行排序（所有的 undefined 元素都会被排序到数组的末尾，并且不调用 compareFn）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0a 在 b 后，如 [b, a]</span><br><span class="line">&lt; 0a 在 b 前，如 [a, b]</span><br><span class="line">=== 0保持 a 和 b 原来的顺序</span><br></pre></td></tr></table></figure><p>ok，在知道了这个条件以后，我们就可以开始排序了, 比如我们需要从低到高排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">19</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>];</span><br><span class="line">sortArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortArr);</span><br></pre></td></tr></table></figure><p>大概是这样。</p><p>在大量且性能要求高的地方需要知道究竟是怎么算的，详情看这里 <a href="https://segmentfault.com/a/1190000010648740">https://segmentfault.com/a/1190000010648740</a> ，多看看算法和源码。</p><h3 id="34-Array-prototype-toSorted"><a href="#34-Array-prototype-toSorted" class="headerlink" title="34. Array.prototype.toSorted()"></a>34. Array.prototype.toSorted()</h3><blockquote><p>Array 实例的 toSorted() 方法是 sort() 方法的复制方法版本。它返回一个新数组，其元素按升序排列。</p></blockquote><p>需要注意的是，依然是浅拷贝。</p><h3 id="35-Array-prototype-splice"><a href="#35-Array-prototype-splice" class="headerlink" title="35. Array.prototype.splice()"></a>35. Array.prototype.splice()</h3><blockquote><p>splice() 方法通过移除或者替换已存在的元素和&#x2F;或添加新元素就地改变一个数组的内容。</p></blockquote><p>slice 是截取，splice 是移除或者替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">splice</span>(start)</span><br><span class="line"><span class="title function_">splice</span>(start, deleteCount)</span><br><span class="line"><span class="title function_">splice</span>(start, deleteCount, item1)</span><br><span class="line"><span class="title function_">splice</span>(start, deleteCount, item1, item2, itemN)</span><br></pre></td></tr></table></figure><p>start，遵循之前的其他数组的规则。</p><ul><li>允许负数，param + array.length</li><li>param &lt; -array.length &#x3D; 0</li><li>start &gt;&#x3D; array.length， 不截取</li></ul><p>deleteCount，0 或者不传入就不删除，类似于插入，如果传入，就从start开始计算，deleteCount的几位。</p><p>最后就是替换或者插入多少个, 写几个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="keyword">const</span> spliceArr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>];</span><br><span class="line">spliceArr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除`</span>, spliceArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> splice1Arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>];</span><br><span class="line">spliceArr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`插入`</span>, spliceArr);</span><br></pre></td></tr></table></figure><p>替换就是删除+插入。</p><h3 id="36-Array-prototype-toSpliced"><a href="#36-Array-prototype-toSpliced" class="headerlink" title="36. Array.prototype.toSpliced()"></a>36. Array.prototype.toSpliced()</h3><blockquote><p>Array 实例的 toSpliced() 方法是 splice() 方法的复制版本。它返回一个新数组，并在给定的索引处删除和&#x2F;或替换了一些元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toSpliced</span>(start)</span><br><span class="line"><span class="title function_">toSpliced</span>(start, deleteCount)</span><br><span class="line"><span class="title function_">toSpliced</span>(start, deleteCount, item1)</span><br><span class="line"><span class="title function_">toSpliced</span>(start, deleteCount, item1, item2, itemN)</span><br></pre></td></tr></table></figure><p>老规矩，浅拷贝。</p><h3 id="37-Array-prototype-toLocaleString-Array-prototype-toString"><a href="#37-Array-prototype-toLocaleString-Array-prototype-toString" class="headerlink" title="37. Array.prototype.toLocaleString(), Array.prototype.toString()"></a>37. Array.prototype.toLocaleString(), Array.prototype.toString()</h3><blockquote><p>toLocaleString() 方法返回一个字符串，表示数组中的所有元素。每个元素通过调用它们自己的 toLocaleString 方法转换为字符串，并且使用特定于语言环境的字符串（例如逗号“,”）分隔开。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="title function_">toLocaleString</span>(locales)</span><br><span class="line"><span class="title function_">toLocaleString</span>(locales, options)</span><br></pre></td></tr></table></figure><p>locales </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_%E5%8F%82%E6%95%B0">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_%E5%8F%82%E6%95%B0</a></p><p><a href="https://juejin.cn/post/6844903863556767758">https://juejin.cn/post/6844903863556767758</a></p><blockquote><p>BCP 47（Best Current Practice 47）是一个标准，用于表示语言标签，它规定了一种语言标记的格式和结构。BCP 47 最初由IETF（Internet Engineering Task Force）发布，并被广泛用于标识语言、地区和文化相关的信息，如语言代码、地区代码和区域设置等</p></blockquote><p>toString 一样，分别调用每个 item 的 toString().</p><p>还有，两位都认稀疏数组。</p><h3 id="38-Array-prototype-values"><a href="#38-Array-prototype-values" class="headerlink" title="38. Array.prototype.values()"></a>38. Array.prototype.values()</h3><blockquote><p>values() 方法返回一个新的数组迭代器 (en-US)对象，该对象迭代数组中每个元素的值。</p></blockquote><p>之前讲了 Array.prototype.keys, 返回了索引， values 就是返回值</p><h3 id="39-Array-prototype-with"><a href="#39-Array-prototype-with" class="headerlink" title="39. Array.prototype.with()"></a>39. Array.prototype.with()</h3><blockquote><p>Array 实例的 with() 方法是使用方括号表示法修改指定索引值的复制方法版本。它会返回一个新数组，其指定索引处的值会被新值替换。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">with</span>(index, value)</span><br></pre></td></tr></table></figure><p>其实和 splice 很像，不过 splice 功能更全</p><blockquote><p>with() 方法总会创建一个密集数组。</p></blockquote><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable">Symbol.isConcatSpreadable</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator">Iterator</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议</a></li><li><a href="https://segmentfault.com/a/1190000010648740">深入浅出 JavaScript 的 Array.prototype.sort 排序算法</a></li><li><a href="https://www.toolhelper.cn/Encoding/UTF16">UTF-16 编码表</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_%E5%8F%82%E6%95%B0">locales 参数</a></li><li><a href="https://juejin.cn/post/6844903863556767758">locales 参数 BCP 47 语言标记 解析</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器事件流</title>
      <link href="/2023/07/09/browser_event/"/>
      <url>/2023/07/09/browser_event/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-dom-事件级别"><a href="#01-dom-事件级别" class="headerlink" title="01. dom 事件级别"></a>01. dom 事件级别</h3><blockquote><p>DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理</p></blockquote><p>DOM 0 </p><blockquote><p>用于处理基本的用户交互，如鼠标点击、键盘输入和表单提交等。一些常见的第一级事件包括click、keydown、submit等。</p></blockquote><p>DOM 2</p><blockquote><p>例如，mouseenter和mouseleave事件在第二级事件中引入，用于检测鼠标进入和离开元素的区域, addEventListener</p></blockquote><p>DOM 3</p><blockquote><p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件。</p></blockquote><p>为什么要这样区分呢？</p><p>其实就是一个不断演进的过程，所以不用纠结这个区分，类似于， ES4，ES5，ES6，ES7一样，现在怕是没有只支持 DOM0 的浏览器了。</p><h3 id="02-什么是事件冒泡和捕获"><a href="#02-什么是事件冒泡和捕获" class="headerlink" title="02. 什么是事件冒泡和捕获"></a>02. 什么是事件冒泡和捕获</h3><blockquote><p>事件冒泡（Event Bubbling）是指在DOM中，当一个元素上的事件被触发后，事件将向父元素逐级传播，直至传播到DOM树的根节点或被阻止</p><p>事件捕获（Event Capturing）是指在DOM中，当一个元素上的事件被触发时，事件将从DOM树的根节点开始，逐级向下传播至目标元素。换句话说，事件从最外层的元素开始传播，依次经过父元素、子元素，直到传播到目标元素。</p></blockquote><p>在事件流里面，其实就是 <strong>捕获 &#x3D;&gt; 自身 &#x3D;&gt; 冒泡</strong></p><p>这里写了一个简单的例子，代码在 <a href="https://codesandbox.io/s/hardcore-glitter-h9v8kq?file=/browser_event.html">https://codesandbox.io/s/hardcore-glitter-h9v8kq?file=/browser_event.html</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>多层嵌套的事件捕获和冒泡示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#outer</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#middle</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#inner</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 获取元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> outer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;outer&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> middle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;middle&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> inner = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inner&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">name</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="string">`<span class="subst">$&#123;event.target.id&#125;</span> 触发了, 现在处于的阶段是 <span class="subst">$&#123;event.eventPhase&#125;</span>, 在传递到了<span class="subst">$&#123;name&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">          );</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 添加事件处理程序</span></span></span><br><span class="line"><span class="language-javascript">      outer.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`outer`</span>), <span class="literal">true</span>); <span class="comment">// 事件捕获阶段</span></span></span><br><span class="line"><span class="language-javascript">      middle.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`middle`</span>), <span class="literal">true</span>); <span class="comment">// 事件捕获阶段</span></span></span><br><span class="line"><span class="language-javascript">      inner.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`inner`</span>), <span class="literal">true</span>); <span class="comment">// 事件捕获阶段</span></span></span><br><span class="line"><span class="language-javascript">      btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`btn`</span>), <span class="literal">true</span>); <span class="comment">// 事件捕获阶段</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      outer.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`outer`</span>), <span class="literal">false</span>); <span class="comment">// 事件冒泡阶段</span></span></span><br><span class="line"><span class="language-javascript">      middle.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`middle`</span>), <span class="literal">false</span>); <span class="comment">// 事件冒泡阶段</span></span></span><br><span class="line"><span class="language-javascript">      inner.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`inner`</span>), <span class="literal">false</span>); <span class="comment">// 事件冒泡阶段</span></span></span><br><span class="line"><span class="language-javascript">      btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">f</span>(<span class="string">`btn`</span>), <span class="literal">false</span>); <span class="comment">// 事件冒泡阶段</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 1, 在传递到了outer</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 1, 在传递到了middle</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 1, 在传递到了inner</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 2, 在传递到了btn</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 2, 在传递到了btn</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 3, 在传递到了inner</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 3, 在传递到了middle</li><li>browser_event.html:50 btn 触发了, 现在处于的阶段是 3, 在传递到了outer</li></ul><p>首先不会执行两次，我这里是捕获了2次。 </p><p>event.eventPhase 表示冒泡执行的阶段， <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/eventPhase">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/eventPhase</a></p><ul><li>Event.CAPTURING_PHASE (1)：表示事件处于捕获阶段。</li><li>Event.AT_TARGET (2)：表示事件处于目标元素阶段。</li><li>Event.BUBBLING_PHASE (3)：表示事件处于冒泡阶段。</li></ul><p>这里就验证了这个流 <strong>捕获 &#x3D;&gt; 自身 &#x3D;&gt; 冒泡</strong></p><h3 id="03-addEventListener"><a href="#03-addEventListener" class="headerlink" title="03. addEventListener"></a>03. addEventListener</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(type, listener); <span class="comment">//不传默认为false, 也就是冒泡</span></span><br><span class="line"><span class="title function_">addEventListener</span>(type, listener, options);</span><br><span class="line"><span class="title function_">addEventListener</span>(type, listener, useCapture);</span><br></pre></td></tr></table></figure><p>主要还是要说一说 <code>options</code></p><ul><li>capture 可选, 一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li><li>once 可选, 一个布尔值，表示 listener 在添加之后最多只调用一次。如果为 true，listener 会在其被调用之后自动移除。</li><li>passive 可选, 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看使用 passive 改善滚屏性能以了解更多。</li><li>signal 可选,  AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。</li></ul><p>前两个很好理解。</p><p>preventDefault <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault</a> 取消默认行为.</p><p>signal </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eventListener</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件被触发&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, eventListener, &#123; signal &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个条件满足时中止事件监听器</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><h3 id="04-onclick"><a href="#04-onclick" class="headerlink" title="04. onclick"></a>04. onclick</h3><p>只能冒泡，不能捕获。</p><p>只能一次，不能像 addEventListener 多次，也不能取消。</p><h3 id="05-为什么我们要知道事件冒泡和事件委托？"><a href="#05-为什么我们要知道事件冒泡和事件委托？" class="headerlink" title="05. 为什么我们要知道事件冒泡和事件委托？"></a>05. 为什么我们要知道事件冒泡和事件委托？</h3><p>这就是一个性能问题.</p><p>当你有一个这样的列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> * 100， </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你需要每一个 li 都有事件，如果每一个 li 都绑定事件，那么性能大打折扣，如果利用事件冒泡，只需要在 ul 中绑定事件，就可以解决。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器复制</title>
      <link href="/2023/07/08/clipboard/"/>
      <url>/2023/07/08/clipboard/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>实现原理 Clipboard Api</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>().<span class="title function_">then</span>(<span class="function"><span class="params">clipText</span> =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.editor&quot;</span>).<span class="property">innerText</span> += clipText);</span><br></pre></td></tr></table></figure><p>以前的做法是 <code>document.execCommand</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(aCommandName, aShowDefaultUI, aValueArgument)</span><br></pre></td></tr></table></figure><p>现在已经废弃了，就看你是否要兼容老浏览器。</p><p>这里是组件的 clipboard-copy 的源码</p><p><a href="https://github.com/feross/clipboard-copy/blob/master/index.js">https://github.com/feross/clipboard-copy/blob/master/index.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! clipboard-copy. MIT License. Feross Aboukhadijeh &lt;https://feross.org/opensource&gt; */</span></span><br><span class="line"><span class="comment">/* global DOMException */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = clipboardCopy</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeError</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DOMException</span>(<span class="string">&#x27;The request is not allowed&#x27;</span>, <span class="string">&#x27;NotAllowedError&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copyClipboardApi</span> (text) &#123;</span><br><span class="line">  <span class="comment">// Use the Async Clipboard API when available. Requires a secure browsing</span></span><br><span class="line">  <span class="comment">// context (i.e. HTTPS)</span></span><br><span class="line">  <span class="keyword">if</span> (!navigator.<span class="property">clipboard</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title function_">makeError</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copyExecCommand</span> (text) &#123;</span><br><span class="line">  <span class="comment">// Put the text to copy into a &lt;span&gt;</span></span><br><span class="line">  <span class="keyword">const</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">  span.<span class="property">textContent</span> = text</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Preserve consecutive spaces and newlines</span></span><br><span class="line">  span.<span class="property">style</span>.<span class="property">whiteSpace</span> = <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">  span.<span class="property">style</span>.<span class="property">webkitUserSelect</span> = <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">  span.<span class="property">style</span>.<span class="property">userSelect</span> = <span class="string">&#x27;all&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the &lt;span&gt; to the page</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(span)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a selection object representing the range of text selected by the user</span></span><br><span class="line">  <span class="keyword">const</span> selection = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>()</span><br><span class="line">  <span class="keyword">const</span> range = <span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line">  selection.<span class="title function_">removeAllRanges</span>()</span><br><span class="line">  range.<span class="title function_">selectNode</span>(span)</span><br><span class="line">  selection.<span class="title function_">addRange</span>(range)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy text to the clipboard</span></span><br><span class="line">  <span class="keyword">let</span> success = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    success = <span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    selection.<span class="title function_">removeAllRanges</span>()</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(span)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!success) <span class="keyword">throw</span> <span class="title function_">makeError</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">clipboardCopy</span> (text) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">copyClipboardApi</span>(text)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// ...Otherwise, use document.execCommand() fallback</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">copyExecCommand</span>(text)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (err2 || err || <span class="title function_">makeError</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是两个做法的结合的封装</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 剪切板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 如何实现左侧固定 300px，右侧自适应的布局</title>
      <link href="/2023/07/08/%5BQ017%5DHow_does_css_achieve_a_fixed_300px_on_the_left_and_an_daptive_layout_on_the_right/"/>
      <url>/2023/07/08/%5BQ017%5DHow_does_css_achieve_a_fixed_300px_on_the_left_and_an_daptive_layout_on_the_right/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-flex"><a href="#01-flex" class="headerlink" title="01. flex"></a>01. flex</h3><p>主要利用 flex 特性, 如果只有一个 flex: 1 撑满</p><p><a href="https://codesandbox.io/s/frosty-haze-wqmm8l">https://codesandbox.io/s/frosty-haze-wqmm8l</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="02-float"><a href="#02-float" class="headerlink" title="02. float"></a>02. float</h3><p><a href="https://codesandbox.io/s/fancy-dream-nktwvm?file=/%5BQ017%5DHow_does_css_achieve_a_fixed_300px_on_the_left_and_an_daptive_layout_on_the_right_two.html">https://codesandbox.io/s/fancy-dream-nktwvm?file=/%5BQ017%5DHow_does_css_achieve_a_fixed_300px_on_the_left_and_an_daptive_layout_on_the_right_two.html</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 做题 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 nextTick</title>
      <link href="/2023/07/08/nextTick/"/>
      <url>/2023/07/08/nextTick/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-什么是-nextTick"><a href="#01-什么是-nextTick" class="headerlink" title="01. 什么是 nextTick"></a>01. 什么是 nextTick</h3><p>首先要知道什么是 nextTick</p><blockquote><p>等待下一次 DOM 更新刷新的工具方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">callback?: () =&gt; <span class="built_in">void</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;</span><br></pre></td></tr></table></figure><p>这里说了语法和定义，下面这个例子会会说明，为什么需要 nextTick</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOM 还未更新</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">    <span class="comment">// DOM 此时已经更新</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>nextTick 例子1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;counter&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里展示一下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 index.vue:14 </span><br><span class="line">1 index.vue:10 </span><br><span class="line">1 index.vue:14 </span><br><span class="line">2 index.vue:14 </span><br></pre></td></tr></table></figure><p>就是说，当 <code>count.value++</code> 变量发生变化，他不会立刻更新，而是触发调度。</p><p>为什么要这么做？</p><p>如果我写一个循环</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    count.<span class="property">value</span> = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<strong>vue</strong> 是不是需要更新 <strong>1000</strong> 次？很明显不是。也就是说中间有一个调度</p><p>那么 <code>nextTick</code> 就是等待更新完成以后，会调用的回调，他可以使用 <code>await</code>, 也可以使用回调。</p><h3 id="02-调度过程"><a href="#02-调度过程" class="headerlink" title="02. 调度过程"></a>02. 调度过程</h3><p>我在看 nextTick 之前，专门学习了一下任务调度的源码，地址在这里 <a href="/tblog/2023/07/08/Vue3_queue/">任务调度源码解析</a>。</p><p>这里可以解释</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    count.<span class="property">value</span> = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不会一直更新。</p><h3 id="03-nextTick-源码"><a href="#03-nextTick-源码" class="headerlink" title="03. nextTick 源码"></a>03. nextTick 源码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="comment">/*#__PURE__*/</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() <span class="keyword">as</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> nextTick&lt;T = <span class="built_in">void</span>&gt;(</span><br><span class="line">  <span class="attr">this</span>: T,</span><br><span class="line">  fn?: <span class="function">(<span class="params"><span class="variable language_">this</span>: T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(<span class="variable language_">this</span> ? fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>currentFlushPromise</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 flushJobs 执行完成所有当前 Job 以后的 finally 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentFlushPromise = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>所以这个这个原理就很清楚了</p><p>当你修改了属性，然后后面设置了 nextTick. 就会在执行 flushJobs(也就是一个更新的循环) 以后，执行 nextTick。</p><p>如果你没有修改任何属性，那么 nextTick 就是一个单纯的异步，一个微任务。</p><h3 id="04-总结"><a href="#04-总结" class="headerlink" title="04. 总结"></a>04. 总结</h3><p>这个够清晰了，不用总结了…</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 任务调度 </tag>
            
            <tag> Vue3 </tag>
            
            <tag> nextTick </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 任务调度源码解析</title>
      <link href="/2023/07/08/Vue3_queue/"/>
      <url>/2023/07/08/Vue3_queue/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-queueJob"><a href="#01-queueJob" class="headerlink" title="01. queueJob"></a>01. queueJob</h3><p>首先需要知道这个接口的定义，他就是任务调度的 <strong>job</strong> 定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">SchedulerJob</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">  id?: <span class="built_in">number</span> <span class="comment">//唯一ID</span></span><br><span class="line">  pre?: <span class="built_in">boolean</span> <span class="comment">//是否是预处理</span></span><br><span class="line">  active?: <span class="built_in">boolean</span> <span class="comment">//是否激活</span></span><br><span class="line">  computed?: <span class="built_in">boolean</span> <span class="comment">//是否是计算任务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 表示是否允许该效果自行递归触发</span></span><br><span class="line"><span class="comment">    * 当由调度程序管理时。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 默认情况下，作业无法自行触发，因为某些内置方法调用，</span></span><br><span class="line"><span class="comment">    * 例如 Array.prototype.push 实际上也执行读取（#1740）</span></span><br><span class="line"><span class="comment">    * 可能导致令人困惑的无限循环。</span></span><br><span class="line"><span class="comment">    * 允许的情况是组件更新函数和监视回调。</span></span><br><span class="line"><span class="comment">    * 组件更新函数可能会更新子组件 props，进而更新子组件 props</span></span><br><span class="line"><span class="comment">    * 触发刷新：“预”监视回调，该回调会改变父级的状态</span></span><br><span class="line"><span class="comment">    * 依赖于（#1801）。 监视回调不会跟踪其依赖项，因此如果</span></span><br><span class="line"><span class="comment">    * 再次触发自身，这可能是故意的，并且是用户的</span></span><br><span class="line"><span class="comment">    * 负责执行递归状态突变，最终</span></span><br><span class="line"><span class="comment">    * 稳定（#1727）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置组件渲染效果时由renderer.ts附加</span></span><br><span class="line"><span class="comment">    * 用于在报告最大递归更新时获取组件信息。</span></span><br><span class="line"><span class="comment">    * 仅限开发人员。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  ownerInstance?: <span class="title class_">ComponentInternalInstance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下面是入口, 传入一个 <code>job</code>, 并且 <code>push</code> 进入队列。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="comment">// 重复数据删除搜索使用 Array.includes() 的 startIndex 参数</span></span><br><span class="line">  <span class="comment">// 默认情况下，搜索索引包括当前正在运行的作业</span></span><br><span class="line">  <span class="comment">// 所以它不能再次递归地触发自身。</span></span><br><span class="line">  <span class="comment">// 如果作业是 watch() 回调，则搜索将从 +1 索引开始</span></span><br><span class="line">  <span class="comment">// 允许它递归地触发自身 - 用户有责任</span></span><br><span class="line">  <span class="comment">// 确保它不会陷入无限循环。</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !queue.<span class="property">length</span> ||</span><br><span class="line">    !queue.<span class="title function_">includes</span>(</span><br><span class="line">      job,</span><br><span class="line">      isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (job.<span class="property">id</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(job)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue.<span class="title function_">splice</span>(<span class="title function_">findInsertionIndex</span>(job.<span class="property">id</span>), <span class="number">0</span>, job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">queueFlush</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const queue: SchedulerJob[] = []</code> 这是一个 <code>SchedulerJob</code> 数组.</p><p><code>job.id = instance.uid</code> 也就是 <code>Vue</code> 实例的唯一ID</p><h3 id="02-queueFlush"><a href="#02-queueFlush" class="headerlink" title="02. queueFlush"></a>02. queueFlush</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> <span class="comment">//是否有更新循环正在执行</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span> <span class="comment">//是否有等待中的更新循环</span></span><br></pre></td></tr></table></figure><p>这两个标志位主要是为了保证，一次性只执行一个更新循环，当没有循环.</p><p>设置 <code>isFlushPending = true</code>，然后设置微任务</p><p>到这里我们其实已经可以知道他的大概调度流程.</p><p>当触发更新，调用 <code>queueJob =&gt; 如果没有重复 =&gt; queue.push =&gt; queueFlush =&gt; 如果没有执行 =&gt; 加入微任务(flushJobs)</code></p><p>这样一个流程说明了什么？</p><p>首先 <code>queueJob</code> 需要去重，<code>include</code>, 位置判断是基于是否允许递归调用。</p><p>也就是说，如果你</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根本不会增加队列中 <code>job</code>, 他始终保证了只有一个。</p><p>第二个点就是微任务, 我之前写了一个文章，<a href="/tblog/2023/07/03/eventLoop/">浏览器事件循环总结</a>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="comment">/*#__PURE__*/</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() <span class="keyword">as</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br></pre></td></tr></table></figure><p>这里就是把 <code>flushJobs</code> 当做微任务来执行，也就是说，需要主线程的代码执行完毕以后，再执行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isFlushPending = <span class="literal">true</span></span><br><span class="line">currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br></pre></td></tr></table></figure><p>当这个代码执行，就是一次更新循环，js主线程执行完毕以后，开始执行队列，flushJobs，这个就是所谓的操作合并。</p><p>这里明白了这两个点，其实就已经大概明白了事件调度。</p><h3 id="03-flushJobs"><a href="#03-flushJobs" class="headerlink" title="03. flushJobs"></a>03. flushJobs</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  isFlushPending = <span class="literal">false</span></span><br><span class="line">  isFlushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在刷新之前对队列进行排序。</span></span><br><span class="line">   <span class="comment">// 这确保了：</span></span><br><span class="line">   <span class="comment">// 1. 组件从父级更新到子级。 （因为父母总是</span></span><br><span class="line">   <span class="comment">// 在子进程之前创建，因此它的渲染效果会更小</span></span><br><span class="line">   <span class="comment">// 优先级编号）</span></span><br><span class="line">   <span class="comment">// 2. 如果在父组件更新期间卸载了组件，</span></span><br><span class="line">   <span class="comment">// 可以跳过它的更新。</span></span><br><span class="line">  queue.<span class="title function_">sort</span>(comparator)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// checkRecursiveUpdate 的条件使用必须由以下确定</span></span><br><span class="line">   <span class="comment">// try ... catch 块，因为 Rollup 默认情况下会取消对 treeshaking 的优化</span></span><br><span class="line">   <span class="comment">// 在 try-catch 中。 这可以使所有警告代码保持不变。 虽然</span></span><br><span class="line">   <span class="comment">// 他们最终会被像 terser 这样的缩小器动摇，一些缩小器</span></span><br><span class="line">   <span class="comment">// 将无法做到这一点（例如 https://github.com/evanw/esbuild/issues/1610）</span></span><br><span class="line">  <span class="keyword">const</span> check = __DEV__</span><br><span class="line">    ? <span class="function">(<span class="params">job: SchedulerJob</span>) =&gt;</span> <span class="title function_">checkRecursiveUpdates</span>(seen!, job)</span><br><span class="line">    : <span class="variable constant_">NOOP</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title function_">check</span>(job)) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// console.log(`running:`, job.id)</span></span><br><span class="line">        <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    flushIndex = <span class="number">0</span></span><br><span class="line">    queue.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line"></span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">    currentFlushPromise = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 一些 postFlushCb 排队作业！</span></span><br><span class="line">    <span class="comment">// 继续冲洗直到排空。</span></span><br><span class="line">    <span class="keyword">if</span> (queue.<span class="property">length</span> || pendingPostFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">flushJobs</span>(seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里在注释里面已经说的很明确了，在这里可以开始讲一讲关于 <code>isFlushing &amp; isFlushPending</code>.</p><p><code>isFlushPending = true</code> 表示，<code>flushJobs</code> 加入微任务以后 &#x3D;&gt; 开始执行这一个区间, 其他为 false.<br><code>isFlushing = true</code> 表示 <code>flushJobs</code> 正在执行的区间</p><p>还有一个需要注意的点 <code>queue.sort(comparator)</code>, 为什么需要排序，以及 <code>id</code> 的意义，在注释中都解释了</p><p>然后遍历队列，全部执行。</p><p>然后执行回调 <code>flushPostFlushCbs</code></p><p>然后开始继续执行 <code>flushJobs(seen)</code>，因为在执行之前的 <code>queue</code> 的时候，可能也有需要插入队列。</p><h3 id="04-flushPostFlushCbs"><a href="#04-flushPostFlushCbs" class="headerlink" title="04. flushPostFlushCbs"></a>04. flushPostFlushCbs</h3><p>简单说就是执行回调函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPostFlushCbs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pendingPostFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> deduped = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPostFlushCbs)]</span><br><span class="line">    pendingPostFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1947 already has active queue, nested flushPostFlushCbs call</span></span><br><span class="line">    <span class="keyword">if</span> (activePostFlushCbs) &#123;</span><br><span class="line">      activePostFlushCbs.<span class="title function_">push</span>(...deduped)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activePostFlushCbs = deduped</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activePostFlushCbs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">getId</span>(a) - <span class="title function_">getId</span>(b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">      postFlushIndex = <span class="number">0</span>;</span><br><span class="line">      postFlushIndex &lt; activePostFlushCbs.<span class="property">length</span>;</span><br><span class="line">      postFlushIndex++</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        <span class="title function_">checkRecursiveUpdates</span>(seen!, activePostFlushCbs[postFlushIndex])</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      activePostFlushCbs[postFlushIndex]()</span><br><span class="line">    &#125;</span><br><span class="line">    activePostFlushCbs = <span class="literal">null</span></span><br><span class="line">    postFlushIndex = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些回调函数是在 <code>pendingPostFlushCbs</code> 当中, 他可能是 <code>queuePostRenderEffect</code> 加入的, <code>queuePostRenderEffect</code> 是各种生命周期函数加入的。</p><h3 id="05-总结。"><a href="#05-总结。" class="headerlink" title="05. 总结。"></a>05. 总结。</h3><p>这里解释了 Vue3.x 调度的大概流程，我之所以想看这个，是因为我在看 <code>nextTick</code> 源码, 不看这个无法完全理解 <code>nextTick</code>.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 源码 </tag>
            
            <tag> queue </tag>
            
            <tag> 任务调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fetch 简单介绍</title>
      <link href="/2023/07/07/web_fetch/"/>
      <url>/2023/07/07/web_fetch/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-什么是-fetch"><a href="#01-什么是-fetch" class="headerlink" title="01. 什么是 fetch"></a>01. 什么是 fetch</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/fetch</a></p><p><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html</a></p><blockquote><p>fetch()是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生提供这个对象</p></blockquote><p><a href="https://caniuse.com/?search=fetch">https://caniuse.com/?search=fetch</a> 现代浏览器都支持.</p><blockquote><p>（1）fetch()使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p><p>（2）fetch()采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p><p>（3）fetch()通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来</p></blockquote><p>原生支持 promise.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_">fetch</span>(myUrl)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">blob</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(blob.<span class="property">type</span>)) <span class="keyword">return</span> <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">        target.<span class="property">blob</span> = url;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        target.<span class="title function_">showError</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;URL不正确或MIME类型不正确&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这是我之前获取图片的一个例子，是通过 res获取二进制文件的例子。</p><p>理论上到这里就可以开始基本的使用了，剩下的就是大概的知道有什么属性，api，用的时候查。</p><h3 id="02-Response"><a href="#02-Response" class="headerlink" title="02. Response"></a>02. Response</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">https://developer.mozilla.org/zh-CN/docs/Web/API/Response</a></p><p><strong>数据类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Response</span>.<span class="title function_">arrayBuffer</span>()  <span class="comment">//二进制 流媒体</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">blob</span>()  <span class="comment">//二进制 blob，图片之类</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">formData</span>() <span class="comment">//表单</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">json</span>()</span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">text</span>()</span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">clone</span>()</span><br></pre></td></tr></table></figure><p>这里需要注意的是 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Response</span>.<span class="title function_">text</span>()</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Response</span>.<span class="title function_">json</span>() <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>所以需要先 <code>clone()</code></p><p><strong>状态码和基本属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Response</span>.<span class="property">ok</span> <span class="number">200</span> &lt; <span class="title class_">Response</span>.<span class="property">status</span> &lt; <span class="number">299</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">status</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">statusText</span> <span class="comment">//字符串，ok</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">type</span> <span class="comment">//请求类型</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">url</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">redirected</span> <span class="comment">//请求是否发生过跳转</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="title function_">redirect</span>() <span class="comment">//跳转</span></span><br></pre></td></tr></table></figure><p><strong>body</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Response</span>.<span class="property">body</span> <span class="comment">//ReadableStream</span></span><br><span class="line"><span class="title class_">Response</span>.<span class="property">bodyUsed</span> <span class="comment">//bodyUsed 是 Response mixin 中的一个只读属性。用以表示该 body 是否被使用过。</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream">https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>) <span class="comment">// 发起网络请求</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>(); <span class="comment">// 获取 ReadableStreamDefaultReader 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">readStream</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> reader.<span class="title function_">read</span>() <span class="comment">// 逐块读取数据</span></span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据读取完毕&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理读取的数据</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取数据块:&#x27;</span>, value);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 继续读取下一个数据块</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">readStream</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;读取数据时发生错误:&#x27;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readStream</span>(); <span class="comment">// 开始读取数据流</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求数据时发生错误:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>Response.headers</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">https://developer.mozilla.org/zh-CN/docs/Web/API/Headers</a></p><p>以上就是 response 大概参数，重点其实是类型获取和body</p><h3 id="03-options"><a href="#03-options" class="headerlink" title="03. options"></a>03. options</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/fetch</a></p><ul><li>method: 请求使用的方法，如 GET、POST。</li><li>headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString 值的对象字面量。</li><li>body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li><li>mode: 请求的模式，如 cors、no-cors 或者 same-origin。</li><li>credentials: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie，必须提供这个选项，从 Chrome 50 开始，这个属性也可以接受 FederatedCredential (en-US) 实例或是一个 PasswordCredential (en-US) 实例。</li><li>cache: 请求的 cache 模式：default、 no-store、 reload 、 no-cache、 force-cache 或者 only-if-cached。</li><li>redirect: 可用的 redirect 模式：follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误），或者 manual (手动处理重定向)。在 Chrome 中默认使用 follow（Chrome 47 之前的默认值是 manual）。</li><li>referrer: 一个 USVString 可以是 no-referrer、client 或一个 URL。默认是 client。</li><li>referrerPolicy: 指定了 HTTP 头部 referer 字段的值。可能为以下值之一：no-referrer、 no-referrer-when-downgrade、origin、origin-when-cross-origin、 unsafe-url。</li><li>integrity: 包括请求的 subresource integrity 值（例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE&#x3D;）。</li><li>signal: AbortController</li><li>keepalive</li></ul><h3 id="04-终止-fetch"><a href="#04-终止-fetch" class="headerlink" title="04. 终止 fetch"></a>04. 终止 fetch</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController">https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController</a></p><p>他不仅仅可以终止 fetch，还可以终止 xmlHttpRequest.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>(); <span class="comment">// 取消</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>fetch</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/long-operation&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> == <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Aborted!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结。"><a href="#总结。" class="headerlink" title="总结。"></a>总结。</h3><p>其实差不多，主要语法和用法上的差别。fetch原生 原生Promise 链式语法，其他更大区别，在于流式数据处理，response.body</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> fetch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载方案</title>
      <link href="/2023/07/06/web_img_lazy_loading/"/>
      <url>/2023/07/06/web_img_lazy_loading/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>虽然这里只说图片懒加载，还是得知道什么是懒加载</p><blockquote><p>延迟加载（懒加载）是一种将资源标识为非阻塞（非关键）资源并仅在需要时加载它们的策略。这是一种缩短关键渲染路径长度的方法，可以缩短页面加载时间。</p></blockquote><p>如果只局限到图片这一个点上，就是延后加载非必须的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=`` /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="01-位置计算-滚动事件-Scroll-DataSet-API"><a href="#01-位置计算-滚动事件-Scroll-DataSet-API" class="headerlink" title="01. 位置计算 + 滚动事件 (Scroll) + DataSet API"></a>01. 位置计算 + 滚动事件 (Scroll) + DataSet API</h3><p>就是说，我知道图片位置，我能监听滚动事件，当图片位置和滚动事件重合的时候，获取图片的 data-src, 渲染图片.</p><p>有些网站方案细节不一样，比如提前多少距离加载。</p><p>这种方案有点儿类似于移动端分页，划到某些位置自动加载下面的。</p><p>在这个思路之下，写了一点代码 <a href="https://codesandbox.io/s/polished-resonance-fw3hfy?file=/index.html">方案一 Demo</a></p><p>url 可以换，这个方案最大的问题是什么？</p><p>这里还可以有什么优化的点？比如 ImgClass 完成以后需要删除监听。其他就是优化判断是否在里面。</p><h3 id="02-方案2-getBoundingClientRect"><a href="#02-方案2-getBoundingClientRect" class="headerlink" title="02. 方案2 getBoundingClientRect"></a>02. 方案2 getBoundingClientRect</h3><blockquote><p>getBoundingClientRect 是一个 DOM 元素的方法，它返回一个包含该元素位置和尺寸信息的 DOMRect 对象。DOMRect 对象包含以下属性：</p><p>top：元素上边界相对于视口顶部的距离。<br>right：元素右边界相对于视口左边的距离。<br>bottom：元素下边界相对于视口顶部的距离。<br>left：元素左边界相对于视口左边的距离。<br>width：元素的宽度。<br>height：元素的高度。</p></blockquote><p>他的 top 是基于滚动的位置, 是基于 document.documentElement.scrollTop 再做运算的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isInViewport</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">element</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://caniuse.com/?search=getBoundingClientRect">https://caniuse.com/?search=getBoundingClientRect</a> 兼容性ok.</p><h3 id="03-方案3-Intersection-Observer-API"><a href="#03-方案3-Intersection-Observer-API" class="headerlink" title="03. 方案3 Intersection_Observer_API"></a>03. 方案3 Intersection_Observer_API</h3><blockquote><p>Intersection Observer API 是一个用于观察元素在视口中可见性变化的 JavaScript API。它提供了一种异步方式来监听一个或多个元素与其祖先元素或整个文档视口的交叉状态。通过使用 Intersection Observer API，开发者可以有效地检测元素是否进入或离开视口，或者与其他元素相交的程度。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt; * <span class="number">10</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 创建 Intersection Observer 对象</span></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">                <span class="comment">// 元素进入视口时添加 CSS 类名</span></span><br><span class="line">                entry.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;visible&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 元素离开视口时移除 CSS 类名</span></span><br><span class="line">                entry.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;visible&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听所有具有 &quot;.box&quot; 类名的元素</span></span><br><span class="line">    <span class="keyword">const</span> boxes = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">    boxes.<span class="title function_">forEach</span>(<span class="function"><span class="params">box</span> =&gt;</span> &#123;</span><br><span class="line">        observer.<span class="title function_">observe</span>(box);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这是一个简单例子，如果用在之前的例子中应用 <a href="https://codesandbox.io/s/polished-resonance-fw3hfy?file=/intersectionObserver.html">demo</a></p><p><a href="https://caniuse.com/?search=IntersectionObserver">https://caniuse.com/?search=IntersectionObserver</a></p><h3 id="04-方案4"><a href="#04-方案4" class="headerlink" title="04. 方案4"></a>04. 方案4</h3><p><a href="https://caniuse.com/?search=loading">https://caniuse.com/?search=loading</a></p><p>这个方案最简单直接，而且浏览器直支持，现在来看还行。</p><blockquote><p>loading 属性是 HTML <img> 元素的一个属性，用于指定图像的加载行为。该属性可帮助开发者优化图像的加载性能和用户体验。loading 属性在 HTML5.2 规范中被引入，支持现代浏览器。</p></blockquote><p>loading 属性有以下几个可选值：</p><ul><li>auto：默认值，浏览器自动选择加载方式，根据网络条件和用户体验来决定。</li><li>lazy：图像延迟加载，只有当图像进入视口附近时才开始加载。这可以提高页面的加载速度和性能。</li><li>eager：图像立即加载，优先级高于页面其他内容的加载。适用于需要尽快展示图像的情况。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一种方案兼容性最好，所有浏览器都能支持，因为他就是靠位置计算。</p><p>第二种方法，getBoundingClientRect，可以根据当前浏览的窗口来计算 top。</p><p>第三种方法，IntersectionObserver，他避免了对于 scoll 事件的监控，很平滑。</p><p>第四种方法，loading &#x3D; lazy 其实简单有效，但是原理目前不是很清楚。</p><p><a href="https://addyosmani.com/blog/lazy-loading/">https://addyosmani.com/blog/lazy-loading/</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect">https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Lazy_loading">https://developer.mozilla.org/zh-CN/docs/Web/Performance/Lazy_loading</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> lazyloading </tag>
            
            <tag> 懒加载 </tag>
            
            <tag> 方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 defineAsyncComponent &amp; Suspense 用法以及源码</title>
      <link href="/2023/07/06/Vue3_Suspense/"/>
      <url>/2023/07/06/Vue3_Suspense/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-defineAsyncComponent-定义和使用"><a href="#01-defineAsyncComponent-定义和使用" class="headerlink" title="01. defineAsyncComponent 定义和使用"></a>01. defineAsyncComponent 定义和使用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineAsyncComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  source: AsyncComponentLoader | AsyncComponentOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AsyncComponentLoader</span> = <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">Component</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AsyncComponentOptions</span> &#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="title class_">AsyncComponentLoader</span></span><br><span class="line">  loadingComponent?: <span class="title class_">Component</span></span><br><span class="line">  errorComponent?: <span class="title class_">Component</span></span><br><span class="line">  delay?: <span class="built_in">number</span></span><br><span class="line">  timeout?: <span class="built_in">number</span></span><br><span class="line">  suspensible?: <span class="built_in">boolean</span></span><br><span class="line">  onError?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    error: <span class="built_in">Error</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    retry: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    fail: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    attempts: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个参数 <code>AsyncComponentLoader</code> or <code>AsyncComponentOptions</code></p><p>写了一个 type AsyncComponentLoader &#x3D; () &#x3D;&gt; Promise<Component> 参数的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">my-async-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-async-component</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title class_">MyAsyncComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 异步加载组件的逻辑</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="title function_">resolve</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;This is an async component!&lt;/div&gt;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;, <span class="number">2000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title class_">MyAsyncComponent</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>既然可以这样写，也可以这样写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyAsyncComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">import</span>(<span class="string">&#x27;../a.vue&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另一种就是写一个 <code>options</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line">    <span class="comment">// 使用 AsyncComponentOptions 配置对象</span></span><br><span class="line">    <span class="attr">loader</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;This is an async component!&lt;/div&gt;&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">delay</span>: <span class="number">200</span>, <span class="comment">// 可选项，加载延迟</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span>, <span class="comment">// 可选项，超时时间</span></span><br><span class="line">    <span class="attr">errorComponent</span>: <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 可选项，加载错误时显示的组件或标签</span></span><br><span class="line">    <span class="attr">timeoutComponent</span>: &#123; <span class="comment">// 可选项，加载超时时显示的组件或配置对象</span></span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Component loading timed out.&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">suspensible</span>: <span class="literal">true</span> <span class="comment">// 可选项，启用组件的暂停和恢复功能</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="02-源码"><a href="#02-源码" class="headerlink" title="02. 源码"></a>02. 源码</h3><p><strong>packages\runtime-core\src\apiAsyncComponent.ts</strong></p><p>这个代码看得比较纠结，简单说就是</p><ol><li>获取参数</li><li>定义一些局部变量用于跟踪异步加载状态，如 pendingRequest、resolvedComp 和 retries。</li><li>实现 load 函数，用于执行异步加载过程。它会调用 loader 函数，并处理加载过程中的错误和超时。加载成功后，将得到的组件进行处理，并返回 Promise 对象。</li><li>使用 defineComponent 定义一个包裹组件 (AsyncComponentWrapper)，并在 setup 钩子中处理异步加载的逻辑。</li><li>在 setup 钩子中，根据加载状态渲染不同的内容，包括已加载的组件、加载中的组件、错误组件等。</li><li>返回 AsyncComponentWrapper 作为最终的组件选项对象，并使用类型断言 as T 将其转换为泛型参数 T 所指定的类型。</li></ol><p>简单说就是这些，我更关注的，这些参数有什么用。</p><h3 id="03-delay"><a href="#03-delay" class="headerlink" title="03. delay"></a>03. delay</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delayed = <span class="title function_">ref</span>(!!delay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delay) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    delayed.<span class="property">value</span> = <span class="literal">false</span></span><br><span class="line">&#125;, delay)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loaded.<span class="property">value</span> &amp;&amp; resolvedComp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createInnerComp</span>(resolvedComp, instance)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">value</span> &amp;&amp; errorComponent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createVNode</span>(errorComponent, &#123;</span><br><span class="line">        <span class="attr">error</span>: error.<span class="property">value</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadingComponent &amp;&amp; !delayed.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createVNode</span>(loadingComponent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，知道这个 <code>delay</code> 有什么用了吧，他只和 <code>loadingComponent</code> 相关。</p><ol><li>判断是否load完成以及解析完成组件</li><li>判断错误信息和错误组件</li><li>loading组件和是否应该loading</li></ol><p>也就是说，<code>delay</code> 是出现 <code>loadingComponent</code> 组件出现的延迟时间</p><h3 id="04-timeout"><a href="#04-timeout" class="headerlink" title="04. timeout"></a>04. timeout</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loaded.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">            <span class="string">`Async component timed out after <span class="subst">$&#123;timeout&#125;</span>ms.`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="title function_">onError</span>(err)</span><br><span class="line">        error.<span class="property">value</span> = err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>timeout</code>稍显简陋，就是一个定时任务，并且无法中断 <code>promise</code>, 也就是 <code>load</code>.</p><p>但是，<code>error.value</code> 会触发 <code>render</code> 重新渲染，并且调用，所以会调用 <code>errorComponent</code></p><h3 id="04-suspensible"><a href="#04-suspensible" class="headerlink" title="04 suspensible"></a>04 suspensible</h3><p>是否开启了 <code>suspens</code>.</p><h3 id="05-defineAsyncComponent-总结"><a href="#05-defineAsyncComponent-总结" class="headerlink" title="05. defineAsyncComponent 总结"></a>05. defineAsyncComponent 总结</h3><p>这里基本就知道他是怎么用的了，以及 error，loading 组件加载的原理，以及 setTimeout &amp; delay &amp; suspensible 等参数作用是什么</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">(__FEATURE_SUSPENSE__ &amp;&amp; suspensible &amp;&amp; instance.<span class="property">suspense</span>) ||</span><br><span class="line">(__SSR__ &amp;&amp; isInSSRComponentSetup)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">load</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">comp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">createInnerComp</span>(comp, instance)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onError</span>(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">        errorComponent</span><br><span class="line">        ? <span class="title function_">createVNode</span>(errorComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>, &#123;</span><br><span class="line">            <span class="attr">error</span>: err</span><br><span class="line">            &#125;)</span><br><span class="line">        : <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-suspense"><a href="#06-suspense" class="headerlink" title="06. suspense"></a>06. suspense</h3><p>官方文档 <a href="https://cn.vuejs.org/guide/built-ins/suspense.html">Suspense</a>，其他的简单文档 <a href="https://medium.com/i-am-mike/vue-3-vue3-%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD-suspense-428e02254030">Vue3 的新功能 — Suspense</a></p><blockquote><p><Suspense> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p></blockquote><p>这个其实就说的很明确了，刚才说的 defineAsyncComponent 是针对单个组件，Suspense可以对于整个下面的组件都控制。</p><blockquote><p>Suspense 可以等待的异步依赖有两种：</p><ol><li>带有异步 setup() 钩子的组件。这也包含了使用 <script setup> 时有顶层 await 表达式的组件。</li><li>异步组件, definedAsyncComponent, suspensible = true</li></ol></blockquote><p>以及两个插槽和事件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span>&gt;</span><br><span class="line">  &lt;!-- 具有深层异步依赖的组件 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Loading...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure><p>default 插槽只能有一个组件，fallback 正在加载。</p><p>事件</p><blockquote><p><Suspense> 组件会触发三个事件：pending、resolve 和 fallback。pending 事件是在进入挂起状态时触发。resolve 事件是在 default 插槽完成获取新内容时触发。fallback 事件则是在 fallback 插槽的内容显示时触发。</p></blockquote><p>error</p><p>onErrorCaptured 在上层捕获</p><p>ok, 做一个简单测试</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///main</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">AsyncComponentOne</span> /&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineAsyncComponent, <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Loading</span> <span class="keyword">from</span> <span class="string">&#x27;./Loading.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title class_">AsyncComponentOne</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span>(<span class="string">&#x27;./OneAsyncComponent.vue&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///OneAsyncComponent</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">ThreeAsyncComponen</span> <span class="keyword">from</span> <span class="string">&#x27;./ThreeAsyncComponent.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> asyncLeft = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`./TwoAsyncComponent.vue`</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">asyncLeft</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThreeAsyncComponen</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.read-the-docs</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: <span class="number">#888</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///TwoAsyncComponent.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> dataMsg = <span class="title function_">ref</span>(<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">resolve</span>(<span class="string">&#x27;&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">5000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Two AsyncComponent &#123;&#123; dataMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.read-the-docs</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: <span class="number">#888</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///ThreeAsyncComponen.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> dataMsg = <span class="title function_">ref</span>(<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">resolve</span>(<span class="string">&#x27;&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">10000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Three AsyncComponent &#123;&#123; dataMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.read-the-docs</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: <span class="number">#888</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="07-Suspendse-如何实现的？"><a href="#07-Suspendse-如何实现的？" class="headerlink" title="07. Suspendse 如何实现的？"></a>07. Suspendse 如何实现的？</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suspense exposes a component-like API, and is treated like a component</span></span><br><span class="line"><span class="comment">// in the compiler, but internally it&#x27;s a special built-in type that hooks</span></span><br><span class="line"><span class="comment">// directly into the renderer.</span></span><br><span class="line"><span class="comment">// Suspense 公开了类似组件的 API，并被视为组件</span></span><br><span class="line"><span class="comment">// 在编译器中，但在内部它是一个特殊的内置类型，可以挂钩</span></span><br><span class="line"><span class="comment">// 直接进入渲染器。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseImpl</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Suspense&#x27;</span>,</span><br><span class="line">  <span class="comment">// In order to make Suspense tree-shakable, we need to avoid importing it</span></span><br><span class="line">  <span class="comment">// directly in the renderer. The renderer checks for the __isSuspense flag</span></span><br><span class="line">  <span class="comment">// on a vnode&#x27;s type and calls the `process` method, passing in renderer</span></span><br><span class="line">  <span class="comment">// internals.</span></span><br><span class="line">  <span class="comment">// 为了使 Suspense 树可摇动，我们需要避免导入它</span></span><br><span class="line">  <span class="comment">// 直接在渲染器中。 渲染器检查 __isSuspense 标志</span></span><br><span class="line">  <span class="comment">// 在 vnode 的类型上并调用 `process` 方法，传入渲染器</span></span><br><span class="line">  <span class="comment">// 内部结构。</span></span><br><span class="line">  <span class="attr">__isSuspense</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">process</span>(<span class="params"></span></span><br><span class="line"><span class="params">    n1: VNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    n2: VNode,</span></span><br><span class="line"><span class="params">    container: RendererElement,</span></span><br><span class="line"><span class="params">    anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    optimized: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="comment">// platform-specific impl passed from renderer</span></span></span><br><span class="line"><span class="params">    rendererInternals: RendererInternals</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">mountSuspense</span>(</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized,</span><br><span class="line">        rendererInternals</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patchSuspense</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized,</span><br><span class="line">        rendererInternals</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">hydrate</span>: hydrateSuspense,</span><br><span class="line">  <span class="attr">create</span>: createSuspenseBoundary,</span><br><span class="line">  <span class="attr">normalize</span>: normalizeSuspenseChildren</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 h 和 TSX props 推理的强制公共类型</span></span><br><span class="line"><span class="comment">// Force-casted public typing for h and TSX props inference</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Suspense</span> = (__FEATURE_SUSPENSE__</span><br><span class="line">  ? <span class="title class_">SuspenseImpl</span></span><br><span class="line">  : <span class="literal">null</span>) <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> &#123;</span><br><span class="line">  <span class="attr">__isSuspense</span>: <span class="literal">true</span></span><br><span class="line">  <span class="keyword">new</span> (): &#123;</span><br><span class="line">    <span class="attr">$props</span>: <span class="title class_">VNodeProps</span> &amp; <span class="title class_">SuspenseProps</span></span><br><span class="line">    <span class="attr">$slots</span>: &#123;</span><br><span class="line">      <span class="title function_">default</span>(): <span class="title class_">VNode</span>[]</span><br><span class="line">      <span class="title function_">fallback</span>(): <span class="title class_">VNode</span>[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码注释里面说</p><blockquote><p> 直接在渲染器中。 渲染器检查 __isSuspense 标志<br> 在 vnode 的类型上并调用 <code>process</code> 方法，传入渲染器</p></blockquote><p>但是这里明明是一个 Object, 没有检查，于是我又查了 process 的引用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">    ;(<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">SuspenseImpl</span>).<span class="title function_">process</span>(</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds,</span><br><span class="line">    optimized,</span><br><span class="line">    internals</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FEATURE_SUSPENSE</strong> 是指的是开启 suspense 功能.</p><p><strong>mountSuspense</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountSuspense</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vnode: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  rendererInternals: RendererInternals</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">p</span>: patch,</span><br><span class="line">    <span class="attr">o</span>: &#123; createElement &#125;</span><br><span class="line">  &#125; = rendererInternals</span><br><span class="line">  <span class="keyword">const</span> hiddenContainer = <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个可以说是核心创建方法, 返回一个 suspense，后面操作的核心</span></span><br><span class="line">  <span class="keyword">const</span> suspense = (vnode.<span class="property">suspense</span> = <span class="title function_">createSuspenseBoundary</span>(</span><br><span class="line">    vnode,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    parentComponent,</span><br><span class="line">    container,</span><br><span class="line">    hiddenContainer,</span><br><span class="line">    anchor,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds,</span><br><span class="line">    optimized,</span><br><span class="line">    rendererInternals</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始在 off-dom 容器中挂载内容子树</span></span><br><span class="line">  <span class="comment">// start mounting the content subtree in an off-dom container</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    (suspense.<span class="property">pendingBranch</span> = vnode.<span class="property">ssContent</span>!),</span><br><span class="line">    hiddenContainer,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    parentComponent,</span><br><span class="line">    suspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 现在检查我们是否遇到了任何异步依赖</span></span><br><span class="line">  <span class="comment">// now check if we have encountered any async deps</span></span><br><span class="line">  <span class="keyword">if</span> (suspense.<span class="property">deps</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// has async</span></span><br><span class="line">    <span class="comment">// invoke @fallback event</span></span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onPending&#x27;</span>)</span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onFallback&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mount the fallback tree</span></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      vnode.<span class="property">ssFallback</span>!,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds</span><br><span class="line">    )</span><br><span class="line">    <span class="title function_">setActiveBranch</span>(suspense, vnode.<span class="property">ssFallback</span>!)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Suspense has no async deps. Just resolve.</span></span><br><span class="line">    suspense.<span class="title function_">resolve</span>(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createSuspenseBoundary</code></p><blockquote><p>创建 suspense 对象，该对象包含了 <Suspense> 组件的各种属性和方法。<br>resolve 方法用于处理异步组件加载完成后的操作。它会根据加载状态和配置来移动或渲染组件内容，并触发相关的事件和效果。<br>fallback 方法用于处理异步组件加载过程中的回退（fallback）操作。它会根据配置来渲染回退内容，并触发相关的事件。<br>move 方法用于移动异步组件的位置。<br>next 方法用于获取当前活跃分支的下一个节点。<br>registerDep 方法用于注册异步组件的依赖。当异步组件的依赖完成加载时，会触发相应的回调处理。<br>unmount 方法用于卸载 <Suspense> 组件边界及其相关的组件。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line"><span class="comment">// before proceeding</span></span><br><span class="line"><span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.<span class="property">asyncDep</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里其实就是 asyncDep，处理 catch + then, 处理参数 setupRenderEffect(asyncResult) 处理钩子</span></span><br><span class="line">    parentSuspense &amp;&amp; parentSuspense.<span class="title function_">registerDep</span>(instance, setupRenderEffect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give it a placeholder if this is not hydration</span></span><br><span class="line">    <span class="comment">// TODO handle self-defined fallback</span></span><br><span class="line">    <span class="keyword">if</span> (!initialVNode.<span class="property">el</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> placeholder = (instance.<span class="property">subTree</span> = <span class="title function_">createVNode</span>(<span class="title class_">Comment</span>))</span><br><span class="line">        <span class="title function_">processCommentNode</span>(<span class="literal">null</span>, placeholder, container!, anchor)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遇到异步任务不会立刻执行，而是增加 <code>Dep++</code>, 然后预留位置</p><p>会在卸载或者解析完成以后 <code>--</code></p><p>所以这里的 dep 出处在这里</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">registerDep</span>(<span class="params">instance, setupRenderEffect</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isInPendingSuspense = !!suspense.<span class="property">pendingBranch</span></span><br><span class="line">    <span class="keyword">if</span> (isInPendingSuspense) &#123;</span><br><span class="line">    suspense.<span class="property">deps</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hydratedEl = instance.<span class="property">vnode</span>.<span class="property">el</span></span><br><span class="line">    instance</span><br><span class="line">    .<span class="property">asyncDep</span>!.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(err, instance, <span class="title class_">ErrorCodes</span>.<span class="property">SETUP_FUNCTION</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">asyncSetupResult</span> =&gt;</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>事件在 <code>handleError</code>, 触发 <code>onErrorCaptured</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now check if we have encountered any async deps</span></span><br><span class="line"><span class="keyword">if</span> (suspense.<span class="property">deps</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// has async</span></span><br><span class="line">  <span class="comment">// invoke @fallback event</span></span><br><span class="line">  <span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onPending&#x27;</span>)</span><br><span class="line">  <span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onFallback&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mount the fallback tree</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    vnode.<span class="property">ssFallback</span>!,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds</span><br><span class="line">  )</span><br><span class="line">  <span class="title function_">setActiveBranch</span>(suspense, vnode.<span class="property">ssFallback</span>!)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Suspense has no async deps. Just resolve.</span></span><br><span class="line">  suspense.<span class="title function_">resolve</span>(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有异步任务，挂载 <code>fallback</code>，也就是 <code>loading</code> 之类的, <code>setActiveBranch</code> 是把 <code>vnode.ssFallback</code> 设置为当前的, 然后触发生命周期</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onPending&#x27;</span>)</span><br><span class="line"><span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onFallback&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果没有，直接完成。<code>suspense.resolve(false, true)</code>, 也就保证他在所有异步完全执行完成以后执行。</p><p>一旦 <code>asyncDep</code> 执行，就会 -1， 然后 <code>resolve</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resolve</span>(<span class="params">resume = <span class="literal">false</span>, sync = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!resume &amp;&amp; !suspense.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">            <span class="string">`suspense.resolve() is called without a pending branch.`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suspense.<span class="property">isUnmounted</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">            <span class="string">`suspense.resolve() is called on an already unmounted suspense boundary.`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        vnode,</span><br><span class="line">        activeBranch,</span><br><span class="line">        pendingBranch,</span><br><span class="line">        pendingId,</span><br><span class="line">        effects,</span><br><span class="line">        parentComponent,</span><br><span class="line">        container</span><br><span class="line">    &#125; = suspense</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suspense.<span class="property">isHydrating</span>) &#123;</span><br><span class="line">        suspense.<span class="property">isHydrating</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!resume) &#123;</span><br><span class="line">        <span class="keyword">const</span> delayEnter =</span><br><span class="line">            activeBranch &amp;&amp;</span><br><span class="line">            pendingBranch!.<span class="property">transition</span> &amp;&amp;</span><br><span class="line">            pendingBranch!.<span class="property">transition</span>.<span class="property">mode</span> === <span class="string">&#x27;out-in&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (delayEnter) &#123;</span><br><span class="line">        activeBranch!.<span class="property">transition</span>!.<span class="property">afterLeave</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pendingId === suspense.<span class="property">pendingId</span>) &#123;</span><br><span class="line">                <span class="title function_">move</span>(pendingBranch!, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this is initial anchor on mount</span></span><br><span class="line">    <span class="keyword">let</span> &#123; anchor &#125; = suspense</span><br><span class="line">    <span class="comment">// unmount current active tree</span></span><br><span class="line">    <span class="keyword">if</span> (activeBranch) &#123;</span><br><span class="line">        <span class="comment">// if the fallback tree was mounted, it may have been moved</span></span><br><span class="line">        <span class="comment">// as part of a parent suspense. get the latest anchor for insertion</span></span><br><span class="line">        anchor = <span class="title function_">next</span>(activeBranch)</span><br><span class="line">        <span class="title function_">unmount</span>(activeBranch, parentComponent, suspense, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!delayEnter) &#123;</span><br><span class="line">        <span class="comment">// move content from off-dom container to actual container</span></span><br><span class="line">        <span class="title function_">move</span>(pendingBranch!, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setActiveBranch</span>(suspense, pendingBranch!)</span><br><span class="line">    suspense.<span class="property">pendingBranch</span> = <span class="literal">null</span></span><br><span class="line">    suspense.<span class="property">isInFallback</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush buffered effects</span></span><br><span class="line">    <span class="comment">// check if there is a pending parent suspense</span></span><br><span class="line">    <span class="keyword">let</span> parent = suspense.<span class="property">parent</span></span><br><span class="line">    <span class="keyword">let</span> hasUnresolvedAncestor = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">        <span class="comment">// found a pending parent suspense, merge buffered post jobs</span></span><br><span class="line">        <span class="comment">// into that parent</span></span><br><span class="line">        parent.<span class="property">effects</span>.<span class="title function_">push</span>(...effects)</span><br><span class="line">        hasUnresolvedAncestor = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent.<span class="property">parent</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no pending parent suspense, flush all jobs</span></span><br><span class="line">    <span class="keyword">if</span> (!hasUnresolvedAncestor) &#123;</span><br><span class="line">    <span class="title function_">queuePostFlushCb</span>(effects)</span><br><span class="line">    &#125;</span><br><span class="line">    suspense.<span class="property">effects</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve parent suspense if all async deps are resolved</span></span><br><span class="line">    <span class="keyword">if</span> (isSuspensible) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        parentSuspense &amp;&amp;</span><br><span class="line">        parentSuspense.<span class="property">pendingBranch</span> &amp;&amp;</span><br><span class="line">        parentSuspenseId === parentSuspense.<span class="property">pendingId</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        parentSuspense.<span class="property">deps</span>--</span><br><span class="line">        <span class="keyword">if</span> (parentSuspense.<span class="property">deps</span> === <span class="number">0</span> &amp;&amp; !sync) &#123;</span><br><span class="line">        parentSuspense.<span class="title function_">resolve</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke @resolve event</span></span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onResolve&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>就是全部创建流程，更新 activeBranch 为 default， 挂载 default， 删除 Fallback, 修改属性为默认值，处理嵌套, 然后触发，</p><h3 id="08-总结"><a href="#08-总结" class="headerlink" title="08. 总结"></a>08. 总结</h3><p>ok, 简单说就是 defineAsyncCom.. 单个， suspense 多个同时处理。</p><p>suspense，有 defalut 和 fallback 两个插槽，可以提供3个钩子，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onPending&#x27;</span>)</span><br><span class="line"><span class="title function_">triggerEvent</span>(vnode, <span class="string">&#x27;onFallback&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在进行异步之前触发，两个钩子可以说同时触发， <code>triggerEvent(vnode, &#39;onResolve&#39;)</code> 在完成以后触发。</p><p>defineAsyncComponent 可以单个进行异步，他就是 definedComponent 封装.</p><ul><li><a href="https://cn.vuejs.org/api/general.html#defineasynccomponent">defineasynccomponent</a></li><li><a href="https://cn.vuejs.org/guide/components/async.html">异步组件</a></li><li><a href="https://cn.vuejs.org/guide/built-ins/suspense.html">Suspense</a></li><li><a href="https://medium.com/i-am-mike/vue-3-vue3-%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD-suspense-428e02254030">Vue3 的新功能 — Suspense</a></li><li><a href="https://juejin.cn/post/7044880716793905183#heading-9">Vue3 新特性 Teleport Suspense实现原理</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
            <tag> defineAsyncComponent </tag>
            
            <tag> Suspense </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>type 和 interface 区别</title>
      <link href="/2023/07/03/ts_type_interface/"/>
      <url>/2023/07/03/ts_type_interface/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><p>interface 可以通过 implements 实现继承，然而 type 理论上不能继承。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>;</span><br><span class="line">    <span class="attr">sex</span>: <span class="title class_">Number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="attr">to</span>: <span class="built_in">number</span>): <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>, <span class="title class_">Speak</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><code>class</code> 就可以继承 <code>interface</code> 取实现方法.</p><p>type 想要继承，可以通过交叉类型可以实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal1</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>;</span><br><span class="line">    <span class="attr">sex</span>: <span class="title class_">Number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Speak1</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="attr">to</span>: <span class="built_in">number</span>): <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person1</span> = <span class="title class_">Animal1</span> &amp; <span class="title class_">Speak1</span>;</span><br></pre></td></tr></table></figure><p>也可以实现相同效果</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a>2. 合并</h3><p>如果两个同名的 interface 可以直接合并，如果遇见重名的属性，以后面的为准，type 不行，只会报错。</p><p>type 不行，他不能实现这种操作。</p><h3 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h3><p>接口和类型都可以实现泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="title function_">getInfo</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Box1</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="title function_">getInfo</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-联合类型，交叉类型"><a href="#4-联合类型，交叉类型" class="headerlink" title="4. 联合类型，交叉类型"></a>4. 联合类型，交叉类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myVar</span>: <span class="title class_">MyType</span>;</span><br><span class="line">myVar = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 类型为 string</span></span><br><span class="line">myVar = <span class="number">123</span>; <span class="comment">// 类型为 number</span></span><br></pre></td></tr></table></figure><p>联合类型就是都可以使用，不过 interface 也可以</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IMyType</span> &#123;</span><br><span class="line">    <span class="attr">myType</span>:  <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交叉类型也一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = &#123;</span><br><span class="line">  <span class="attr">company</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">position</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmployeeWithPerson</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: <span class="title class_">EmployeeWithPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">company</span>: <span class="string">&quot;ABC Inc.&quot;</span>,</span><br><span class="line">  <span class="attr">position</span>: <span class="string">&quot;Manager&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IEmployeeWithPerson</span> &#123;</span><br><span class="line">    <span class="attr">company</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">position</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: <span class="title class_">IEmployeeWithPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">company</span>: <span class="string">&quot;ABC Inc.&quot;</span>,</span><br><span class="line">  <span class="attr">position</span>: <span class="string">&quot;Manager&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果类似，但是明显 type 更灵活，可以随意组装，任意加载。</p><h3 id="5-定义数组顺序"><a href="#5-定义数组顺序" class="headerlink" title="5. 定义数组顺序"></a>5. 定义数组顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> a &#123; <span class="title function_">a</span>(); &#125;</span><br><span class="line"><span class="keyword">interface</span> b &#123; <span class="title function_">b</span>(); &#125;</span><br><span class="line"><span class="keyword">type</span> list = [a, b];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> c &#123;</span><br><span class="line">    <span class="attr">c</span>: [a, b]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-typeof"><a href="#6-typeof" class="headerlink" title="6. typeof"></a>6. typeof</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;testA&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> d = <span class="keyword">typeof</span> element; <span class="comment">//htmlElement || null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> d1 &#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="keyword">typeof</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>其实主要区别在于继承上，还有接口合并上。</p><p>理论上 type 能够实现的 interface 都可以实现，差别只是在于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> a &#123;</span><br><span class="line">    <span class="attr">b</span>: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> b = ...</span><br></pre></td></tr></table></figure><p>从继承上来说，一个是 extends implements 继承，一个是通过联合类型，交叉类型实现，方法不一样，但是可以实现相同效果。</p><p>interface 可以使用合并， type 其实也可以使用交叉类型来解决问题。</p><p>其实最大的区别在于，interface 需要外面包一个壳子，也就是初始一个对象，但是 type 可以作为一个单独的类型存在, 也就是类型。</p><p>期间，不管是使用 字符串字面量类型模板，还是映射类型，还是 typof，条件类型 等等方式，虽然不能直接对 interface 使用，但是可以对 interface 下面的属性使用。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> type </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript 基础点</title>
      <link href="/2023/07/03/ts_baseTypescript/"/>
      <url>/2023/07/03/ts_baseTypescript/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h2 id="01-类型"><a href="#01-类型" class="headerlink" title="01. 类型"></a>01. 类型</h2><p>Number, Tuple, String, Enum, Any, Void, Null, Undefined, Never, Object, Boolean, Symbol</p><p>需要说一说的只是 Tuple, Never, Void</p><p><strong>Tuple</strong></p><blockquote><p>Tuple 元组类型允许表示一个已知元素数量和类型的数组<br>当访问一个越界的元素，会使用联合类型替代</p></blockquote><p>let x:[string, number] &#x3D; [“1”, 1];</p><p>x[3] &#x3D; “1”; &#x2F;&#x2F;联合类型替 [String | Number]</p><p><strong>Never &amp; Void</strong></p><p>Never 表示没有任何返回值<br>Void Null || undefined</p><h2 id="02-变量声明"><a href="#02-变量声明" class="headerlink" title="02. 变量声明"></a>02. 变量声明</h2><p>const let var 作用域和ES6相同，别用var就行了。<br>readonly const 一个是修饰符，一个声明变量<br>readonly 主要用于接口，类，并且可以不用在声明的时候初始化，第一次赋值后不能再赋值<br>const 必须初始化的时候赋值。</p><h2 id="03-interface"><a href="#03-interface" class="headerlink" title="03. interface"></a>03. interface</h2><p>和 C# java 差不多，用于类定义，Object定义。<br>需要注意 implements和extends 差别</p><p>implements 接口<br>extends 类，抽象类</p><p>从语义上也可以区分，可以混合继承</p><ol><li>只读属性 readonly 属性</li><li>可选属性 ?</li><li>索引签名 [index: string]: { message: string }; 可以直接在变量声明,也可以之间诶接在变量后面</li><li>函数属性 (param1: type, param2: type): boolean</li><li>类类型</li><li>多继承</li></ol><h2 id="04-class"><a href="#04-class" class="headerlink" title="04. class"></a>04. class</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class a &#123;</span><br><span class="line">constructor() &#123;&#125;</span><br><span class="line">private func() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰符</p><ol><li>public 共有</li><li>protected 内部访问</li><li>readonly 属性只读</li><li>private 私有</li><li>getters&#x2F;setters 读取器</li><li>static 静态属性，静态类</li><li>abstract 抽象类</li></ol><p>没有什么特别需要注意的，如果你有后端语言经验的话，基本一致。</p><p>非的说一下就是 static 使用。<br>，</p><blockquote><p>在内存级别，将为静态字段创建一部分内存，这些字段将在类中的所有对象之间共享。</p></blockquote><p>为什么要使用？<br>关键在于状态，不建议在 static 当中保存状态，可能会比较麻烦，更多的用处在于在降低耦合，创建无副作用代码。<br>比如说数据获取，比如可以提取出的公共操作，返回公共状态，总之就是有抽象价值，对于全局有作用的函数或者属性。</p><h2 id="05-Function"><a href="#05-Function" class="headerlink" title="05. Function"></a>05. Function</h2><p>基本差不多，默认值，解构，<code>...a: string[]</code>. 需要注意的是重载问题，支持重载不需要再使用 <code>typeof</code>.</p><h2 id="06-泛型"><a href="#06-泛型" class="headerlink" title="06. 泛型"></a>06. 泛型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function 也可以使用泛型，总之是在抽象同一类型的对象的时候，节约代码用的。</p><p>比如都是手机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class phoneAbs &#123;</span><br><span class="line">call() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract sms(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class class oldPhone&lt;T: IOldPhone&gt; extends phoneAbs &#123;</span><br><span class="line">sms(number) &#123; T.sendSMS(number) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T也可以 extends，不过记住这里是约束</p><h2 id="07-类型推断"><a href="#07-类型推断" class="headerlink" title="07. 类型推断"></a>07. 类型推断</h2><p>简单变量使用ok，因为上下文问题，复杂情况可能推断不出，比如自定义类型</p><h2 id="08-高级类型"><a href="#08-高级类型" class="headerlink" title="08. 高级类型"></a>08. 高级类型</h2><p>交叉类型（Intersection Types）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Ant &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fly &#123;</span><br><span class="line">    flyHeight: number;</span><br><span class="line">    speed: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 少了任何一个属性都会报错</span><br><span class="line">const flyAnt: Ant &amp; Fly = &#123;</span><br><span class="line">    name: &#x27;蚂蚁呀嘿&#x27;,</span><br><span class="line">    weight: 0.2,</span><br><span class="line">    flyHeight: 20,</span><br><span class="line">    speed: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>联合类型（Union Types）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a: string | number;</span><br></pre></td></tr></table></figure><p>任意一个都ok, 但是联合类型会产生一个问题，无法推断出 a 究竟是 String or Number</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getSmallPet();</span><br><span class="line">pet.layEggs(); // okay</span><br><span class="line">pet.swim();  </span><br></pre></td></tr></table></figure><p>无法推导出究竟是 <code>Fish</code> 还是 <code>Bird</code>, 所以需要判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let pet = getSmallPet();</span><br><span class="line">if(&lt;Fish&gt;pet.swim) ...</span><br><span class="line">else &lt;Bird&gt;pet.layEggs();</span><br></pre></td></tr></table></figure><p>这个时候需要判断类型.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;Fish&gt;pet.swim) ... //可以直接判断</span><br><span class="line"></span><br><span class="line">if(pet instanceof Fish) ... </span><br><span class="line"></span><br><span class="line">function isFish(target): target is Fish  &#123;</span><br><span class="line">//判断</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过泛型确定方法</span><br><span class="line">function isOfType&lt;T&gt;(</span><br><span class="line">  target: unknown,</span><br><span class="line">  prop: keyof T</span><br><span class="line">): target is T &#123;</span><br><span class="line">  return (target as T)[prop] !== undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以进行判断</p><h2 id="09-type-类型别名"><a href="#09-type-类型别名" class="headerlink" title="09. type 类型别名"></a>09. type 类型别名</h2><p>类型别名有点类似于 <code>interface</code></p><blockquote><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type name = string;</span><br><span class="line">function getName(): name &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>name</code> 就是 <code>string</code>, 还可以使用一些莫名其妙的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type user&lt;T&gt; = &#123;</span><br><span class="line">name: string;</span><br><span class="line">sex: enmu;</span><br><span class="line">age: number;</span><br><span class="line">m: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type user&lt;T&gt; = T &amp; string;</span><br><span class="line">type user&lt;T&gt; = T &amp; &#123; name: string, sex: emum &#125;</span><br></pre></td></tr></table></figure><p>看起来都和接口很像,使用方式也很像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type name = string;</span><br><span class="line">let haha: name;</span><br><span class="line">function b(user: name): name &#123; return &quot;&quot; &#125;</span><br></pre></td></tr></table></figure><p>那么 type 究竟可以做什么.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Container&lt;T&gt; = &#123; value: T &#125;; //范型</span><br><span class="line">type TreeNode&lt;T&gt; = &#123;</span><br><span class="line">left: TreeNode&lt;T&gt;;</span><br><span class="line">right: TreeNode&lt;T&gt;</span><br><span class="line">&#125; //自己调用自己</span><br><span class="line">type 使用高级类型, &amp; or | , 就可以实现联合继承.</span><br><span class="line">type a = (x: number, y: number) =&gt; number</span><br><span class="line">type b = &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;</span><br></pre></td></tr></table></figure><p>区别</p><p>1.type 可以声明基本类型别名，联合类型，元组等类型, 但是 interface 其实也可以,只是不能像 type 那样声明一个变量.<br>2. type 可以用 typeof 获取实例<br>3. interface可以合并声明, 两个 interface User 就自己合并了<br>4. 而且从语义上来说，interface 应该更加偏功能性，type 更加偏类型</p><h2 id="10-keyof-泛型方法"><a href="#10-keyof-泛型方法" class="headerlink" title="10. keyof 泛型方法"></a>10. keyof 泛型方法</h2><h2 id="11-类型索引"><a href="#11-类型索引" class="headerlink" title="11. 类型索引"></a>11. 类型索引</h2><h2 id="12-函数属性"><a href="#12-函数属性" class="headerlink" title="12. 函数属性"></a>12. 函数属性</h2><h2 id="13-Symbol"><a href="#13-Symbol" class="headerlink" title="13. Symbol"></a>13. Symbol</h2><p>和 javascript symbol 没区别</p><h2 id="14-模块"><a href="#14-模块" class="headerlink" title="14. 模块"></a>14. 模块</h2><p>太多细节了，这个需要专门写一篇。</p><h2 id="15-命名空间"><a href="#15-命名空间" class="headerlink" title="15. 命名空间"></a>15. 命名空间</h2><p>其实就是整合一个类型的类或者类型统一在一个命名空间下，有点类似之前 C# part，可以在多个不同的文件下。</p><h2 id="16-声明合并"><a href="#16-声明合并" class="headerlink" title="16. 声明合并"></a>16. 声明合并</h2><p>Namespace, Class, Enum, Interface, type Alias, Function, Variable<br>要合并必须要知道他的怎么生成的，所以简单写一下，tsc 编译一下就ok了。<br>最经典的是 Namespace</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var user;</span><br><span class="line">(function() &#123; ... &#125;)(user || (user = &#123;&#125;))</span><br></pre></td></tr></table></figure><p>那么他的合并就比较好说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let LogName = &quot;test&quot;;</span><br><span class="line">namespace logName &#123;</span><br><span class="line">export const name = &quot;Namespace name&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(logName)</span><br><span class="line"></span><br><span class="line">var LogName = &quot;test&quot;;</span><br><span class="line">var logName;</span><br><span class="line">(function (logName) &#123;</span><br><span class="line">    logName.name = &quot;Namespace name&quot;;</span><br><span class="line">&#125;)(logName || (logName = &#123;&#125;));</span><br><span class="line">console.log(logName);</span><br></pre></td></tr></table></figure><p>那么他的先后顺序也会对编译产生影响.<br>这种合并最好还是独立起名，只是相同的声明，比如 namespace 再采取合并的方式。</p><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><a href="https://typescript.bootcss.com/basic-types.html">https://typescript.bootcss.com/basic-types.html</a><br><a href="https://www.jianshu.com/p/57df3cb66d3d">https://www.jianshu.com/p/57df3cb66d3d</a><br><a href="https://zhuanlan.zhihu.com/p/365973520">https://zhuanlan.zhihu.com/p/365973520</a><br><a href="https://zhuanlan.zhihu.com/p/568705587">https://zhuanlan.zhihu.com/p/568705587</a><br><a href="https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html">https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2023/07/03/ts_Generics/"/>
      <url>/2023/07/03/ts_Generics/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>官网这一章从最开始的泛型基本语法讲起，然后通过 keyof， typeof，ReturonType 等方式来类型，更方便的创建类型，只是后面玩的太花了，我确实想不到这么多玩法有什么应用类型，可能后续 typescript 用的多了以后再来复习吧。</p><h3 id="01-Generics-泛型"><a href="#01-Generics-泛型" class="headerlink" title="01. Generics 泛型"></a>01. Generics 泛型</h3><p>泛型最基础的就是 function or class 的形变，主要用于相同逻辑，相同的接口的抽象。</p><hr><blockquote><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p></blockquote><p>语法很简单，就是增加一个任意类型的 <code>T</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function log&lt;T&gt;(arg:T) ****:T &#123; return arg &#125;</span><br><span class="line">class log&lt;T extends Ilogs&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入一个泛型，在声明的时候可以传入对应想要的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log&lt;string&gt;(&quot;&quot;);</span><br><span class="line">new log&lt;testLog&gt;();</span><br></pre></td></tr></table></figure><p>这个字是什么不重要，主要是表达这个泛型的意思</p><ol><li>T &#x3D; Type</li><li>K &#x3D; Key</li><li>V &#x3D; Value</li><li>E &#x3D; Element</li></ol><p>理论上你用 <code>B</code> 也可以，重要的是他的意义，你需要传递什么，用什么为基础来重用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function log&lt;T&gt;(arg: T):T &#123; return arg &#125;;</span><br></pre></td></tr></table></figure><p>他的核心就在于传递类型，以及你需要 <code>function</code> 里面写什么代码进行复用。</p><p>这就是最基础的语法，后续可以有很多变种，这种是最基础的用法</p><p>interface, type 都可以使用泛型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type a&lt;T&gt; = T &amp; string;</span><br><span class="line">interface ITree&lt;T&gt; &#123;</span><br><span class="line">    value: Object</span><br><span class="line">    parent:T</span><br><span class="line">    child: T[]</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>那么就可以和泛型类进行联动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class tree&lt;T&gt; extends ITree&lt;T&gt; &#123;</span><br><span class="line">    root: T;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">    create: function(tree: T[]) &#123;</span><br><span class="line">        /...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>创建一个跟树相关的泛型类，<code>ITree</code> 就可以一个基础泛型树型接口。</p><h3 id="02-约束"><a href="#02-约束" class="headerlink" title="02. 约束"></a>02. 约束</h3><p>从开头到现在，泛型是一个任意类型，自然可以增加约束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function A&lt;T extends ITree&gt;(arg: T): void &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 extends 你其实可以理解为一种继承，但是只能引用继承到的接口或者类型，换一种说法就是一种约束。</p><p>好处就是，可以从任意类型到指定一个范围，比如刚才约束为 <code>ITree</code> 的例子，就可以确定 <code>arg</code> 类型一定包含 <code>ITree</code> 的接口，于是可以调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function A&lt;T extends string&gt;(arg: T) &#123;</span><br><span class="line">    return arg.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03-keyof"><a href="#03-keyof" class="headerlink" title="03. keyof"></a>03. keyof</h3><p>其实上代码最好理解这个东西的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    sex: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof User;</span><br></pre></td></tr></table></figure><p>这个 <code>keyof User</code> 其实相当于 <code>type K1 = name | age | sex</code>, 并且值是 <code>key</code> 的值。</p><p>他有什么用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let user: User = &#123; ... &#125;;</span><br><span class="line">function getUserItem&lt;T extends keyof User&gt;(arg: T) &#123;</span><br><span class="line">    return user[arg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserItem(arg) &#123;</span><br><span class="line">    if(arg === &quot;name&quot; || arg === &quot;age&quot; || arg === &quot;sex&quot;) return user[arg];</span><br><span class="line">    else return ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个就是差别。</p><h3 id="04-typeof-amp-ReturnType"><a href="#04-typeof-amp-ReturnType" class="headerlink" title="04. typeof &amp; ReturnType"></a>04. typeof &amp; ReturnType</h3><p>一般来说 <code>typeof</code> 就是返回原始类型的, 但是在 typescript 里有不一样的用处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let O = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">&#125;;</span><br><span class="line">type A3 = typeof O; // &#123; a:1, b:2, c:3 &#125;</span><br><span class="line">type A4 = typeof O[&quot;a&quot;]; //string</span><br></pre></td></tr></table></figure><p>可以看到，如果是基础类型，直接返回。</p><p>如果是复杂类型，直接返回类型本身</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;tommy&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;99&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="keyword">typeof</span> F;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="keyword">typeof</span> <span class="variable constant_">F1</span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play#code/GYVwdgxgLglg9mABAMQBQEoBcBnKAnGMAc0QG8AoRKxPAUyhDyQCJmBucgX3PNElgQoAjBjKVqdBkzHVZiMAEMAtrUyJmUOEqUBPZgBpxcxAqKr1ATgvMjibt3JQdAB1qIAKgGZEAXkRPXOGAUDgC3dwAWX38XWiDhNiA">Playground Link</a></p><p>那么如果需要获取返回值的类型如何解决？</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;tommy&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;99&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> F&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="variable constant_">F1</span>&gt;;</span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play?ssl=13&ssc=33&pln=12&pc=32#code/GYVwdgxgLglg9mABAMQBQEoBcBnKAnGMAc0QG8AoRKxPAUyhDyQCJmBucgX3PNElgQoAjBjKVqdBkzHVZiMAEMAtrUyJmUOEqUBPZgBpxcxAqKr1ATgvMjibjyg6ADrUQAVAKyIAvIgBK9Ixgbs60ADyOLnDAKAB8HJGubgBsPv6BTCEuEaHRwvFAA">Playground Link</a></p><h3 id="05-Indexed-Access-Types-索引访问类型"><a href="#05-Indexed-Access-Types-索引访问类型" class="headerlink" title="05. Indexed Access Types 索引访问类型"></a>05. Indexed Access Types 索引访问类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ttype <span class="title class_">Person</span> = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">alive</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---cut---</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AliveOrName</span> = <span class="string">&quot;alive&quot;</span> | <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I3</span> = <span class="title class_">Person</span>[<span class="title class_">AliveOrName</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>][<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age2</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br><span class="line"><span class="comment">//   ^?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6Afjn3zUALQuAxuWAunC8NACSAIzqcEhoega6UAA+ULqoTIYmco7Wdj5KfgBMwZphANYQIMgAZhqhqEkpULb2itDKAsIA8vAAcgnq+o2G0bHxzLrydVB+AMw55doNQhAt7cyVFqn2rmhsUACyIMrw8Hgg6tpylrj9LLrTroYANPhEpAEArFDS18c4jMykugBCyNS6W4GUiZcavd6nBLfACiwkBdxYowAHC83kl0tAQlp1HUSpttrt9toKDQEItLNU7MNVNAsLjSlsdnsQMSqLR4EZwkRjGYlpTkhYWhiVERslgsWF9NzycthQUDlgpYYhr4RbSylptPKZZSgA">Playground Link</a></p><p>根据索引访问 <code>type</code></p><h3 id="06-条件类型"><a href="#06-条件类型" class="headerlink" title="06. 条件类型"></a>06. 条件类型</h3><p>有意思的 <code>extends</code> 用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class a extends b &#123; &#125;</span><br><span class="line">class a&lt;T extends b&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>然而这里却是一个判断</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChlkdgA3CACgEoAuZcge2ABMBuQgX0NElkQoAIkwDmyCAA9IIVgGc0GbHiIkA7kyYxaDZm049CYAJ4AHFAFFJcTKZwQAjMgC8yEeKkz5irLmQB+ZBAAV0wAI2hkBjkwKFBRTgB6RJJkAD1-QiMzS2tbewAmF2QAJQhRK1MJaQhZBXRfPECQ8Mjo2PiklJIMoA">Playground Link</a></p><p>判断继承自哪里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeType extends OtherType ? TrueType : FalseType;</span><br></pre></td></tr></table></figure><h3 id="07-Mapped-Types-映射类型"><a href="#07-Mapped-Types-映射类型" class="headerlink" title="07. Mapped Types 映射类型"></a>07. Mapped Types 映射类型</h3><p>这里又引入和很多概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type OptionsFlags&lt;Type&gt; = &#123;</span><br><span class="line">  [Property in keyof Type]: boolean;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Property</code> 是属性，这里写做 <code>Property</code>, 使用 ABCDEFG，或者其他单词都可以。</p><p><code>in</code> 表示 <code>Property</code> 在 <code>keyof Type</code> 里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type FeatureFlags = &#123;</span><br><span class="line">  darkMode: () =&gt; void;</span><br><span class="line">  newUserProfile: () =&gt; void;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">type FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;</span><br></pre></td></tr></table></figure><p>那么根据官方的例子，<code>[Property in keyof FeatureFlags]</code>, 也就是说 <code>FeatureFlags = darkMode | newUserProfile</code></p><p>这就是映射，将 <code>FeatureFlags</code> 映射到一个新类型。</p><p><strong>映射修饰符</strong></p><blockquote><p>可以通过以 或 为前缀来删除或添加这些修饰符。如果您不添加前缀，则假定。-++</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable1</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: P;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LockedAccount</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T10</span> = <span class="title class_">CreateMutable1</span>&lt;<span class="title class_">LockedAccount</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T11</span> = <span class="title class_">CreateMutable</span>&lt;<span class="title class_">LockedAccount</span>&gt;;</span><br></pre></td></tr></table></figure><p>这样 <code>+-</code> 会导致不一样的结果。</p><p><code>T11</code> 会取消所有的 <code>readonly</code></p><p><code>T10</code> 所有都会增加 <code>readonly</code></p><p>作用于修饰符，那么所有修饰符都会受到这个符号限制</p><p><a href="https://juejin.cn/post/7031450398959337486">TypeScript 中的修饰符</a></p><p><strong>Key Remapping via as</strong></p><p>用 as 重新映射 key</p><blockquote><p>In TypeScript 4.1 and onwards</p></blockquote><p>as 其实是一种断言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let A: any = 18</span><br><span class="line">let B = A as string;</span><br><span class="line"></span><br><span class="line">let C:number = 18;</span><br><span class="line">let D:string = D as unknow as string;</span><br><span class="line"></span><br><span class="line">let F:string | number = 18;</span><br><span class="line">let E:string = F as string;</span><br></pre></td></tr></table></figure><p>在类型中的应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Getters&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T as `get$&#123;Capitalize&lt;string &amp; P&gt;&#125;`]: () =&gt; T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  location: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type LazyPerson = Getters&lt;Person&gt;;</span><br></pre></td></tr></table></figure><h3 id="08-Exclude-amp-Extract"><a href="#08-Exclude-amp-Extract" class="headerlink" title="08. Exclude &amp; Extract"></a>08. Exclude &amp; Extract</h3><p>Exclude</p><blockquote><p>type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Fruits = &quot;apple&quot; | &quot;banana&quot; | &#x27;peach&#x27; | &#x27;orange&#x27;;</span><br><span class="line">type DislikeFruits = &quot;apple&quot; | &quot;banana&quot;;</span><br><span class="line">type FloveFruits = Exclude&lt;Fruits, DislikeFruits&gt; // 等效于 type FloveFruits = &quot;peach&quot; | &quot;orange&quot;</span><br><span class="line"></span><br><span class="line">// 实际上 Exclude 进行的比较</span><br><span class="line">type FloveFruits =</span><br><span class="line">  | (&quot;apple&quot; extends &quot;apple&quot; | &quot;banana&quot; ? never : &quot;apple&quot;)</span><br><span class="line">  | (&quot;banana&quot; extends &quot;apple&quot; | &quot;banana&quot; ? never : &quot;banana&quot;)</span><br><span class="line">  | (&quot;peach&quot; extends &quot;apple&quot; | &quot;banana&quot; ? never : &quot;peach&quot;)</span><br><span class="line">  | (&quot;orange&quot; extends &quot;apple&quot; | &quot;banana&quot; ? never : &quot;orange&quot;)</span><br><span class="line">// 所以最后的结果</span><br><span class="line">type FloveFruits = &quot;peach&quot; | &quot;orange&quot;</span><br></pre></td></tr></table></figure><p>例子来源 <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">typescript 之 Exclude 和 Extract</a></p><p>例子说明了 <code>Exclude</code> 每个字段和整个DislikeFruits 判断继承，如果 true : never : <code>Exclude</code> 字段.</p><p><code>Extract</code> 恰好和 <code>Exclude</code> 相反</p><blockquote><p>type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Fruits = &quot;apple&quot; | &quot;banana&quot;  | &#x27;peach&#x27; | &#x27;orange&#x27;;</span><br><span class="line">type DislikeFruits = &quot;apple&quot; | &quot;banana&quot;;</span><br><span class="line">type FloveFruits = Extract&lt;Fruits, DislikeFruits&gt; // 等效于 type FloveFruits = &quot;apple&quot; | &quot;banana&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是现在不管是 <code>Exclude</code> 还是 <code>Extract</code> 都是使用联合类型作为参数，如果对象或者接口，就是整个 <code>extends</code>.</p><h3 id="09-Omit-amp-Pick"><a href="#09-Omit-amp-Pick" class="headerlink" title="09. Omit &amp; Pick"></a>09. Omit &amp; Pick</h3><blockquote><p>type Pick&lt;T, K extends keyof T&gt; &#x3D; {<br>    [key in k]: T[key]<br>}</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface TState &#123;</span><br><span class="line">name: string;</span><br><span class="line">age: number;</span><br><span class="line">like: string[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T28 = Pick&lt;TState, &quot;name&quot; | &quot;age&quot;&gt;;</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">type T28 = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>type Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; </p></blockquote><p>利用 <code>Pick</code> 来创建 Omit, Omit 是排除。</p><p>两者互为补充，如果排除少量的 Key 使用 Omit, 排除大量的使用 <code>Pick</code></p><h3 id="10-Partial"><a href="#10-Partial" class="headerlink" title="10. Partial"></a>10. Partial</h3><blockquote><p>Partial 的作用就是将某个类型里的属性全部变为可选项 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-Record"><a href="#11-Record" class="headerlink" title="11. Record"></a>11. Record</h3><blockquote><p>Record&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Record&lt;K extends keyof any, T&gt; = &#123;</span><br><span class="line">    [P in K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h3><ol><li>泛型</li><li>约束: extends 来限制 T 的类型或者范围</li><li>keyof: 获取类型的所有Key</li><li>typeof &amp; ReturnType 通过 typeof 返回全部对象类型，ReturnType和type配合获取返回值的类型</li><li>Indexed Access Types 通过索引获取type</li><li>条件类型 通过类似三元表达式的方式 a extends T ? “string” : “number”</li><li>Mapped Types: Property 关键字，in，+- 修饰符</li><li>Exclude &amp; Extract: Exclude&lt;T, U&gt; T extends U ? never : T; T &#x3D; T的每一项，Extract 返回值相反</li><li>Omit &amp; Pick Pick选择，Omit排除</li><li>Partial 所有都类型转换为 ?</li><li>Record 所有类型转换为 T</li></ol><p>泛型的基础概念是什么，传入动态类型，让代码可以最高程度的复用，为了帮助复用造就了这么多方法。</p><h3 id="13-link"><a href="#13-link" class="headerlink" title="13. link"></a>13. link</h3><ol><li><a href="https://www.typescriptlang.org/docs/handbook/2/types-from-types.html">Creating Types from Types</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">泛型</a></li><li><a href="https://www.51cto.com/article/711374.html">TS typeof 操作符原来有这五种用途！</a></li><li><a href="https://juejin.cn/post/6844904184894980104#heading-15">一文读懂 TypeScript 泛型及应用（ 7.8K字）</a></li><li><a href="https://bobbyhadz.com/blog/typescript-conversion-of-type-to-type-may-be-mistake">Conversion of type ‘X’ to type ‘Y’ may be a mistake in TS</a></li><li><a href="https://blog.csdn.net/pfourfire/article/details/125301619">TypeScript - 理清Omit与Exclude的关系与区别</a></li><li><a href="https://blog.csdn.net/qq_28992047/article/details/106879772">学习TypeScript 之 Pick与泛型约束</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三斜杠指令</title>
      <link href="/2023/07/03/ts_triple-slash-directives/"/>
      <url>/2023/07/03/ts_triple-slash-directives/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-什么是三斜杠指令"><a href="#01-什么是三斜杠指令" class="headerlink" title="01. 什么是三斜杠指令"></a>01. 什么是三斜杠指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;...&quot; /&gt;</span><br><span class="line">/// &lt;reference types=&quot;...&quot; /&gt;</span><br><span class="line">/// &lt;reference lib=&quot;...&quot; /&gt;</span><br><span class="line">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span><br><span class="line">/// &lt;amd-module /&gt;</span><br><span class="line">/// &lt;amd-dependency /&gt;</span><br></pre></td></tr></table></figure><p>官方文档中给出的样例，我也经常在 <code>typescript</code> 项目当中看到类似的引用</p><blockquote><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p><p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p><p>三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p></blockquote><p>那么这些东西有什么用呢？</p><p>就是为编译和智能提示，比如说，我全局引用了 <code>Jquery</code>, 但是我有这么多文件，都没有智能提示，这个时候 <code>reference</code> 就出场了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference types=&quot;Jquery&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;node_modules/jquery/....&quot; /&gt;</span><br></pre></td></tr></table></figure><p>两个的差别就是一个通过名字自己去 <code>node_modules</code> 里面找，一个是直接给出地址，都能让 <code>typescript</code> 通过编译了。</p><p>其他用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference lib=&quot;...&quot; /&gt;</span><br><span class="line"></span><br><span class="line">此指令允许文件显式包含现有的内置 lib 文件。</span><br><span class="line"></span><br><span class="line">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">此指令将文件标记为默认库</span><br><span class="line"></span><br><span class="line">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;</span><br><span class="line"></span><br><span class="line">默认情况下，AMD 模块是匿名生成的。 当使用其他工具处理生成的模块（例如捆绑器）时，这可能会导致问题。r.js</span><br><span class="line"></span><br><span class="line">该指令允许将可选模块名称传递给编译器：amd-module</span><br><span class="line"></span><br><span class="line">/// &lt;amd-dependency /&gt;</span><br><span class="line"></span><br><span class="line">将导致将名称分配给模块作为调用 AMD 的一部分：NamedModuledefine</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p><a href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html">triple-slash-directives</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mixin</title>
      <link href="/2023/07/03/ts_mixin/"/>
      <url>/2023/07/03/ts_mixin/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// Disposable Mixin</span><br><span class="line">class Disposable &#123;</span><br><span class="line">    isDisposed: boolean;</span><br><span class="line">    dispose() &#123;</span><br><span class="line">        this.isDisposed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Activatable Mixin</span><br><span class="line">class Activatable &#123;</span><br><span class="line">    isActive: boolean;</span><br><span class="line">    activate() &#123;</span><br><span class="line">        this.isActive = true;</span><br><span class="line">    &#125;</span><br><span class="line">    deactivate() &#123;</span><br><span class="line">        this.isActive = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SmartObject implements Disposable, Activatable &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        setInterval(() =&gt; console.log(this.isActive + &quot; : &quot; + this.isDisposed), 500);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interact() &#123;</span><br><span class="line">        this.activate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Disposable</span><br><span class="line">    isDisposed: boolean = false;</span><br><span class="line">    dispose: () =&gt; void;</span><br><span class="line">    // Activatable</span><br><span class="line">    isActive: boolean = false;</span><br><span class="line">    activate: () =&gt; void;</span><br><span class="line">    deactivate: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">applyMixins(SmartObject, [Disposable, Activatable]);</span><br><span class="line"></span><br><span class="line">let smartObj = new SmartObject();</span><br><span class="line">setTimeout(() =&gt; smartObj.interact(), 1000);</span><br><span class="line"></span><br><span class="line">////////////////////////////////////////</span><br><span class="line">// In your runtime library somewhere</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;</span><br><span class="line">    baseCtors.forEach(baseCtor =&gt; &#123;</span><br><span class="line">        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;</span><br><span class="line">            derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方例子关于 mixin 的解释有点类似于原型链的继承，单纯的复制原型链。</p><p>后续的原型链覆盖之前的原型链, 核心代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;</span><br><span class="line">    baseCtors.forEach(baseCtor =&gt; &#123;</span><br><span class="line">        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;</span><br><span class="line">            derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没什么难以理解的，知识让我疑惑的点在于明明就是一个原型链的复制，为什么要专门开一章来说明，并且其一个名字叫 mixin.</p><h3 id="02-其他地方定义的mixin"><a href="#02-其他地方定义的mixin" class="headerlink" title="02. 其他地方定义的mixin"></a>02. 其他地方定义的mixin</h3><blockquote><p>「混合」是一个函数：</p><p>传入一个构造函数；<br>创建一个带有新功能，并且扩展构造函数的新类；<br>返回这个新类。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 所有 mixins 都需要</span><br><span class="line">type Constructor&lt;T = &#123;&#125;&gt; = new (...args: any[]) =&gt; T;</span><br><span class="line"></span><br><span class="line">/////////////</span><br><span class="line">// mixins 例子</span><br><span class="line">////////////</span><br><span class="line"></span><br><span class="line">// 添加属性的混合例子</span><br><span class="line">function Timestamped&lt;TBase extends Constructor&gt;(Base: TBase) &#123;</span><br><span class="line">  return class extends Base &#123;</span><br><span class="line">    timestamp = Date.now();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加属性和方法的混合例子</span><br><span class="line">function Activatable&lt;TBase extends Constructor&gt;(Base: TBase) &#123;</span><br><span class="line">  return class extends Base &#123;</span><br><span class="line">    isActivated = false;</span><br><span class="line"></span><br><span class="line">    activate() &#123;</span><br><span class="line">      this.isActivated = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deactivate() &#123;</span><br><span class="line">      this.isActivated = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这个例子其实类似于高解组件的写法，高解组件是在后续调用原有的组件，而这个例子是继承</p><p>其实和前面官方例子当中复制原型链的方式其实差不多，extends 本质上也是原型链继承，只是细微上有差别。</p><h3 id="03-什么是typescript-mixin"><a href="#03-什么是typescript-mixin" class="headerlink" title="03. 什么是typescript mixin"></a>03. 什么是typescript mixin</h3><p>其实就是继承，从效果上来看也算是 mixin</p><h3 id="04-link"><a href="#04-link" class="headerlink" title="04. link"></a>04. link</h3><ol><li><a href="https://www.tslang.cn/docs/handbook/mixins.html">Mixins</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/mixins.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">深入理解 typescript 混合</a></li><li><a href="https://juejin.cn/post/6844903527941144589">setPrototypeOf 与 Object.create区别</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>infer</title>
      <link href="/2023/07/03/ts_Infer/"/>
      <url>/2023/07/03/ts_Infer/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><blockquote><p>infer 是在 typescript 2.8中新增的关键字。<br>infer 可以在 extends 条件类型的字句中，在真实分支中引用此推断类型变量，推断待推断的类型。</p></blockquote><h2 id="01-infer-有什么用？"><a href="#01-infer-有什么用？" class="headerlink" title="01. infer 有什么用？"></a>01. infer 有什么用？</h2><blockquote><p>推导泛型参数</p></blockquote><p>他的本质上就是推导泛型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type T1&lt;T&gt; = T extends () =&gt; infer p ? p : number </span><br></pre></td></tr></table></figure><p>判断 T 继承自 () &#x3D;&gt; T, 如果是返回 T， 如果不是返回 number.</p><p>而这个 <code>infer p == T</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type T2 = T1&lt;() =&gt; string&gt;</span><br><span class="line">//T2 === string</span><br><span class="line">type T3 = T1&lt;(i: number) =&gt; void&gt;</span><br><span class="line">//T3 === number</span><br></pre></td></tr></table></figure><p>还可以多个参数，进行协变和逆变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type T4&lt;T&gt; = T extends (a: infer P, b: infer P) =&gt; void ? P : any;</span><br><span class="line">type T5 = T4&lt;() =&gt; void&gt;; //any</span><br><span class="line">type T6 = T4&lt;(a:string, b: number) =&gt; void&gt; // string &amp; number</span><br></pre></td></tr></table></figure><p>上面这个是例子是网上看到的例子</p><blockquote><p>协变：类型推导到其子类型的过程，A | B -&gt; A &amp; B 就是一个协变<br>逆变：类型推导到其超类型的过程</p></blockquote><p>也就是说参数是一个逆变 <code>string &amp; nubmer</code> &#x3D; never;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123; name: string, age:number &#125;;</span><br><span class="line">type OtherInfo = &#123; sex: string &#125;;</span><br><span class="line">type T7 = T4&lt;(a: User, b:OtherInfo) =&gt; void&gt; // User &amp; OtherInfo</span><br></pre></td></tr></table></figure><p>之前的 <code>ReturnType</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T </span><br><span class="line">  extends (...args: any) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><h3 id="02-应用场景"><a href="#02-应用场景" class="headerlink" title="02. 应用场景"></a>02. 应用场景</h3><blockquote><p>一般业务代码用 any 也不要写 infer，因为要顾及可读性和维护性，要不同事也会打人的。<br>如果有机会你封装 util、hook，甚至是一个 npm 包，你需要通过使用者的输入给予更好的类型提示，infer 就是一个很重要的关键字了。<br>具体例子有很多，如果你有心翻一翻各种库的 ts 定义就会发现 infer 被大量使用</p></blockquote><p><a href="https://github.com/reduxjs/redux/blob/8ad084251a5b3e4617157fc52795b6284e68bc1e/src/types/reducers.ts#L48">redux&#x2F;src&#x2F;types&#x2F;reducers.ts</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Infer a combined state shape from a `ReducersMapObject`.</span><br><span class="line"> *</span><br><span class="line"> * @template M Object map of reducers as provided to `combineReducers(map: M)`.</span><br><span class="line"> */</span><br><span class="line">export type StateFromReducersMapObject&lt;M&gt; = M extends ReducersMapObject</span><br><span class="line">  ? &#123; [P in keyof M]: M[P] extends Reducer&lt;infer S, any&gt; ? S : never &#125;</span><br><span class="line">  : never</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Infer reducer union type from a `ReducersMapObject`.</span><br><span class="line"> *</span><br><span class="line"> * @template M Object map of reducers as provided to `combineReducers(map: M)`.</span><br><span class="line"> */</span><br><span class="line">export type ReducerFromReducersMapObject&lt;M&gt; = M extends &#123;</span><br><span class="line">  [P in keyof M]: infer R</span><br><span class="line">&#125;</span><br><span class="line">  ? R extends Reducer&lt;any, any&gt;</span><br><span class="line">    ? R</span><br><span class="line">    : never</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Infer action type from a reducer function.</span><br><span class="line"> *</span><br><span class="line"> * @template R Type of reducer.</span><br><span class="line"> */</span><br><span class="line">export type ActionFromReducer&lt;R&gt; = R extends Reducer&lt;any, infer A&gt; ? A : never</span><br></pre></td></tr></table></figure><h3 id="03-link"><a href="#03-link" class="headerlink" title="03. link"></a>03. link</h3><ol><li><a href="http://www.semlinker.com/ts-infer/">TypeScript infer 关键字</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%B8%80%E4%BA%9B%E7%94%A8%E4%BE%8B">infer</a></li><li><a href="https://github.com/reduxjs/redux/blob/8ad084251a5b3e4617157fc52795b6284e68bc1e/src/types/reducers.ts#L48">redux&#x2F;src&#x2F;types&#x2F;reducers.ts</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器(js &amp; ts)</title>
      <link href="/2023/07/03/ts_decorator/"/>
      <url>/2023/07/03/ts_decorator/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-js版本"><a href="#01-js版本" class="headerlink" title="01. js版本"></a>01. js版本</h3><p>之前在看 typescript decorators 的时候想起 js 其实也有 decorators, 于是翻了一下阮一峰的 es6 教程。<br>在自己测试的时候，发现不光是编辑器提示错误，并且在浏览器中也不支持，通过nodejs尝试，也不行。</p><p>于是查了一下</p><p><a href="https://caniuse.com/decorators">https://caniuse.com/decorators</a></p><p>并不支持，想要使用特性</p><ol><li>react</li><li>typescript</li><li>babel</li></ol><p>Es6原生语法</p><p><a href="https://es6.ruanyifeng.com/#docs/decorator">https://es6.ruanyifeng.com/#docs/decorator</a></p><h3 id="02-typescript-decorators"><a href="#02-typescript-decorators" class="headerlink" title="02. typescript decorators"></a>02. typescript decorators</h3><p>不管是 C#，java 或者 ag，nest.js 只要你使用过对这个东西就不会陌生。</p><blockquote><p>随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 建议征集的第二阶段，但在TypeScript里已做为一项实验性特性予以支持。<br>注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。<br>若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项：</p></blockquote><p>要使用这个你需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;ES5&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true,</span><br><span class="line">        &quot;emitDecoratorMetadata&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中介绍了这几种装饰器</p><ol><li>类装饰器</li><li>方法装饰器</li><li>访问器装饰器</li><li>属性装饰器</li><li>参数装饰器</li></ol><p>也就是主要用途是给类，function，以及里面的属性，参数，访问器服务。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function decoratorA(target) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decoratorB(value:boolean) &#123;</span><br><span class="line">return function(target, key, desc) &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别主要在于是否传参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@decoratorA</span><br><span class="line">@decoratorB(false)</span><br></pre></td></tr></table></figure><p>每个装饰器用在不同的对象上参数是不一样的。</p><p>这样就是一个最简单的装饰器</p><h3 id="03-执行时机"><a href="#03-执行时机" class="headerlink" title="03. 执行时机"></a>03. 执行时机</h3><p>我们需要知道什么时候执行装饰器</p><blockquote><p>装饰器只在解释执行时应用一次</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function log(value: string): any &#123;</span><br><span class="line">  console.log(`log function $&#123;value&#125;`);</span><br><span class="line">  return function () &#123;</span><br><span class="line">    //省略参数，因为我不需要</span><br><span class="line">    console.log(`log return function $&#123;value&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@log(&quot;类&quot;)</span><br><span class="line">class testLog &#123;</span><br><span class="line">  @log(&quot;属性&quot;)</span><br><span class="line">  B: number;</span><br><span class="line"></span><br><span class="line">  @log(&quot;静态属性&quot;)</span><br><span class="line">  static C: number;</span><br><span class="line"></span><br><span class="line">  @log(&quot;方法&quot;)</span><br><span class="line">  A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @log(&quot;静态方法&quot;)</span><br><span class="line">  static D() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  F(@log(&quot;参数&quot;) i: number) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @log(&quot;访问器&quot;)</span><br><span class="line">  set X(arg) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">log function 属性</span><br><span class="line">return function 属性</span><br><span class="line">index.js:66 log function 方法</span><br><span class="line">return function 方法</span><br><span class="line">index.js:66 log function 参数</span><br><span class="line">return function 参数</span><br><span class="line">index.js:66 log function 访问器</span><br><span class="line">return function 访问器</span><br><span class="line">index.js:66 log function 静态属性</span><br><span class="line">return function 静态属性</span><br><span class="line">index.js:66 log function 静态方法</span><br><span class="line">return function 静态方法</span><br><span class="line">index.js:66 log function 类</span><br><span class="line">return function 类</span><br></pre></td></tr></table></figure><blockquote><p>属性 &gt; 方法 &gt; 参数 &gt; 访问器 &gt; 静态属性 &gt; 静态方法 &gt; 类</p></blockquote><p>然后就是相同装饰器，比如一个类有两个装饰器的情况下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@log(&quot;类&quot;)</span><br><span class="line">@log(&quot;类1&quot;)</span><br><span class="line">class testLog &#123;</span><br><span class="line">  @log(&quot;属性&quot;)</span><br><span class="line">  @log(&quot;属性1&quot;)</span><br><span class="line">  B: number;</span><br><span class="line"></span><br><span class="line">  @log(&quot;静态属性&quot;)</span><br><span class="line">  @log(&quot;静态属性1&quot;)</span><br><span class="line">  static C: number;</span><br><span class="line"></span><br><span class="line">  @log(&quot;方法&quot;)</span><br><span class="line">  @log(&quot;方法1&quot;)</span><br><span class="line">  A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @log(&quot;静态方法&quot;)</span><br><span class="line">  @log(&quot;静态方法1&quot;)</span><br><span class="line">  static D() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  F(@log(&quot;参数&quot;) i: number, @log(&quot;参数1&quot;) y: number) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @log(&quot;访问器&quot;)</span><br><span class="line">  @log(&quot;访问器1&quot;)</span><br><span class="line">  set X(arg) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">log function 属性</span><br><span class="line">index.js:66 log function 属性1</span><br><span class="line">return function 属性1</span><br><span class="line">return function 属性</span><br><span class="line">index.js:66 log function 方法</span><br><span class="line">index.js:66 log function 方法1</span><br><span class="line">return function 方法1</span><br><span class="line">return function 方法</span><br><span class="line">index.js:66 log function 参数</span><br><span class="line">index.js:66 log function 参数1</span><br><span class="line">return function 参数1</span><br><span class="line">return function 参数</span><br><span class="line">index.js:66 log function 访问器</span><br><span class="line">index.js:66 log function 访问器1</span><br><span class="line">return function 访问器1</span><br><span class="line">return function 访问器</span><br><span class="line">index.js:66 log function 静态属性</span><br><span class="line">index.js:66 log function 静态属性1</span><br><span class="line">return function 静态属性1</span><br><span class="line">return function 静态属性</span><br><span class="line">index.js:66 log function 静态方法</span><br><span class="line">index.js:66 log function 静态方法1</span><br><span class="line">return function 静态方法1</span><br><span class="line">return function 静态方法</span><br><span class="line">index.js:66 log function 类</span><br><span class="line">index.js:66 log function 类1</span><br><span class="line">return function 类1</span><br><span class="line">return function 类</span><br></pre></td></tr></table></figure><p>也就是说先放先执行构造函数，后面装饰器的后执行构造函数，但是先执行回调。<br>总的来说，就是后放先执行。</p><h3 id="04-类装饰器"><a href="#04-类装饰器" class="headerlink" title="04. 类装饰器"></a>04. 类装饰器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type ClassDecorator = &lt;TFunction extends Function&gt;</span><br><span class="line">(target: TFunction) =&gt; TFunction | void;</span><br></pre></td></tr></table></figure><p>可以做什么？</p><blockquote><p>如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。<br>因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。<br>例如我们可以添加一个toString方法给所有的类来覆盖它原有的toString方法。<br>也就是说其实只能对构造函数进行重载，当然也够用了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function classDecorator&lt;T extends &#123; new (...args: any[]) &#125;&gt;(constructor: T) &#123;</span><br><span class="line">  return class extends constructor &#123;</span><br><span class="line">    title = &quot;classDecorator title&quot;;</span><br><span class="line">toString() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的装饰器 classDecorator 重载了类的构造函数，并且新建属性 title， 重载了 <code>toString()</code> 输出。</p><h3 id="05-属性装饰器"><a href="#05-属性装饰器" class="headerlink" title="05. 属性装饰器"></a>05. 属性装饰器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void;</span><br></pre></td></tr></table></figure><p>@<strong>参数</strong></p><ol><li>target 目标</li><li>propertyKey 属性名</li></ol><p>@<strong>可以做什么</strong></p><blockquote><p>监控变化<br>重写属性<br>收集信息<br>标记验证</p></blockquote><p>等等，比如说实现一个 readonly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function myReadonly(target: Object, key: string) &#123;</span><br><span class="line">  Reflect.defineProperty(target, key, &#123;</span><br><span class="line">    set(v) &#123;</span><br><span class="line">      if (this.key === undefined) &#123;</span><br><span class="line">        this.key = v;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw new Error(`$&#123;key&#125; is readonly`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @myReadonly</span><br><span class="line">  foo: string = &quot;a&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myC = new C();</span><br><span class="line">myC.foo = &quot;aaaaaaa&quot;;</span><br><span class="line">console.log(myC.foo);</span><br></pre></td></tr></table></figure><h3 id="06-方法装饰器"><a href="#06-方法装饰器" class="headerlink" title="06. 方法装饰器"></a>06. 方法装饰器</h3><p>@<strong>参数</strong></p><ol><li>target: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li><li>propertyKey: 属性的名称。</li><li>descriptor: {<br> value<br> writable<br> enumerable<br> configurable<br>}</li></ol><p>@<strong>返回</strong></p><ol><li>如果返回了值，它会被用于替代属性的描述器。</li></ol><p>@<strong>场景</strong></p><p>几乎可以适用任何场景，你甚至可以重写方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor.value === Function</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">  const original = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = function (...args) &#123;</span><br><span class="line">    console.log(&#x27;params: &#x27;, ...args);</span><br><span class="line">    const result = original.call(this, ...args);</span><br><span class="line">    console.log(&#x27;result: &#x27;, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @logger</span><br><span class="line">  add(x: number, y:number ) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line">c.add(1, 2);</span><br></pre></td></tr></table></figure><h3 id="07-访问器装饰器"><a href="#07-访问器装饰器" class="headerlink" title="07. 访问器装饰器"></a>07. 访问器装饰器</h3><p>@<strong>参数</strong></p><ol><li>target</li><li>propertyKey</li><li>descriptor {<br> get<br> set<br> enumerable<br> configurable<br>}</li></ol><p>需要注意的是，不管是给 <code>get</code> or <code>set</code> 添加访问器，添加一个就相当于都添加了</p><p>@<strong>返回</strong> 忽略</p><p>@<strong>场景</strong></p><p>其实和方法差不多，重写，加日志等等，只要你想得到。</p><h3 id="08-参数装饰器"><a href="#08-参数装饰器" class="headerlink" title="08. 参数装饰器"></a>08. 参数装饰器</h3><p>@<strong>参数</strong></p><ol><li>target: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li><li>propertyKey: 属性的名称(注意是方法的名称，而不是参数的名称)。</li><li>parameterIndex: 参数在方法中所处的位置的下标。</li></ol><p>@<strong>返回</strong> </p><p>忽略</p><p>@<strong>场景</strong></p><p>验证，验证方式，日志等等。</p><h3 id="09-例子"><a href="#09-例子" class="headerlink" title="09. 例子"></a>09. 例子</h3><p>如果我需要写一个类的参数的装饰器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 1. 属性 &gt; 方法 &gt; 参数 &gt; 访问器 &gt; 静态属性 &gt; 静态方法 &gt; 类</span><br><span class="line">// 2. 装饰器只在解释执行时应用一次</span><br><span class="line">// 3. 所以需要在方法或者类装饰器解析的时候，重载为必包，先验证参数，后调用</span><br><span class="line">// 4. 需要有变量保存验证的函数</span><br><span class="line">// 5. 需要工厂方法，或者抽象类去写清楚各种不同的验证</span><br><span class="line"></span><br><span class="line">//验证类型</span><br><span class="line">type Validator = (x: any) =&gt; boolean;</span><br><span class="line"></span><br><span class="line">//验证方法集合</span><br><span class="line">let validatorMap = new Map&lt;string, Validator&gt;();</span><br><span class="line"></span><br><span class="line">//属性验证装饰器工厂</span><br><span class="line">function validatorFactiory(vaildator: Validator) &#123;</span><br><span class="line">  return function (target, key, index) &#123;</span><br><span class="line">    let keyStr = key as string;</span><br><span class="line">    let t = validatorMap[keyStr] ?? [];</span><br><span class="line">    t[index] = vaildator;</span><br><span class="line">    validatorMap.set(key, t);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//暂时不需要参数</span><br><span class="line">//</span><br><span class="line">function valid(target: any, key: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line"></span><br><span class="line">  //保存原有方法</span><br><span class="line">  const original = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = function (...args) &#123;</span><br><span class="line"></span><br><span class="line">    //验证参数</span><br><span class="line">    for (let i in args) &#123;</span><br><span class="line">      let validtors = validatorMap.get(key);</span><br><span class="line">      if (validtors !== undefined) &#123;</span><br><span class="line">        for (let i = 0; i &lt; validtors.length; i++) &#123;</span><br><span class="line">          if(!validtors[i](args[i])) &#123;</span><br><span class="line">            throw new Error(`$&#123;key&#125; 值为 $&#123;args[i]&#125;, 验证失败`);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    original.call(this, &#123; ...args &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const validString = validatorFactiory((v: any) =&gt; &#123;</span><br><span class="line">  return typeof v === &quot;string&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">const validNumber = validatorFactiory((v: any) =&gt; &#123;</span><br><span class="line">  return Number.isInteger(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @valid</span><br><span class="line">  a(@validString a) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myC = new C();</span><br><span class="line">myC.a(1);</span><br></pre></td></tr></table></figure><p>这里就写了一个简单的装饰器，不仅如此，比如我要写一个解析 request body的装饰器，也可以这样写。</p><h3 id="11-link"><a href="#11-link" class="headerlink" title="11. link"></a>11. link</h3><p><a href="https://es6.ruanyifeng.com/#docs/decorator">阮一峰 es6 装饰器</a></p><p><a href="https://www.tslang.cn/docs/handbook/decorators.html">typescript 中文文档 装饰器</a></p><p><a href="https://jkchao.github.io/typescript-book-chinese/tips/metadata.html#%E5%9F%BA%E7%A1%80">Reflect Metadata typescript</a></p><p><a href="https://stackoverflow.com/questions/58057916/what-does-t-extends-new-args-any-constructort-mean-in-typescr">What does &lt;T extends { new(…args: any[]): {} }&gt;(constructor:T) mean in typescript?</a></p><p>[TypeScript 中的 Decorator &amp; 元数据反射：从小白到专家（部分 I）(<a href="https://zhuanlan.zhihu.com/p/20297283">https://zhuanlan.zhihu.com/p/20297283</a>)</p><p><a href="https://stackoverflow.com/questions/45165224/what-is-reflect-decorate-in-js-code-transpiled-from-ts">What is <code>Reflect.decorate</code> in JS code transpiled from TS?</a></p><p><a href="https://github.com/tc39/proposal-decorators">tc39 Decorators</a></p><p><a href="https://stackoverflow.com/questions/37694322/typescript-ts1241-unable-to-resolve-signature-of-method-decorator-when-called-a">typescript TS1241: Unable to resolve signature of method decorator when called as an expression</a></p><p><a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a></p><p><a href="https://jkchao.github.io/typescript-book-chinese/tips/metadata.html#%E5%9F%BA%E7%A1%80">Reflect Metadata</a></p><p><a href="https://www.zhihu.com/question/20679872">什么是元数据？为何需要元数据?</a></p><p><a href="https://www.ruanyifeng.com/blog/2007/03/metadata.html">元数据,阮一峰</a></p><p><a href="https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/">TypeScript装饰器完全指南</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstructSignature 错误</title>
      <link href="/2023/07/03/constructSignatureError/"/>
      <url>/2023/07/03/constructSignatureError/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="ConstructSignature"><a href="#ConstructSignature" class="headerlink" title="ConstructSignature"></a>ConstructSignature</h1><p>看构造函数签名起源于一个错误</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">commonMobileFunc</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">call</span>(<span class="attr">ph</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">sms</span>(<span class="attr">ph</span>: <span class="built_in">number</span>, <span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">oldMobile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">commonMobileFunc</span> &#123;</span><br><span class="line">  <span class="title function_">call</span>(<span class="attr">ph</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">sms</span>(<span class="attr">ph</span>: <span class="built_in">number</span>, <span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newMobile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">commonMobileFunc</span> &#123;</span><br><span class="line">  <span class="title function_">call</span>(<span class="attr">ph</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">sms</span>(<span class="attr">ph</span>: <span class="built_in">number</span>, <span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">videoCall</span>(<span class="params">ph: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exec</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">model</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = <span class="keyword">new</span> <span class="title function_">arg</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sms</span>(<span class="params">ph: <span class="built_in">number</span>, text: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span>.<span class="title function_">sms</span>(ph, text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象出一个通用的手机功能类型<br>新手机 call sms videoCall<br>旧手机 call sms<br>如果我想实例化对象，可以通过工厂方法，依赖注入等等方式<br>这次想通过泛型的方法去实例化，但是报错了。</p></blockquote><p>但是构造函数签名可以解决这个问题</p><h3 id="01-什么是构造函数签名"><a href="#01-什么是构造函数签名" class="headerlink" title="01. 什么是构造函数签名"></a>01. 什么是构造函数签名</h3><p>语法</p><blockquote><p>ConstructSignature: new TypeParametersopt (ParameterListopt) TypeAnnotationopt</p></blockquote><p>TypeScript 官方解释</p><blockquote><p>An object type containing one or more construct signatures is said to be a constructor type. Constructor types may be written using constructor type literals or by including construct signatures in object type literals.</p></blockquote><p>机翻</p><blockquote><p>包含一个或多个构造签名的对象类型被称为构造函数类型。 构造函数类型可以使用构造函数类型文字或通过在对象类型文字中包含构造签名来编写。</p></blockquote><p>也就是下面这种</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;<span class="variable constant_">T1</span>,<span class="variable constant_">T2</span> ...&gt;<span class="function">(<span class="params">p1, p2</span>) =&gt;</span> <span class="title class_">Result</span></span><br></pre></td></tr></table></figure><p>这样问题就得到了解决, 沿用最开始抽象的例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> I1 &#123;</span><br><span class="line">  <span class="keyword">new</span> (): commonMobileFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="attr">model</span>: commonMobileFunc;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">arg: I1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">model</span> = <span class="keyword">new</span> <span class="title function_">arg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以用简写的方式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="attr">model</span>: commonMobileFunc;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">arg: &#123; <span class="keyword">new</span>(): commonMobileFunc &#125;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">model</span> = <span class="keyword">new</span> <span class="title function_">arg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-泛型构造函数签名"><a href="#02-泛型构造函数签名" class="headerlink" title="02. 泛型构造函数签名"></a>02. 泛型构造函数签名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T3&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">new</span> (): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T4 &#123;</span><br><span class="line">    <span class="title function_">sms</span>(<span class="attr">ph</span>: <span class="built_in">number</span>, <span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">call</span>(<span class="attr">ph</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>&lt;T&gt; <span class="keyword">implements</span> <span class="variable constant_">T4</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg: T3&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = <span class="keyword">new</span> <span class="title function_">arg</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sms</span>(<span class="attr">ph</span>: <span class="built_in">number</span>, <span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">call</span>(<span class="attr">ph</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要智能提示，可以增加约束</p><h3 id="03-应用场景"><a href="#03-应用场景" class="headerlink" title="03. 应用场景"></a>03. 应用场景</h3><p>我们可以创建一个泛型工厂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function F1&lt;T&gt;(arg: &#123; new():T &#125;) &#123;</span><br><span class="line">    return new arg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我上文写的也是一种工厂，比如我想实现依赖注入,就是源于类似的思路</p><h3 id="04-定义了构造器签名的接口无法被实现"><a href="#04-定义了构造器签名的接口无法被实现" class="headerlink" title="04. 定义了构造器签名的接口无法被实现"></a>04. 定义了构造器签名的接口无法被实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface T2&lt;T&gt; &#123;</span><br><span class="line">  new (): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C5&lt;T&gt; implements T2&lt;T&gt; &#123;</span><br><span class="line">    constructor(arg: T) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Class ‘C5 T’ incorrectly implements interface ‘T2 T’.<br>Type ‘C5 T’ provides no match for the signature ‘new (): T’.ts(2420)</p></blockquote><p>我觉得这个应该实现</p><h3 id="05-link"><a href="#05-link" class="headerlink" title="05. link"></a>05. link</h3><ol><li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html">More on Functions</a></li><li><a href="https://stackoverflow.com/questions/13407036/how-does-interfaces-with-construct-signatures-work">How does interfaces with construct signatures work?</a></li><li><a href="https://juejin.cn/post/6844904184894980104#heading-14">一文读懂 TypeScript 泛型及应用（ 7.8K字）</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘和回流的基本概念</title>
      <link href="/2023/07/03/repaint_reflow/"/>
      <url>/2023/07/03/repaint_reflow/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="01-基本概念"><a href="#01-基本概念" class="headerlink" title="01. 基本概念"></a>01. 基本概念</h3><p>单纯说概念就是 浏览器渲染会解析css，dom对吧，如果你更改背景颜色，dom等等就需要重新渲染对吧，这个就是重绘和回流。</p><p>复杂一点说概念就是</p><blockquote><p>重绘（Repaint）：</p><p>定义：重绘是指当元素的样式发生改变，但不影响其布局的情况下，浏览器重新绘制元素的可视部分。</p><p>过程：浏览器会根据新的样式属性值更新元素的视觉外观，重新绘制元素的背景色、边框、文本等可视效果。<br>影响：重绘操作不会影响页面的布局和几何属性，只是重新绘制元素的外观，所以开销相对较小。</p><p>回流（Reflow）：</p><p>定义：回流是指当页面的布局发生改变，例如元素的尺寸、位置、显示&#x2F;隐藏状态等改变时，浏览器重新计算并应用所有受影响元素的几何属性，然后重新排列页面中的元素。</p><p>过程：浏览器会从页面的根节点开始递归遍历，并计算每个受影响元素的布局属性，例如位置、尺寸、相对关系等。<br>影响：回流操作涉及大量的计算和重新排列，会导致整个页面或部分页面的重建，开销较大，可能会引起页面闪烁和性能下降。</p></blockquote><h3 id="02-浏览器请求的基本原理"><a href="#02-浏览器请求的基本原理" class="headerlink" title="02. 浏览器请求的基本原理"></a>02. 浏览器请求的基本原理</h3><p>在知道什么是重绘和回流以后，如果要搞清楚究竟是怎么回事儿，就需要浏览器大概是怎么做的</p><ol><li>用户在浏览器地址栏中输入要访问的网址（URL），然后按下回车键。</li><li>浏览器会将输入的网址发送给本地的DNS解析器，解析器负责将域名转换为对应的IP地址。</li><li>浏览器使用HTTP或HTTPS协议，通过TCP&#x2F;IP协议与服务器建立网络连接。这个过程包括三次握手，确保客户端与服务器之间的可靠连接。</li><li>浏览器向服务器发送HTTP请求，包括请求的方法（GET、POST等）、请求的资源路径、请求头部等信息。</li><li>服务器接收到浏览器发送的请求后，根据请求的资源路径和其他参数进行处理。服务器可能需要查询数据库、执行业务逻辑等操作，最终生成相应的数据或页面。</li><li>服务器将处理结果封装成HTTP响应，包括响应的状态码、响应头部和响应体等信息。服务器会将响应发送回给浏览器。</li><li>浏览器接收到服务器发送的HTTP响应，开始接收响应数据。</li><li>浏览器对收到的HTTP响应进行解析，提取出响应头部和响应体等信息。</li><li>浏览器开始根据解析得到的响应数据，渲染页面。这个过程包括解析HTML结构、构建DOM树，加载和解析CSS样式，以及执行JavaScript代码。</li><li>浏览器将DOM树和CSS样式结合起来，构建渲染树（Render Tree）。渲染树表示了要显示在页面上的所有可见元素及其样式信息。</li><li>浏览器根据渲染树的信息，计算每个元素在页面上的位置和大小。这个过程被称为布局或回流（reflow）。</li><li>浏览器根据渲染树和布局结果，开始绘制页面的每个元素，将其呈现在屏幕上。</li><li>绘制完成后，浏览器将页面呈现给用户进行查看。用户可以与页面进行交互，执行操作。</li></ol><p>简单说就如下</p><p>url &#x3D;&gt; dns &#x3D;&gt; ip &#x3D;&gt; tcp &#x3D;&gt; http(get,post..) &#x3D;&gt; 获取响应数据(头，数据等) &#x3D;&gt; 解析html &#x3D;&gt; 构建dom树 &#x3D;&gt; css树 &#x3D;&gt; 执行javascript &#x3D;&gt; 结合dom树，css树 身成 render树。 &#x3D;&gt; 渲染出元素位置和大小(回流) &#x3D;&gt; 绘制元素(重绘)</p><p>过程大概就是这样, 这里知道了回流和重绘产生的阶段，但是这里其实没有说一些细节概念，但是和回流和重绘相关。</p><ol><li>浏览器将DOM解析为DOM树，并将树中的节点分割为多个图层（Layer），以便进行后续的渲染优化。</li><li>浏览器对每个图层的节点进行样式计算，确定每个节点的最终样式结果。</li><li>layout, 渲染出元素位置和大小(回流)</li><li>在绘制（Paint）阶段，浏览器将每个节点的绘制命令转化为位图，将节点的内容绘制到图层的位图中</li><li>图层作为纹理上传至GPU</li><li>浏览器将不同图层的位图进行合成（Composite），按照正确的层次顺序叠加在一起，生成最终的屏幕图像</li></ol><p>这就是浏览器渲染的基本流程，为什么要讲这个？为什么要知道图层的概念？</p><p>因为重绘和回流可以控制在图层中，可以限制范围，从而提升性能。</p><h3 id="03-重绘代价是什么？"><a href="#03-重绘代价是什么？" class="headerlink" title="03. 重绘代价是什么？"></a>03. 重绘代价是什么？</h3><p>从之前讲的基本概念我们可以知道重绘的代价是比较小的</p><blockquote><p>浏览器会根据新的样式属性值更新元素的视觉外观，重新绘制元素的背景色、边框、文本等可视效果。<br>影响：重绘操作不会影响页面的布局和几何属性，只是重新绘制元素的外观，所以开销相对较小.</p></blockquote><p>因为它不会改变整体大小，不会导致整体大小重新计算，仅仅改变当前部分，所以代价是比较小的。</p><p>这里涉及到一个问题，就是重绘的范围, 我在查资料的时候，对于重绘的说法都是只影响当前的元素，那么他是否有可能影响到其他元素呢？</p><p>这里是可能触发重绘的操作</p><ul><li>color</li><li>background</li><li>outline-color  </li><li>border-style </li><li>background-image </li><li>outline</li><li>border-radius </li><li>background-position </li><li>outline-style</li><li>visibility </li><li>background-repeat </li><li>outline-width     </li><li>text-decoration </li><li>background-size </li><li>box-shadow</li></ul><p>重绘的开销其实可以不那么精确计算，因为正常情况下不会出现不停的修改样式，往往是做动画的时候才会出现。这个时候善用 css3动画的gpu加速的特性就好了。</p><h3 id="04-回流的代价是什么？"><a href="#04-回流的代价是什么？" class="headerlink" title="04. 回流的代价是什么？"></a>04. 回流的代价是什么？</h3><p>回流就比较简单了，任何改变都可能导致整个页面回流，最简单的例子就是窗口发生改变，那么整个页面也就回流了。</p><p>比如你突然改变一个元素的大小，自然会导致问题，这就是应该避免或者优化的东西。</p><ul><li>width </li><li>top </li><li>text-align </li><li>height </li><li>bottom </li><li>overflow-y </li><li>padding </li><li>left </li><li>font-weight </li><li>margin </li><li>right </li><li>overflow </li><li>display </li><li>position </li><li>font-family </li><li>border-width </li><li>float </li><li>line </li><li>height </li><li>border </li><li>clear </li><li>vertival-align </li><li>min-height </li><li>white-space</li></ul><h3 id="05-优化"><a href="#05-优化" class="headerlink" title="05. 优化"></a>05. 优化</h3><h5 id="05-01-合并操作"><a href="#05-01-合并操作" class="headerlink" title="05.01. 合并操作"></a>05.01. 合并操作</h5><p>当我们要去修改css，尽量不用使用行内css，多用class，保证修改次数少。<br>设计 css 的时候，多用选择器。<br>保证一件事，减少次数，但是这个似乎现在浏览器都做了优化，但是还是需要注意。</p><p>在css上注意，在dom操作上也需要注意。<br>比如我要绑定数据，写一个循环不停的创建，可能会不停的触发回流。</p><p>合并就是减少回流次数</p><ul><li>比如说先隐藏，修改，显示</li><li>使用 document fragment，是一个在内存中存在但不在 DOM 树中的文档节点，相当于一个临时容器。</li><li>或者拷贝到一个不显示的地方，在进行移动操作。</li></ul><h5 id="05-2-避免触发同步布局"><a href="#05-2-避免触发同步布局" class="headerlink" title="05.2. 避免触发同步布局"></a>05.2. 避免触发同步布局</h5><p>首先需要知道什么是同步布局事件，我们刚才看了浏览器执行的流程</p><p>dom tree &#x3D;&gt; ccs tree &#x3D;&gt; javascript &#x3D;&gt; render tree &#x3D;&gt; layout.</p><p>但是如果遇到一种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">for(let i=0;i&lt;els.length;i++) &#123;</span><br><span class="line">els[i].style.width = box.offsetWidth + &quot;px&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来是 javascript 执行以后开始计算整个布局，但是如果你每次都去获取，就会强制计算整个布局，然后返回数据，再一次循环，这个就是问题。</p><p>不仅仅是我这种操作会触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function logBoxHeight() &#123;</span><br><span class="line">  box.classList.add(&#x27;super-big&#x27;);</span><br><span class="line"></span><br><span class="line">  // Gets the height of the box in pixels</span><br><span class="line">  // and logs it out.</span><br><span class="line">  console.log(box.offsetHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以javascript获取属性需要谨慎, 前面如果有样式修改，那么再获取就会触发。</p><h5 id="05-03-善用css3硬加加速"><a href="#05-03-善用css3硬加加速" class="headerlink" title="05.03 善用css3硬加加速"></a>05.03 善用css3硬加加速</h5><p>简单说就是移动使用transform，来代替top，left。<br>别用visibility，使用opacity。<br>如果要写动画，多用可以触发gpu加速的</p><ul><li>transform</li><li>opacity</li><li>filters</li><li>Will-change</li></ul><h5 id="05-04-requestAnimationFrame"><a href="#05-04-requestAnimationFrame" class="headerlink" title="05.04 requestAnimationFrame"></a>05.04 requestAnimationFrame</h5><p><code>window.requestAnimationFrame()</code> 是一个用于执行动画的 Web API 方法。它接受一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前被调用。</p><h3 id="06-总结"><a href="#06-总结" class="headerlink" title="06. 总结"></a>06. 总结</h3><p>这里弄清楚了回流和重绘的基本概念，为什么要知道这些概念，从而更好的去提升性能，特别是在一些关键的页面上。</p><p>只是现在大家都用框架了，框架帮你做了大部分的事情。</p><h3 id="07-引用"><a href="#07-引用" class="headerlink" title="07. 引用"></a>07. 引用</h3><p><a href="https://blog.csdn.net/JHXL_/article/details/124046715">一文教会你何为重绘、回流？</a><br><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> css </tag>
            
            <tag> javascript </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 重绘 </tag>
            
            <tag> 回流 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 垂直居中方案</title>
      <link href="/2023/07/03/Implementation_Methods_for_Horizontal_and_Vertical_Centering/"/>
      <url>/2023/07/03/Implementation_Methods_for_Horizontal_and_Vertical_Centering/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>一般方案上来说很多。</p><ol><li>flex</li><li>grid</li><li>table</li><li>absolute</li></ol><h3 id="01-flex-基本知识"><a href="#01-flex-基本知识" class="headerlink" title="01. flex 基本知识"></a>01. flex 基本知识</h3><p>做这个之前需要先简单知道一下 flex 是做什么的，阮一峰的那一篇就挺好。</p><p><a href="/img/bg2015071004.png" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/img/bg2015071004.png" alt="alt text"></a></p><blockquote><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p></blockquote><p>这个是基本概念，由这些点来控制 flex 布局，接下来就是基本的属性</p><ul><li>flex-direction 方向，main axis &amp; cross axis 切换</li><li>flex-wrap 控制换行</li><li>flex-flow 前两个的简写</li><li>justify-content 定义了项目在主轴上的对齐方式。</li><li>align-items 交叉轴的对齐方式</li><li>align-content 多根轴线的对齐方式</li></ul><p>在这个基础只上，就基本理解了, flex 运作方式</p><p><code>display:flex</code> 声明容器布局方式，他按照从左到又一次排列，你可以根据属性来修改主轴，以及轴的对齐方式。</p><p>上面的都是对容器进行设置，除此之外，我们还可以设置以下属性。</p><ul><li>order 设置优先级，用于排序</li><li>flex-grow 可以放大，原本每个单元格都是1, 你可以单独设置他</li><li>flex-shrink 缩小的比例</li><li>flex-basis</li><li>flex 上面的简写</li><li>align-self 单独设置对齐方式，一般用不到，你要玩花活的时候就需要了</li></ul><h3 id="02-flex-垂直居中"><a href="#02-flex-垂直居中" class="headerlink" title="02. flex 垂直居中"></a>02. flex 垂直居中</h3><p>在上面的基础之上，就可以知道如何写了</p><ol><li>display: flex</li><li>设置交叉轴对齐方式居中</li><li>设置水平轴对齐方式居中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   &lt;style&gt;</span><br><span class="line">     .box &#123;</span><br><span class="line">       display: flex;</span><br><span class="line">       align-items: center;</span><br><span class="line">       justify-content: center;</span><br><span class="line">       width: 500px;</span><br><span class="line">       height: 500px;</span><br><span class="line">       border: 1px black solid;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     .item &#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;item&quot;&gt;a&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>就完成了。</p><h3 id="03-grid-布局基本知识"><a href="#03-grid-布局基本知识" class="headerlink" title="03. grid 布局基本知识"></a>03. grid 布局基本知识</h3><p>grid 的概念和 flex 区别很大，flex只关心 item, grid 是在于 row 和 column,</p><ul><li>grid-template-columns 指定每一列的列宽</li><li>grid-template-rows 指定每一行的行高</li><li>repeat 重复，不用每个都写</li><li>auto-fill 自动计算，类似于自动换行，这个是针对于 repeat(个数, 宽度)</li><li>fr 百分比</li><li>auto 自行决定宽度</li><li>grid-row-gap 行间距</li><li>grid-column-gap 列间距</li><li>grid-gap 上面两位集合</li><li>grid-template-areas 合并单元格所用。</li><li>grid-auto-flow 先行后列，还是先列后行</li><li>justify-items item内部水平位置</li><li>align-items item内部垂直位置</li><li>place-items 上面两个集合</li><li>justify-content item本身对于容器的水平位置</li><li>align-content item本身对于容器的垂直位置</li><li>place-content 上面两个集合</li><li>grid-auto-columns 设置额外网格打小</li><li>grid-auto-rows</li></ul><p>这里就很明确了，区别。</p><p>一个是一维，一个是二维。grid 明显更适合布局，然而flex更适合局部的布局。</p><h3 id="04-grid-垂直居中"><a href="#04-grid-垂直居中" class="headerlink" title="04. grid 垂直居中"></a>04. grid 垂直居中</h3><p>如果只是垂直居中的话很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 100px;</span><br><span class="line">grid-template-rows: 100px;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理都一样。</p><h3 id="05-table"><a href="#05-table" class="headerlink" title="05. table"></a>05. table</h3><p>其实就是使用 td 的 <code>vertical-align: middle &amp; text-align: center</code>.</p><p>这里需要知道一个概念 重绘 和 回流, 这个概念如果要讲清楚，需要从浏览器加载过程说起。</p><p>简单说，就是</p><blockquote><p>重绘（Repaint）：当元素的样式发生改变，但不影响其布局时，浏览器会执行重绘操作。重绘意味着浏览器会重新绘制元素的可视部分，以反映新的样式，但并不会影响元素的大小和位置。重绘操作比回流操作更加轻量级，对性能影响较小。</p><p>回流（Reflow）：当页面的布局发生改变，例如元素的尺寸、位置、显示&#x2F;隐藏状态等改变时，浏览器会执行回流操作。回流会重新计算并应用所有受影响元素的几何属性，然后重新排列页面中的元素。回流操作相对较为昂贵，会引起页面重新布局，对性能有较大的影响。</p></blockquote><p>也就是说，当你更改一个元素的宽高，或者背景颜色都可能触发，关键是 table 特别容易触发。</p><blockquote><p>table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一</p></blockquote><p>这是table我查到的问题，但是现代浏览器优化做的很好，并且怎么去使用table，比如包含大量的嵌套或跨行&#x2F;跨列的单元格时确实很复杂，确实会计算很多。</p><p>但是如果你通过其他方式去实现，比如 grid 或者 flex，在这种复杂度下，是否性能会比table好，这个我没有做过测试，但是我觉得很难说。</p><p>另外，如果只是简单的为了居中 <code>display:table</code> 也是一种方案。</p><h3 id="06-absolute"><a href="#06-absolute" class="headerlink" title="06. absolute"></a>06. absolute</h3><p>这个比较简单，就是说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.centered &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式主要点在于 <code> transform: translate(-50%, -50%);</code> 上。</p><p>top &amp; left 计算的是父结点，所以是300px，如果再加上元素本身高和宽，那么就不是正确的。</p><p>但是加上了 transform: translate，这里的百分比是根据当前元素计算的，这个移动就能保证居中</p><h3 id="07-总结"><a href="#07-总结" class="headerlink" title="07. 总结"></a>07. 总结</h3><p>这里记录了4种垂直居中的方案, 如果在没有浏览器兼容性问题的情况下还是使用 flex，因为他基本没有什么缺点。</p><p>使用绝对定位是需要确定父级高度的。而且需要设置容器的定位属性，可能会对其他布局属性产生影响。</p><p>使用 display:table,对于一些特殊布局要求可能不适用。</p><h3 id="08-引用"><a href="#08-引用" class="headerlink" title="08. 引用"></a>08. 引用</h3><ul><li><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></li><li><a href="https://github.com/Coffcer/flex-layout">flex-layout</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li><li><a href="https://www.duidaima.com/Group/Topic/CSS/9504">CSS布局中Grid 和Flex 该用哪个比较好？</a></li><li><a href="https://blog.csdn.net/JHXL_/article/details/124046715">一文教会你何为重绘、回流？</a></li><li><a href="https://blog.csdn.net/chunxiaqiudong5/article/details/104049484">CSS 变形(CSS3) transform</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> css </tag>
            
            <tag> flex </tag>
            
            <tag> grid </tag>
            
            <tag> table </tag>
            
            <tag> transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IFC 布局模型</title>
      <link href="/2023/07/03/IFC/"/>
      <url>/2023/07/03/IFC/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>官方解释</p><blockquote><p>An inline formatting context is a formatting context that contains inline-level boxes. It is used to determine the layout for the inline-level boxes and their relationships with the line boxes they participate in.</p></blockquote><p>简单来说，IFC 是一种用于确定行内元素的布局和与所在行盒子之间关系的渲染上下文。它定义了行内元素如何排列、如何处理文本换行和溢出等问题，同时还控制了行内元素与周围元素之间的间距和对齐方式。</p><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h3><ul><li>行内元素在 IFC 中从左到右排列，直到占满一行，然后换行继续排列。</li><li>IFC 中的元素在垂直方向上以基线对齐（默认情况下）。</li><li>IFC 的宽度由其包含的行内元素的宽度决定，不会超出其父容器的宽度。</li><li>IFC 中的元素可以通过设置 vertical-align 属性来调整垂直对齐方式。</li><li>IFC 中的元素可以通过设置 text-align 属性来调整水平对齐方式。</li></ul><h3 id="3-line-box"><a href="#3-line-box" class="headerlink" title="3. line-box"></a>3. line-box</h3><p>这里有一个line-box的概念，在形成 IFC 以后，就有这个玩意儿。</p><blockquote><p>在IFC中，盒子水平放置，一个接着一个，从包含块的顶部开始。水平margins,borders,和padding在这些盒子中被平分。这些盒子也许通过不同的方式进行对齐:他们的地步和顶部也许被对齐，或者通过文字的基线进行对齐。矩形区域包含着来自一行的盒子叫做line box。</p></blockquote><p>有多少个line box，取决于你 IFC 长度和显示的宽度。</p><blockquote><p>line box的宽度由浮动情况和它的包含块决定。line box的高度由line-height的计算结果决定。</p><p>一个line box总是足够高对于包含在它内的所有盒子。然后，它也许比包含在它内最高的盒子高。(比如，盒子对齐导致基线提高了)。当盒子B的高度比包含它的line box的高度低，在line box内的B的垂值对齐线通过’vertical align’属性决定。当几个行内级盒子在一个单独的line box内不能很好的水平放置，则他们被分配成了2个或者更多的垂直重叠的line boxs.因此,一个段落是很多个line boxs的垂直叠加。Line boxs被叠加没有垂直方向上的分离(特殊情况除外)，并且他们也不重叠。</p></blockquote><p>这里是直接翻译官方的英文</p><ol><li>高度自适应：line box 的高度会根据行内元素的高度来自适应，以包含所有行内元素的内容。行内元素可以具有不同的高度，但 line box 的高度会根据最高的行内元素来确定。</li><li>垂直对齐：line box 会根据基线（baseline）对齐行内元素。行内元素的基线可以是不同的，但 line box 会根据这些基线来对齐它们。这可以实现行内元素的垂直对齐。</li><li>水平布局：line box 内的行内元素会水平排列。当 line box 的宽度不足以容纳所有行内元素时，会根据相应的排列规则进行换行。</li><li>边界计算：line box 的边界由其中的行内元素决定。line box 的顶部和底部边界会根据行内元素的上边界和下边界来计算。</li><li>内联盒子集合：line box 实际上是一组包含行内盒子（inline boxes）的矩形框，每个行内盒子对应一个行内元素。行内盒子会根据其具体的尺寸和位置排列在 line box 内部。</li></ol><p>这个比较抽象，换成一个实际的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EM &#123;</span><br><span class="line">padding: 10px;</span><br><span class="line">margin: 1em;</span><br><span class="line">border-width: medium;</span><br><span class="line">border-style: dashed;</span><br><span class="line">line-height: 2.4em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;Several &lt;em&gt;emphasized words&lt;/em&gt; appear here.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这里就有3个 <code>line box</code>.</p><p>![alt text](&#x2F;img&#x2F;截图 2023-06-05 16-41-10.png)</p><p>其中两个匿名，一个 em， 其实我刚才是很疑惑为什么要知道这个？然后资料中给了一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.dib-baseline &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 150px;</span><br><span class="line">height: 150px;</span><br><span class="line">border: 1px solid #cad5eb;</span><br><span class="line">background-color: #f0f3f9;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span class=&quot;dib-baseline&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;dib-baseline&quot;&gt;x-baseline&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我薄弱的知识中道理上去说，应该是并排的，其实不是。</p><p>![alt text](&#x2F;img&#x2F;截图 2023-06-05 16-45-18.png)</p><p>结果是这个样子。</p><blockquote><p>没有内联元素的框框：<br>当容器没有内联元素时，基线会被设置为容器的下边缘（即下边框下面的位置）。这是因为在没有内联元素的情况下，基线的位置没有具体的参考物，因此默认被设置为容器的下边缘。</p><p>有字符的框框：<br>当容器内有字符作为内联元素时，基线会根据字符的具体形状和字体特性进行计算，并被设置为字符的基线位置。基线的位置通常是字符底部与字符主要部分的对齐线，用于对齐字符的位置和其他行内元素。</p></blockquote><p>有一个中心线的概念，也就是 <code>baseline</code>, ifc 容器基于 baseline 进行定位。</p><p>所以出现了这种情况，当容器没有内联元素时，基线会被设置为容器的下边缘，当容器内有字符作为内联元素时，基于字体作为 baseline 位置。</p><h3 id="4-line-线"><a href="#4-line-线" class="headerlink" title="4. line 线"></a>4. line 线</h3><p><a href="/img/css-ifc-baseline.jpg" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/img/css-ifc-baseline.jpg" alt="alt text"></a></p><p>理论上我们都是通过默认的基线水平排列，就是baseline这条线， top, middle, bottom 通过 vertical-align 设置。</p><p>那么这个时候我就产生了一个疑问，怎么影响 baseline呢？</p><p>首先 baseline 和 middle line 是不一样的，如果字体越大差距越大，所以想要完全居中，直接 <code>font-size:0</code> 就可以了。</p><p>同样，图片的 bottonline 和 baseline，你要么设置为 vertical-align 为 bottom, 或者还是设置 <code>font-szie：0</code> 线自然就重合了。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>ifc 是一个顺序排列的模型，水平顺序排列，简单用就 <code>text-align</code>, 水平方向使用 margin, padding 就ok了。</p><p>如果遇到问题，还是需要知道line box 和 line 这个概念。</p><h3 id="6-资料"><a href="#6-资料" class="headerlink" title="6. 资料"></a>6. 资料</h3><ul><li><a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">CSS深入理解vertical-align和line-height的基友关系</a></li><li><a href="https://blog.csdn.net/weixin_41192489/article/details/120197275">css 格式化上下文布局——BFC和IFC【详解】</a></li><li><a href="https://segmentfault.com/a/1190000004466536">[译]:BFC与IFC</a></li><li><a href="https://mengsixing.github.io/blog/css-ifc.html#css-%E5%86%85%E8%81%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87">CSS IFC 总结</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> css </tag>
            
            <tag> ifc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC 布局模型</title>
      <link href="/2023/07/03/BFC/"/>
      <url>/2023/07/03/BFC/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id=""><a href="#" class="headerlink" title=""></a></h1><blockquote><p>BFC (块级格式化上下文) 是 CSS 中的一种布局模型，用于控制块级元素的布局和渲染规则。BFC 是一个独立的渲染区域，其中的元素按照一定的规则进行布局，不会影响到外部的布局。</p><p>IFC (行内格式化上下文)：IFC 是行内元素的布局模型，用于控制行内元素的布局和渲染规则。IFC 中的行内元素按照一定的规则进行排列，可以通过设置 display: inline-block 或使用表格布局等方式创建 IFC。</p><p>Flexbox (弹性盒布局)：Flexbox 是一种基于主轴和交叉轴的布局模型，用于创建灵活的盒子布局。通过使用 display: flex 属性，可以将容器元素变为一个 Flexbox 容器，子元素可以通过设置各种弹性属性来实现自适应的布局。</p><p>Grid (网格布局)：Grid 是一种二维网格布局模型，用于将页面划分为行和列，并以网格单元格的形式对元素进行布局。通过使用 display: grid 属性，可以将容器元素变为一个 Grid 容器，可以使用各种网格相关的属性来控制元素的位置和尺寸。</p><p>Float (浮动布局)：Float 是一种早期的布局模型，通过设置元素的 float 属性，使元素浮动到指定的方向，其他元素会环绕在其周围。Float 布局常用于创建多列布局和实现文字环绕效果，但也会带来一些布局上的问题，如布局塌陷等。</p><p>Table (表格布局)：使用 HTML 表格标签  table 及其相关标签 tr、td 等进行布局。表格布局适用于需要呈现表格结构的场景，但在其他布局需求上较为有限，不推荐将表格布局用于非表格结构的页面布局。</p></blockquote><p>各种布局模型，今天要学习的是 BFC 模型。</p><h3 id="1-什么是BFC模型"><a href="#1-什么是BFC模型" class="headerlink" title="1. 什么是BFC模型"></a>1. 什么是BFC模型</h3><blockquote><p>BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器，用于控制块级元素的布局和渲染规则</p></blockquote><h3 id="2-BFC-形成的条件"><a href="#2-BFC-形成的条件" class="headerlink" title="2. BFC 形成的条件"></a>2. BFC 形成的条件</h3><p>根元素（即 html 元素）或包含它的元素。<br>浮动元素（元素的 float 属性不为 none）。<br>绝对定位元素（元素的 position 属性为 absolute 或 fixed）。<br>行内块元素（元素的 display 属性为 inline-block）。<br>表格单元格（元素的 display 属性为 table-cell）。<br>表格标题（元素的 display 属性为 table-caption）。<br>包含了以上任意一个条件的元素的祖先元素，且该祖先元素的 overflow 属性不为 visible。</p><h3 id="3-解决边界重叠"><a href="#3-解决边界重叠" class="headerlink" title="3. 解决边界重叠"></a>3. 解决边界重叠</h3><blockquote><p>边界重叠是由于 CSS 盒模型中的外边距合并（margin collapsing）规则所致。当两个垂直相邻的块级元素具有相邻的外边距时，它们的外边距会合并成一个外边距，导致它们之间的间距不是简单地相加，而是取其中较大的外边距值</p></blockquote><p><a href="https://developer.aliyun.com/article/605570#slide-2">CSS-盒子模型-边距合并</a></p><p>这里提供了很多边距重叠的案例，最简单的解法就是 <code>overflow:hidden</code>, 形成一个 BFC</p><h3 id="4-解决浮动问题"><a href="#4-解决浮动问题" class="headerlink" title="4. 解决浮动问题"></a>4. 解决浮动问题</h3><p>其实这个问题现在没什么意义了，现在很少还有布局采用浮动布局了，浮动布局会出现父元素会发生高度塌陷，无法正常包裹浮动元素的问题，你可以在后面清除浮动 <code>clear:both</code>, 也可以父元素 BFC，<code>overflow: hidden</code></p><p>当然，文字环绕不知道还使用 float? </p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>也就是说，bfc会创建一个稳定的区域，区域内不会受到外部影响，外部也不会影响内部，从而避免一些浏览器特性导致的问题，最常用的就是 <code>overflow:hidden</code>.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> css </tag>
            
            <tag> bfc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要用 void 0 代替 undefined</title>
      <link href="/2023/07/03/undefined_void_0/"/>
      <url>/2023/07/03/undefined_void_0/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="为什么要用-void-0-代替-undefined"><a href="#为什么要用-void-0-代替-undefined" class="headerlink" title="为什么要用 void 0 代替 undefined"></a>为什么要用 void 0 代替 undefined</h1><p>在看 Vue3.x 源码的时候，发现关于 undefined 赋值都是使用 Void 0，觉得很奇怪，于是学习了一下。</p><h3 id="01-什么是-globalThis"><a href="#01-什么是-globalThis" class="headerlink" title="01. 什么是 globalThis?"></a>01. 什么是 globalThis?</h3><blockquote><p>globalThis 是一个全局对象，它提供了在任何执行上下文中都可用的标准全局对象的访问方式。在 Web 浏览器中，全局对象可能有多种不同的名称，比如在浏览器窗口中，全局对象通常是 window，而在 Web Worker 中，全局对象是 self。而在 Node.js 中，全局对象是 global。globalThis 提供了一种跨平台的方式来访问全局对象，它可以在任何平台上使用，而不需要考虑全局对象的名称。</p></blockquote><h3 id="02-undefined-是什么？"><a href="#02-undefined-是什么？" class="headerlink" title="02. undefined 是什么？"></a>02. undefined 是什么？</h3><blockquote><p>undefined 是全局对象的属性——即全局作用域的变量。</p></blockquote><p>它的语义表示，未被定义的值，它是一种原始数据类型。</p><blockquote><p>表示 no value（无值）——也无对象也无值</p></blockquote><p>也就是说, undefined 是一种数据类型，我们平时的使用方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>就是将 undefined 原始值赋值给变量。</p><p>我们直接调用 <code>undefined</code> 或者不赋值，其实等于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = globalThis.<span class="property">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> b = globalThis.<span class="property">undefined</span>;</span><br></pre></td></tr></table></figure><p>也就是全局对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">undefined</span> === <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>总结一下就是，<code>undefined</code> 表示一种原始值，直接在 <code>javascript</code> 写 <code>undefined</code> 就是表示 <code>globalThis.undefined</code>, 同时 <code>undefined</code> 也可以作为变量名.</p><h3 id="03-undefined-有什么问题？"><a href="#03-undefined-有什么问题？" class="headerlink" title="03. undefined 有什么问题？"></a>03. undefined 有什么问题？</h3><p>问题就在于 <code>undefined</code> 也可以作为变量名，因为我们平时完全是把 <code>undefined</code> 当作字面量来使用的，拿 <code>null</code> 来说， <code>null</code> 就是字面量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">null</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>他会直接告诉你</p><blockquote><p>Variable declaration not allowed at this location.ts(1440)</p></blockquote><p>然而 <code>undefined</code> 不会.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>他娘的是可以通过的…</p><p>所以问题就在这里了，你无法确定 <code>undefined</code> 中是否是 <code>undefined</code> 的原始值, </p><p>它可能是原始对象，可能是局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="literal">undefined</span>, cat = <span class="literal">undefined</span>] = [<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>); <span class="comment">//test</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat); <span class="comment">//test</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalThis.<span class="property">undefined</span>) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>还好它不能直接赋值 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>) <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">let</span> desc = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(globalThis, <span class="string">`undefined`</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(desc) <span class="comment">// &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>但是也不会报错。</p><h3 id="04-void-关键字"><a href="#04-void-关键字" class="headerlink" title="04. void 关键字"></a>04. void 关键字</h3><blockquote><p>void 是 JavaScript 中的一个关键字，用于执行一个表达式，但不返回任何值。在语法上，它通常被用于在一个链接或按钮的 href 或 onclick 属性中，以避免浏览器在执行链接或按钮操作时跳转到新的页面或刷新当前页面。</p><p>在使用 void 时，可以将其后面跟一个 JavaScript 表达式。该表达式将被执行，但返回值将被忽略，并且 void 运算符的结果将始终是 undefined。</p></blockquote><p>也就是说，不管你右边是什么，返回什么，加 <code>void</code> 就返回 <code>undefined</code> 原始值。</p><h3 id="05-为什么要用-void-0-代替-undefined"><a href="#05-为什么要用-void-0-代替-undefined" class="headerlink" title="05. 为什么要用 void 0 代替 undefined"></a>05. 为什么要用 void 0 代替 undefined</h3><p>基于上面说的，现在就明白了为什么要用 <code>void 0</code> 代替 <code>undefined</code>, 就是因为 <code>undefined</code> 可以是变量名。</p><p>使用 <code>void 0</code> 可以保证是 <code>undefined</code> 原始值。</p><p>另外，使用 <code>globalThis.undefined</code> 也可以获取原始值，只是它要稍微长一点，本质上没区别。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> undefined </tag>
            
            <tag> void 0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 类型判断方法总结</title>
      <link href="/2023/07/03/js_type_check/"/>
      <url>/2023/07/03/js_type_check/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>常用的判断类型的方式如下</p><ul><li>typeof</li><li>instanceof</li><li>Object.prototype.toString.call</li><li>Array.isArray</li><li>&#x3D;&#x3D;</li><li>&#x3D;&#x3D;&#x3D;</li><li>Object.is</li></ul><h3 id="1-x3D-x3D"><a href="#1-x3D-x3D" class="headerlink" title="1. &#x3D;&#x3D;"></a>1. &#x3D;&#x3D;</h3><p>&#x3D;&#x3D; 有一个类型转换的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>;  <span class="comment">// true，进行类型转换后，字符串 &#x27;1&#x27; 被转换为数字 1，然后比较相等性</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>;  <span class="comment">// true，布尔值 true 被转换为数字 1，然后比较相等性</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>;  <span class="comment">// true，因为它们被视为相等的特殊值</span></span><br></pre></td></tr></table></figure><p>就是隐式转换，所以可能会有意想不到的结果。</p><p>转换以后对比两个值是否相等，这个是最不推荐的，首先特殊情况很多，还会进行类型转换再来对比，而且只能处理基础类型.</p><h3 id="2-x3D-x3D-x3D"><a href="#2-x3D-x3D-x3D" class="headerlink" title="2. &#x3D;&#x3D;&#x3D;"></a>2. &#x3D;&#x3D;&#x3D;</h3><p>它比 <code>==</code> 好一点的是，他不会进行类型转换，也就是类型相同且值相同的情况下，返回 <code>true</code>.</p><p>但是他的缺点依然，就是只能处理基础类型，但是他也有用出。</p><h3 id="3-Object-is"><a href="#3-Object-is" class="headerlink" title="3. Object.is"></a>3. Object.is</h3><p>上面 <code>===</code> 有一个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN //false</span><br></pre></td></tr></table></figure><p>然而在 Object.is 中相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.is(+0, -0); //false</span><br><span class="line">Object.is(NaN, NaN); //false</span><br></pre></td></tr></table></figure><p>其他结果一致。</p><h3 id="4-typeof"><a href="#4-typeof" class="headerlink" title="4. typeof"></a>4. typeof</h3><p>typeof 能做的很明确，迅速确定基础类型，比如这里我就是需要 string or number，直接用就好了。</p><p>缺点就是可以区分的类型太少了，</p><blockquote><p>typeof 运算符通过检查变量的内部标签来确定其类型。不同类型的变量在内部被赋予了不同的标签</p></blockquote><p>但是这个标签又不对外暴露。</p><p>他不能判断复杂类型，比如 new String(), Date, Null 等等，他都返回 <code>object</code>, 而且会混淆 function 和 正则。</p><p>所以只能用他判断基础类型，甚至连 function 都不行.</p><p>还有很多问题，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof null === &quot;object&quot;;</span><br><span class="line">typeof undeclaredVariable; // &quot;undefined&quot;</span><br><span class="line">typeof document.all === &#x27;undefined&#x27;;</span><br></pre></td></tr></table></figure><p>除了判断某些确定的基础类型，不建议使用</p><h3 id="5-instanceof"><a href="#5-instanceof" class="headerlink" title="5. instanceof"></a>5. instanceof</h3><p>他的逻辑本质上是不停的网上寻找匹配的原型或者构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><p>按照这个思路，基础类型是无法匹配的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>)) <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>依照这个思路，我们还可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>); </span><br></pre></td></tr></table></figure><h3 id="6-自己写一个-instanceof"><a href="#6-自己写一个-instanceof" class="headerlink" title="6. 自己写一个 instanceof"></a>6. 自己写一个 instanceof</h3><p>核心就是不停的往上查，写一个递归.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj, type</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> prototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"><span class="keyword">if</span>(prototype === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(prototype.<span class="property">constructor</span> === type) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">myInstanceof</span>(prototype, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Object-prototype-toString-call"><a href="#7-Object-prototype-toString-call" class="headerlink" title="7. Object.prototype.toString.call"></a>7. Object.prototype.toString.call</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</a></p><blockquote><p>Object.prototype.toString 是 Object 类原型上的一个方法，用于返回一个表示对象类型的字符串。当我们调用 Object.prototype.toString 方法时，它会检查调用者的内部标签，并返回相应的字符串表示对象类型。</p></blockquote><p>这个就很奇怪了，既然 typeof 也是调用内部的标签，为什么 typeof 不行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// [object Date]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">String</span>()); <span class="comment">// [object String]</span></span><br><span class="line"><span class="comment">// Math has its Symbol.toStringTag</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line"></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure><p>需要提出的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&#x27;1&#x27;) //[object String]</span><br><span class="line">Object.prototype.toString.call(new String(&#x27;1&#x27;)) //[object String]</span><br></pre></td></tr></table></figure><p>这个是没有区分的，但是实际上是有区别的。</p><p>还有一个问题是</p><blockquote><p>以这种方式使用 toString() 是不可靠的；对象可以通过定义 Symbol.toStringTag 属性来更改 Object.prototype.toString() 的行为，从而导致意想不到的结果</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myDate = new Date();</span><br><span class="line">Object.prototype.toString.call(myDate); // [object Date]</span><br><span class="line"></span><br><span class="line">myDate[Symbol.toStringTag] = &quot;myDate&quot;;</span><br><span class="line">Object.prototype.toString.call(myDate); // [object myDate]</span><br><span class="line"></span><br><span class="line">Date.prototype[Symbol.toStringTag] = &quot;prototype polluted&quot;;</span><br><span class="line">Object.prototype.toString.call(new Date()); // [object prototype polluted]</span><br></pre></td></tr></table></figure><h3 id="8-Array-isArray"><a href="#8-Array-isArray" class="headerlink" title="8. Array.isArray"></a>8. Array.isArray</h3><ul><li>首先，它会使用 Object.prototype.toString 方法来获取值的内部标签。</li><li>然后，它会将内部标签与字符串 “[object Array]” 进行比较。</li><li>如果内部标签与 “[object Array]” 匹配，即表示该值为数组，返回 true。</li><li>如果内部标签与 “[object Array]” 不匹配，即表示该值不是数组，返回 false。</li></ul><p>原理上应该和 Object.prototype.toString.call 一样。</p><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h3><p>还是要 typoef 和 Object.prototype.toString.call 联合使用才能真正很好的解决问题。</p><p>instanceof 真的可以退休了。</p><h3 id="10-资料"><a href="#10-资料" class="headerlink" title="10. 资料"></a>10. 资料</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">Object.prototype.toString()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> instanceof </tag>
            
            <tag> Object.is </tag>
            
            <tag> isArray </tag>
            
            <tag> toString.call </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript new 做了什么？</title>
      <link href="/2023/07/03/js_new/"/>
      <url>/2023/07/03/js_new/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="new-做了什么？"><a href="#new-做了什么？" class="headerlink" title="new 做了什么？"></a>new 做了什么？</h1><p>经常使用 new</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tommy&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><p>那么 new 关键字做了什么 ?</p><ol><li>创建一个空对象：使用 new 关键字创建一个新的空对象，该对象将成为实例化的对象。</li><li>设置原型链连接：将新创建的对象的原型链接到构造函数的原型对象（Constructor.prototype）上。这样，实例对象就可以访问构造函数原型对象上定义的属性和方法。</li><li>绑定 this 上下文：将构造函数的 this 上下文绑定到新创建的对象上，使构造函数内部的代码可以访问和操作新对象。</li><li>执行构造函数代码：执行构造函数的代码块，将属性和方法添加到新创建的对象上。在构造函数中可以使用 this 关键字引用新对象，并对其进行初始化。</li><li>返回新对象：如果构造函数没有显式返回其他对象，那么 new 表达式将隐式返回新创建的对象实例。这样，通过 new 创建的对象就可以在代码中使用，并引用该实例。</li></ol><p>按照这个逻辑，我们自己写一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">func, ...params</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的对象，并且把原型链副浅拷贝到新的对象中</span></span><br><span class="line"><span class="comment">//func.prototype </span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//调用 func, 并且以 obj为this.</span></span><br><span class="line"><span class="keyword">const</span> result = func.<span class="title function_">apply</span>(obj, params);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = result || obj;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也就说明了原理。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器事件循环</title>
      <link href="/2023/07/03/eventLoop/"/>
      <url>/2023/07/03/eventLoop/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="1-V8引擎"><a href="#1-V8引擎" class="headerlink" title="1. V8引擎"></a>1. V8引擎</h3><p>当我们有段 javascript 是如何执行的？</p><p>当浏览器解析到一段javascript，会将 javascript 交给 js引擎，引擎去做一系列事情。</p><p>词法分析，语法分析，编译，优化之类的，但是如果要关联到我们常用的js，非常重要的就是，堆和栈，下面是堆栈的简单解释。</p><blockquote><p>执行栈（Execution Stack）：</p><p>执行栈是一种后进先出（LIFO）的数据结构，也被称为调用栈（Call Stack）。它用于跟踪函数的调用顺序和执行状态。每当函数被调用时，它的执行上下文（Execution Context）会被添加到执行栈的顶部。执行栈中的顶部始终是当前正在执行的函数。当函数执行完毕后，它的执行上下文会被从执行栈中移除，控制权交回给调用该函数的上下文。<br>堆（Heap）：</p><p>堆是用于动态分配内存的区域，用于存储复杂的数据结构，如对象和数组。JavaScript中的对象和数组都存储在堆中。</p></blockquote><p>文章中提到了一个概念，就是</p><blockquote><p>你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后卡住，</p><h3 id="2-什么是js线程和渲染线程"><a href="#2-什么是js线程和渲染线程" class="headerlink" title="2. 什么是js线程和渲染线程"></a>2. 什么是js线程和渲染线程</h3><blockquote><p>JavaScript线程是用于执行JavaScript代码的线程。它负责解析和执行网页中的JavaScript代码，并处理与之相关的事件和操作。JavaScript线程是单线程的，意味着它一次只能执行一个任务。当浏览器在渲染页面时，JavaScript线程会被占用，执行JavaScript代码可能会阻塞其他任务的执行，包括用户界面的响应。这就是为什么在编写JavaScript代码时需要注意避免长时间运行的操作，以免阻塞用户界面的原因。</p><p>渲染线程是负责将HTML、CSS和JavaScript转换为可视化页面的线程。它从浏览器的渲染引擎中派生出来，并执行一系列操作，包括解析HTML和CSS、构建DOM树、计算布局和绘制页面等。渲染线程通常是多线程的，它可以将工作分配给不同的子线程来提高性能和响应性。</p></blockquote><p>也就是说一个是执行 javascript 代码，一个是渲染线程</p><p>两个都是单线程，只是渲染线程可能会把部分代码交给gpu来做渲染。</p><h3 id="3-事件循环是怎么做的？"><a href="#3-事件循环是怎么做的？" class="headerlink" title="3. 事件循环是怎么做的？"></a>3. 事件循环是怎么做的？</h3><p>我最开始使用javascript的时候以为，是一个有时间线的队列，那个时间线必须去执行某个东西。。</p><ol><li>JavaScript 代码的执行从主线程开始，主线程负责执行同步的 JavaScript 代码。</li><li>当遇到异步操作（如定时器、网络请求、事件监听器等）时，异步操作被放置在任务队列（Task Queue）中，而不会立即执行。</li><li>当主线程上的同步代码执行完毕时，事件循环进入检查阶段。</li><li>事件循环检查任务队列是否有待执行的任务。如果任务队列中有任务，则将任务移出队列，并将其发送到主线程执行。</li><li>异步任务在主线程上执行，可能包括回调函数、Promise 的处理函数、定时器的回调等。</li><li>执行完异步任务后，事件循环再次进入检查阶段，重复步骤 4 和步骤 5。</li></ol><p>也就是说，先执行同步代码，遇到异步代码放进列队，等同步任务执行完成之后检查，发送到主线程，完成以后(继续检查，继续发送到主线程)</p><p>这个过程就叫做事件循环。</p><h3 id="4-setTimeout，网络请求是怎么做的？"><a href="#4-setTimeout，网络请求是怎么做的？" class="headerlink" title="4. setTimeout，网络请求是怎么做的？"></a>4. setTimeout，网络请求是怎么做的？</h3><p>我产生了一个疑问，如果进入了任务队列，那么时间到了，需要触发了，怎么做的？网络请求，是立刻发送？</p><p>异步任务，需要执行，那么是立刻执行，比如网络请求，比如Promise执行的部分，然后把剩余回调的部分加入任务列队。</p><p>通过事件循环检查是否应该执行，比如delay时间，比如异步是否完成。</p><p>然后推送到主线程。</p><p>这里就会想到一个问题, 也就是一个缺陷</p><p>因为目前的单线程做法，明显会导致一个问题。就是主线程阻塞以后，会影响其他异步任务，导致全面的阻塞。</p><p>也就是 setTimeout 不准确，异步完成之后并不执行，做一个简单的测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event</span></span><br><span class="line"><span class="keyword">const</span> startEvent = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`startEvent`</span>, startEvent);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> endEvent = ((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`endEvent`</span>, endEvent - startEvent); <span class="comment">//endEvent 27595</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`finish setTimout:`</span>, (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> b = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`finish for:`</span>, (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>());</span><br></pre></td></tr></table></figure><p>这个就是有延迟。</p><h3 id="5-为什么js是单线程？"><a href="#5-为什么js是单线程？" class="headerlink" title="5. 为什么js是单线程？"></a>5. 为什么js是单线程？</h3><p>在第四个节点，知道了单线程有一个缺点，然而多线程明显会解决这个问题，那么为什么不用多线程呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  myA.<span class="property">innerText</span> = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">setText</span>(), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">setText</span>(), <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">setText</span>(), <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>这是一个简单的模拟异步，分别1秒，2秒，3秒。 回调中写入新的内容。</p><p>我们想一想如果使用多线程会怎么样？</p><p>1秒 &#x3D;&gt; 调用回调 &#x3D;&gt; 操作dom<br>2秒 &#x3D;&gt; 调用回调 &#x3D;&gt; 操作dom<br>3秒 &#x3D;&gt; 调用回调 &#x3D;&gt; 操作dom</p><p>与主线程不相关，几个线程相互无关，看上去很美好。</p><p>但是实际上，可能互斥，因为4个线程，都会操作dom，导致页面的回流或者重绘，而且时间不一定会这么泾渭分明，完全可能导致冲突，从而提升页面的复杂度。</p><p>而且加锁这种情况下，虽然说是1秒，但是不一定会1秒能解决，从而导致其他线程阻塞。</p><p>说白了，之所以单线程，就是要保证操作 web api 的只有一个线程，而不是给线程加锁，导致程序复杂度陡增。</p><h3 id="6-微任务，宏任务"><a href="#6-微任务，宏任务" class="headerlink" title="6. 微任务，宏任务"></a>6. 微任务，宏任务</h3><p>刚才在第三条中说到，javascript基本执行的概念，就是一口气执行，然后把异步任务放入任务队列，然后逐条推送到主线程。</p><blockquote><p>事件循环中的任务队列可以分为不同的队列，包括宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。</p></blockquote><ul><li>宏任务队列包含了一些较为耗时的任务，例如 DOM 操作、网络请求等。每个宏任务在执行完毕后，事件循环才会去检查微任务队列。</li><li>微任务队列用于处理一些轻量级的任务，例如 Promise 的回调函数、MutationObserver 的回调等。微任务在每个宏任务执行结束后立即执行，确保它们在下一个宏任务之前被处理。</li></ul><p>我们首先要知道，哪些是微任务，哪些是宏任务</p><p><strong>微任务</strong></p><ul><li>Promise 回调函数（then, catch, finally）</li><li>MutationObserver 的回调函数</li><li>process.nextTick（仅限 Node.js 环境）</li><li>queueMicrotask 函数</li><li>Object.observe（已被废弃）</li></ul><p><strong>宏任务</strong></p><ul><li>setTimeout 和 setInterval 回调函数</li><li>I&#x2F;O 操作和网络请求（如 AJAX、fetch）</li><li>UI 渲染</li><li>requestAnimationFrame 回调函数</li><li>页面加载事件（DOMContentLoaded, load）</li><li>原生事件（如点击事件、键盘事件）</li><li>postMessage 和 MessageChannel</li><li>setImmediate（仅限 Node.js 环境）</li></ul><p>这里包含了大多数微任务和宏任务，但是不保证全部，因为我也没找到全部微任务和宏任务的连接。</p><p>也就是说，在检查队列任务中，还包含一些细节。</p><ol><li>当主线程上的代码执行完成后，事件循环会首先检查微任务队列。</li><li>如果微任务队列中有任务，事件循环会按照先进先出的顺序依次执行所有的微任务，直到微任务队列为空。这意味着微任务会在下一个宏任务之前执行。</li><li>当微任务队列为空后，事件循环会检查宏任务队列。</li><li>如果宏任务队列中有任务，事件循环会选择其中的一个任务，执行该任务的全部代码。</li><li>执行完当前选中的宏任务后，如果有必要，事件循环会再次检查微任务队列，重复步骤 2。</li><li>重复步骤 3~5，不断地从宏任务队列中选取任务并执行，直到宏任务队列和微任务队列都为空。</li></ol><p>也就是说，先检查微任务，在执行一个宏任务，再检查微任务，再执行一个宏任务。</p><p>这就是细节。</p><h3 id="7-第一题"><a href="#7-第一题" class="headerlink" title="7. 第一题"></a>7. 第一题</h3><p>我去网上找了面试题，来验证一下这一章的学习成果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>, promise1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>console.log(‘promise1’)</li><li>console.log(‘1’, promise1);</li><li>console.log(2);</li><li>console.log(‘start’)</li><li>console.log(3);</li><li>console.log(res)</li></ul><p>理论上是这样的，但是由于 promise1 并没有 resolve, reject，所以 console.log(3); 没有返回。</p><p>需要注意的是 Promise 里面的方式只立刻执行的，他不属于异步任务，就是V8引擎在执行的时候顺序执行的代码，比如你发起请求，他会立刻发起请求。</p><h3 id="8-第二题"><a href="#8-第二题" class="headerlink" title="8. 第二题"></a>8. 第二题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//微任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//微任务</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); <span class="comment">//直接执行</span></span><br></pre></td></tr></table></figure><ul><li>console.log(‘start’)</li><li>console.log(‘promise1’);</li><li>console.log(‘timer1’)</li><li>console.log(‘promise2’)</li><li>console.log(‘timer2’)</li></ul><p>看到没，并不复杂，你明白了原理以后，他的知识点就是不停的在微任务和宏任务之间转换，然后根据作用域，不停的执行。</p><h3 id="9-第三题"><a href="#9-第三题" class="headerlink" title="9. 第三题"></a>9. 第三题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">//执行</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//微任务</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) <span class="comment">//执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) <span class="comment">//执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>这道题增加了 <code>setTimeout</code> 时间。</p><ul><li>console.log(‘promise1’, promise1)</li><li>console.log(‘promise2’, promise2)</li><li>throw new Error(‘error!!!’)</li><li>console.log(‘promise1’, promise1)</li><li>console.log(‘promise2’, promise2)</li></ul><p>如果加入了 setTimout,还需要考虑这个执行的时间顺序</p><h3 id="9-第四题"><a href="#9-第四题" class="headerlink" title="9. 第四题"></a>9. 第四题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">//执行</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1里的内容&quot;</span>); <span class="comment">//执行</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//微任务</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1); <span class="comment">//执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2); <span class="comment">//执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//宏任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer2&quot;</span>); </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><ul><li>console.log(“promise1里的内容”);</li><li>console.log(“promise1”, promise1);</li><li>console.log(“promise2”, promise2);</li><li>throw new Error(“error!!!”);</li><li>console.log(“timer1”);</li><li>console.log(“timer2”); </li><li>console.log(“promise1”, promise1);</li><li>console.log(“promise2”, promise2);</li></ul><p>我这里有一个错误，就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer1&quot;</span>);</span><br></pre></td></tr></table></figure><p>我第一反应还是顺序执行，其实 <code>resolve(&quot;success&quot;);</code> 需要看做一个微任务。</p><p>所以步骤是 </p><ol><li>执行完所有的代码后</li><li>执行微任务 promise1.then(() &#x3D;&gt; …) 但是没有需要执行的</li><li>执行一个宏任务 promise1 下的 settimeout</li><li>优先执行顺序代码 console.log(“timer1”);</li><li>执行微任务 promise1.then(() &#x3D;&gt; {…});</li><li>执行宏任务 setTimeout(() &#x3D;&gt; {…}) 最后一个 setTimeout.</li></ol><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><p>这里我学到了，浏览器 javascript 执行的机制</p><p>顺序执行，遇到异步任务先放在列队中<br>执行完成以后进入循环 &#x3D;&gt; 查询微任务，执行所有微任务 &#x3D;&gt; 执行一个宏任务 &#x3D;&gt; 执行所有微任务 &#x3D;&gt; 执行一个宏任务(循环)</p><p>面试问这个再也没问题了。</p><h3 id="11-引用"><a href="#11-引用" class="headerlink" title="11. 引用"></a>11. 引用</h3><ul><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">event-loops</a></li><li><a href="https://juejin.cn/post/6844904087163502605">异步任务(微任务、宏任务)，你学会了吗？还有4道面试题</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 时间循环 </tag>
            
            <tag> eventloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝方法优缺点总结</title>
      <link href="/2023/07/03/deepClone/"/>
      <url>/2023/07/03/deepClone/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="深度拷贝"><a href="#深度拷贝" class="headerlink" title="深度拷贝"></a>深度拷贝</h1><p>一般来说，如果需要深度拷贝，网上会推荐三种方式。</p><ol><li>JSON.stringify(obj)</li><li>_.cloneDeep(value)</li><li>自己写深度遍历</li></ol><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><blockquote><p>首先，将要被序列化的对象（称为目标对象）传递给函数。JSON.stringify()<br>JSON.stringify()函数检查目标对象的数据类型。 如果目标对象是一个简单类型（例如字符串、数字、布尔值、null、undefined），则它会直接返回该值的JSON表示。<br>如果目标对象是一个数组，则会递归地调用自身，对每个数组元素进行序列化，并将结果拼接成一个JSON数组。JSON.stringify()<br>如果目标对象是一个对象，则会递归地调用自身，对每个对象属性进行序列化，并将结果拼接成一个JSON对象。JSON.stringify()<br>在序列化对象属性时，会跳过属性值为函数或undefined的属性，并在其他情况下将属性值转换为JSON格式的字符串。JSON.stringify()<br>最后，返回一个JSON格式的字符串表示整个目标对象。JSON.stringify()</p><p>需要注意的是，在某些情况下，会跳过一些属性。 例如，当对象包含循环引用时，会将这些引用跳过，以避免无限递归。 此外，对于某些不支持的数据类型（例如日期对象），可能会将它们转换为null或空字符串。</p></blockquote><p>他的主要问题其实不是问题，主要是错误的应用方式，他本身就是为了 json &#x3D;&gt; string.</p><p>所以当你使用他的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><p>会发现以下问题</p><ol><li>Date() 他直接给你 toString() 了。</li><li>他不支持函数对象</li><li>他不支持 Map,Set,Error,RegExp，Symbol 等等.</li><li>不支持循环引用</li></ol><p>不支持循环引用的问题 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">b</span> = obj;</span><br></pre></td></tr></table></figure><p>这个时候就会报错。</p><h3 id="clonedeep"><a href="#clonedeep" class="headerlink" title="_.clonedeep"></a>_.clonedeep</h3><p>clonedeep 没有任何问题，问题是需要引入 <code>lodash</code>.</p><p>简单看了一下他的源码</p><p><strong>.internal&#x2F;baseClone.js</strong></p><p>大概是这个递归的思路来的</p><h3 id="自己写一个-deepClone"><a href="#自己写一个-deepClone" class="headerlink" title="自己写一个 deepClone"></a>自己写一个 deepClone</h3><p>本质上就是一个递归，我写一个伪代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> argsTag = <span class="string">&#x27;[object Arguments]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> weakMapTag = <span class="string">&#x27;[object WeakMap]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> arrayBufferTag = <span class="string">&#x27;[object ArrayBuffer]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dataViewTag = <span class="string">&#x27;[object DataView]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> float32Tag = <span class="string">&#x27;[object Float32Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> float64Tag = <span class="string">&#x27;[object Float64Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> int8Tag = <span class="string">&#x27;[object Int8Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> int16Tag = <span class="string">&#x27;[object Int16Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> int32Tag = <span class="string">&#x27;[object Int32Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> uint8Tag = <span class="string">&#x27;[object Uint8Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> uint8ClampedTag = <span class="string">&#x27;[object Uint8ClampedArray]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> uint16Tag = <span class="string">&#x27;[object Uint16Array]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> uint32Tag = <span class="string">&#x27;[object Uint32Array]&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断类型，如果 typeof 不是 object，直接返回</span></span><br><span class="line">    <span class="comment">//判断类型</span></span><br><span class="line">    <span class="comment">//你需要把每一个类型列出来单独处理，如同上图的tag</span></span><br><span class="line">    <span class="comment">//基础类型 new String(), new Date() 之类的，使用取出原始值，来创建新的对象，并且赋值</span></span><br><span class="line">    <span class="comment">//如果是Array, Map, Set ... 之类的的集合，字典，数组，遍历循环递归。</span></span><br><span class="line">    <span class="comment">//最后给出一个结果</span></span><br><span class="line">    <span class="comment">//return reuslt</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新方式，structuredClone"><a href="#新方式，structuredClone" class="headerlink" title="新方式，structuredClone"></a>新方式，structuredClone</h3><p>解决了大部分问题。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">https://developer.mozilla.org/en-US/docs/Web/API/structuredClone</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calendarEvent = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Builder.io Conf&quot;</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">123</span>),</span><br><span class="line">  <span class="attr">attendees</span>: [<span class="string">&quot;Steve&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copied = <span class="title function_">structuredClone</span>(calendarEvent)</span><br></pre></td></tr></table></figure><blockquote><p>克隆无限嵌套的对象和数组<br>克隆循环引用<br>克隆各种 JavaScript 类型，例如 、 、 等等DateSetMapErrorRegExpArrayBufferBlobFileImageData<br>传输任何可转移对象</p></blockquote><p>但是他也有问题</p><p>首先他无法克隆 <code>function</code></p><blockquote><p>Uncaught DOMException: Failed to execute ‘structuredClone’ on ‘Window’: function() { console.log(1) } could not be cloned.</p></blockquote><p>而且在某些情况下他会直接跳过 <code>function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; </span><br><span class="line">  foo = <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">structuredClone</span>(myClass)</span><br><span class="line">cloned.<span class="property">myMethod</span> === <span class="literal">undefined</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这个例子当中，还有另一个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloned <span class="keyword">instanceof</span> <span class="title class_">MyClass</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>也就是说他不会随着原型链像上查找，只是遍历属性。</p><p>还会存在一个问题，就是 <code>getter &amp; setter</code>. 他会跳过，你把他理解为 fn 就行了。</p><p>也就是说，这个单纯的是给你深度克隆数据的方法，如果你要克隆一个类，那是不行的。</p><p><a href="https://caniuse.com/?search=structuredClone">https://caniuse.com/?search=structuredClone</a></p><p>浏览器支持情况, nodejs中至少我目前的 v16.18 是不支持的。</p><h3 id="深拷贝的应用场景"><a href="#深拷贝的应用场景" class="headerlink" title="深拷贝的应用场景"></a>深拷贝的应用场景</h3><p>其实深拷贝还是特殊场景的特殊应用，随意使用可能导致问题。</p><p>因为持续的遍历需要考虑有多深的问题，还需要考虑是否要遍历prototype问题，还需要解决一些数据就是有问题的情况。</p><p>所以还是要剧情情况具体分析。</p><h3 id="如何浅拷贝"><a href="#如何浅拷贝" class="headerlink" title="如何浅拷贝"></a>如何浅拷贝</h3><p>都说道这里了，那么如何浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;...x&#125;</span><br><span class="line"><span class="keyword">let</span> o = x</span><br><span class="line"><span class="keyword">let</span> o = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, x);</span><br><span class="line"><span class="keyword">let</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(x)</span><br></pre></td></tr></table></figure><p>等等..</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必包和作用域</title>
      <link href="/2023/07/03/closures_and_scopes/"/>
      <url>/2023/07/03/closures_and_scopes/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1. 什么是作用域"></a>1. 什么是作用域</h3><blockquote><p>在 JavaScript 中，作用域（Scope）指的是变量和函数在代码中可访问的范围。作用域规定了在代码中定义的变量在何处以及在何时可被访问。</p><p>JavaScript 采用的是词法作用域（Lexical Scope）模型，也称为静态作用域模型。这意味着作用域是在代码编写阶段确定的，而不是在运行时确定的。</p></blockquote><p>JavaScript 中有以下几种类型的作用域：</p><ul><li>全局作用域（Global Scope）：全局作用域是在代码的最外层定义的，它在整个程序中都是可访问的。在全局作用域中定义的变量和函数可以在代码的任何地方被访问。</li><li>函数作用域（Function Scope）：函数作用域是指在函数内部定义的变量和函数只能在函数内部访问，函数外部无法访问这些变量和函数。每次调用函数时，都会创建一个新的函数作用域。</li><li>块级作用域（Block Scope）：在 ES6（ECMAScript 2015）之前，JavaScript 中没有块级作用域。块级作用域是指在代码块（如条件语句、循环语句或使用花括号 {} 包围的代码）中定义的变量仅在该块内部可访问。从 ES6 开始，引入了 let 和 const 关键字，可以在块级作用域中声明变量。</li></ul><p>其实这里还有其他作用域.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x = <span class="number">1</span></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x &#x3D; 1 这里也是一个单独的作用域。</p><p><strong>作用域链</strong></p><blockquote><p>作用域链（Scope Chain）是由嵌套的作用域组成的，它决定了变量查找的顺序。当在一个作用域中访问一个变量时，JavaScript 引擎会先在当前作用域查找，如果找不到，则会向上一级作用域继续查找，直到找到该变量或达到全局作用域。如果变量在任何作用域中都找不到，则会引发一个错误。</p></blockquote><p>好了，这里大概了解了作用域的流程。</p><h3 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2. 词法作用域"></a>2. 词法作用域</h3><blockquote><p>词法（Lexical） 指的是定义某个事物。<br>任何创建文字、表达式或变量的声明都叫词法。<br>词法作用域（Lexical Scope） 是定义表达式并能被访问的区间。<br>一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。</p></blockquote><p>词法作用域的本质是什么？词法作用域（Lexical Scope） 是定义表达式并能被访问的区间。</p><p>就是定义了程序的访问范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> b1 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> c1 = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> d1 = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">e</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> e1 = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>词法作用域决定了你定义的变量如何访问，比如说 function d 和 function e. </p><p>他们内部的变量定义的词法作用域就在内部，也就是 d1 只在 d 内部有效， e1 只在 e 内部有效。</p><p>所以 d 无法访问 e1, e 无法访问得 d1。</p><p>换言之，只有词法作用域内的代码才可以访问该作用域内部的代码。</p><p>比如 g 在所有方法中都能调用。</p><h3 id="3-必包"><a href="#3-必包" class="headerlink" title="3. 必包"></a>3. 必包</h3><p>词法作用域是必包的前提，我们来看一个必包.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tommyWords</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tommy&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">words</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;tommy&#125;</span> <span class="subst">$&#123;words&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name 是在 tommyWords 的词法作用域下，也就是说只有返回的匿名函数能访问，形成了一个私有变量。</p><p>这就是必包的一个特性，<strong>私有变量</strong>，原生js并没有这个能力，但是借助必包就有了。</p><p>第二个点就是，<strong>缓存数据</strong>，这一点就需要知道垃圾回收的机制.</p><blockquote><p>JavaScript 中的垃圾回收（Garbage Collection）是一种自动管理内存的机制，它负责检测不再使用的对象，并自动释放它们所占用的内存空间。垃圾回收器会周期性地扫描内存中的对象，并标记哪些对象是可达的（仍然被引用），哪些对象是不可达的（没有引用指向它们）。然后，垃圾回收器会清除不可达对象所占用的内存，以便可以被再次使用。</p><p>引用计数（Reference Counting）：这是一种最简单的垃圾回收算法。它通过在对象上维护一个引用计数器，每当有新的引用指向对象时，计数器加1，当引用失效时，计数器减1。当计数器为0时，表示该对象不再被引用，即为不可达对象，可以被回收。然而，引用计数算法无法解决循环引用的情况，即使对象之间互相引用，但它们与程序的其他部分没有联系，也会被认为是垃圾并被回收。</p><p>标记清除（Mark and Sweep）：这是一种常用的垃圾回收算法，用于解决引用计数算法无法处理的循环引用问题。标记清除算法分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾回收器会从根对象（全局对象、活动函数的变量等）开始遍历，标记所有可达的对象。在清除阶段，垃圾回收器会扫描整个堆内存，清除未被标记的对象，即不可达对象。被清除的内存空间会被标记为可再分配的，以便将来可以被新的对象使用。</p></blockquote><p>比如说</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"><span class="comment">//todo..</span></span><br><span class="line"><span class="keyword">return</span> other;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>那么当 a() 调用完，就没有地方可以引用a1了，也就是无法标记，所以会被清除了，再来看必包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">todo</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a1 + todo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o = <span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><p>这样只要o，还有人调用，那么 a1就不会清除，但是如果 o1 不再有人调用，a1还是会被清除。</p><p>如果 o 不是常量，继续赋值 <code>o = a()</code>，那么也会清理。</p><p>所以必包中的变量不是不会被清除，还是看匿名方法是否还有引用。</p><p>但是如果你一致有引用，比如说</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">a</span>(); <span class="comment">//1</span></span><br><span class="line">c = <span class="title function_">a</span>(); <span class="comment">//2</span></span><br><span class="line">c = <span class="title function_">a</span>(); <span class="comment">//3</span></span><br><span class="line">c = <span class="title function_">a</span>(); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>这也是一种缓存。</p><p><strong>拆分变量</strong></p><p>比如说我有一个 request 模块，需要传入 url, callback。如果我需要不停的调用这个方法，那么每次都需要传入这两个参数，使用必包呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDate</span>(<span class="params">url</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">request</span>(url, callback);</span><br><span class="line"><span class="title function_">callback</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gDate = <span class="title function_">getDate</span>(...);</span><br><span class="line"><span class="title function_">gDate</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> ...)</span><br><span class="line"><span class="title function_">gDate</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> ...)</span><br><span class="line"><span class="title function_">gDate</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> ...)</span><br></pre></td></tr></table></figure><p>这还有其他使用方式，大概是类似的使用方式。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>必包提供了私有变量，拆分变量，状态管控，模块化开发，事件回调等等功能。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 更新总结</title>
      <link href="/2023/07/03/baseEs6/"/>
      <url>/2023/07/03/baseEs6/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><ol><li>字符串</li><li>数值</li><li>函数</li><li>数组</li><li>对象(object)</li><li>运算符</li><li>Symbol</li><li>Set&amp;Map</li><li>Proxy</li><li>Reflect</li><li>Promise</li><li>Iterator</li><li>Generator</li><li>async</li><li>Class</li><li>Module</li></ol><h3 id="001-字符串"><a href="#001-字符串" class="headerlink" title="001. 字符串"></a>001. 字符串</h3><ol><li>字符的 Unicode 表示法 ‘\u0061’ or ‘\uD842\uDFB7’</li><li>支持 Iterator 遍历</li><li>模板字符串 <code>$&#123;name&#125;</code></li><li>标签模板 alert<code>welcome to $&#123;name&#125; house</code></li></ol><p>function alert() {<br>    console.log(arguments[0]);<br>    console.log(arguments[1]);<br>}</p><p>&#x2F;&#x2F; Array [‘welcome to’, ‘home’]<br>&#x2F;&#x2F; name </p><p>传参方式需要注意</p><ol start="5"><li>String.fromCodePoint() 用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。</li><li>String.raw<code>\a</code> &#x3D; <code>\\a</code> 转义，用于模板转义，已经转义还是要再转</li><li>String.codePointAt() 码点在U+10000到U+10FFFF之间的字符 ‘𠮷’.length &#x3D;&#x3D;&#x3D; 2, 所以这个其实是需要处理的。</li><li>String.repeat “abc”.repeat(2);</li><li>padStart,patEnd 补全，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.padStart(10, &#x27;1234567891011&#x27;) &quot;123456789a&quot;</span><br><span class="line">a.padStart(10, &#x27;12&#x27;) &quot;121212121a&quot;</span><br></pre></td></tr></table></figure><ol start="10"><li>trimLeft, trimEnd</li><li>matchAll</li><li>replaceAll 不用写正则了 replace(&#x2F;a&#x2F;g, ‘_’), 第二个参数可以有一些特殊字符来匹配，你会正则也可以无视</li><li>at()方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）</li></ol><h3 id="02-数值"><a href="#02-数值" class="headerlink" title="02. 数值"></a>02. 数值</h3><ol><li>表示二进制 0b || 0B</li><li>表示八进制 0o || 0O</li><li>数值分割 1000000 可以使用下划线来分割 1_000_000</li><li>Number.isFinite() <a href="https://baike.baidu.com/item/infinity/18702999?fr=aladdin">https://baike.baidu.com/item/infinity/18702999?fr=aladdin</a> 正无穷和负无穷，javascript <code>1.7976931348623157e+308</code> 超过正负值</li><li>Number.isNaN() 是数值类型但是非数字。 Number.isNaN(“a” * 2) &#x3D;&#x3D;&#x3D; true</li><li>Number.isInteger() 是否值整数, 正负都为 true</li><li>parseInt &amp; parseFloat 从 window移植到 Number 下</li><li>Number.EPSILON 二进制的问题就不复述了，主要是可以检测两个数字</li><li>Number.MAX_SAFE_INTEGER </li><li>Number.MIN_SAFE_INTEGER</li><li>Number.isSafeInteger() 9,10,11 都是围绕着是否超过精度估算范围是否是安全数字</li><li>BigInt 后缀必须 + n， 比如3n, 细节没看，但是不能有小数点。</li></ol><p>需要精确计算数字我用的比较少，需要的时候再学习吧。</p><h3 id="03-函数-function"><a href="#03-函数-function" class="headerlink" title="03. 函数 function"></a>03. 函数 function</h3><ol><li>默认参数 function(x, y&#x3D;1) … ,需要注意的是这里有一个独立的作用域，并且每次执行都会计算</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let x = 99</span><br><span class="line">function a(p = x + 1)</span><br><span class="line">a() // 100</span><br><span class="line">x = 100</span><br><span class="line">a() // 101</span><br></pre></td></tr></table></figure><p>内部的作用域可以做很多事情</p><ol start="2"><li>function.length 返回参数个数 默认值和默认值后面的参数都不认。</li><li>name, 返回 function name</li><li>&#x3D;&gt; 函数，主要注意 this 的引用。</li><li>rest 类似扩展运算符 function(…values) a { &#x2F;&#x2F;values数组 }</li></ol><h3 id="04-数组"><a href="#04-数组" class="headerlink" title="04. 数组"></a>04. 数组</h3><ol><li>…</li><li>Array.from 类数组转换为数组</li><li>Array.of() 创建数组</li><li>Array.copyWith(target(需要复制的位置), start(开始复制位置), end(停止复制的位置))</li><li>find()，findIndex()，findLast()，findLastIndex() </li><li>fill</li><li>entries()，keys() 和 values()</li><li>includes()</li><li>flat()，flatMap() 多维数组转一维</li><li>at() 支持负索引</li></ol><h3 id="05-Object"><a href="#05-Object" class="headerlink" title="05. Object"></a>05. Object</h3><ol><li>支持简写，也就是</li></ol><p>var o &#x3D; 1<br>var b &#x3D; { o, a() {} }</p><ol start="2"><li>可以使用变量作为 Object Key</li><li>Object.getOwnPropertyDescriptor 获取属性描述，就是可写，可读，值，之类的值</li><li>for…in &#x2F;&#x2F;enumerable无效</li><li>Object.keys(obj) &#x2F;&#x2F;enumerable无效</li><li>Object.getOwnPropertyNames(obj) &#x2F;&#x2F;enumerable无效</li><li>Object.getOwnPropertySymbols(obj) &#x2F;&#x2F;enumerable无效</li><li>Reflect.ownKeys(obj) &#x2F;&#x2F;enumerable无效</li><li>AggregateError 合并多个错误 <code>AggregateError(errors[, message])</code></li><li>Object.is 基本等于 &#x3D;&#x3D;&#x3D; ，差别在 Object.is(NaN, NaN) &#x3D;&#x3D; true, +0 -0对比为false</li><li>Object.assign 就是合并object, 需要注意的 Object.assign是浅拷贝，并且同名属性是替换，不是合并</li><li>Object.getOwnPropertyDescriptors() </li><li><strong>proto</strong> 用来读取或设置当前对象的原型对象. </li><li>Object.setPrototypeOf</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setPrototypeOf(target, proto) &#123;</span><br><span class="line">target.__proto__ = proto;</span><br><span class="line">return target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>Object.setPrototypeOf</li></ol><p>获取和设置 <strong>proto</strong> , 建议不要直接使用 Object.set or Object.get 方式，<strong>proto</strong> 直接使用的方式兼容性不太好，因为说不定可能取消。</p><ol start="16"><li>Object.keys()，Object.values()，Object.entries() enumerable &#x3D; true 就意味着可以遍历。</li><li>Object.fromEntrise 将键值对转换为object，map转object</li><li>Object.hasOwn, 和Object.hasOwnProperty 类似。</li></ol><h3 id="06-运算符"><a href="#06-运算符" class="headerlink" title="06. 运算符"></a>06. 运算符</h3><ol><li>**  有点像位运算， 平方</li><li>? message.user.name 如果需要判断，需要判断3次， message?.user?.name</li></ol><p>有几点需要注意</p><blockquote><p>一. 短路，本质上，?.运算符相当于一种短路机制 ，只要不满足条件，就不再往下执行。<br>二. 别用括号，因为短路的原因</p></blockquote><ol start="3"><li>?? 判断 null || undefined , 但是不判断0, false之类的</li><li>x ||&#x3D; y, x &amp;&amp;&#x3D; y, x ??&#x3D; y.</li></ol><h3 id="07-Symbol"><a href="#07-Symbol" class="headerlink" title="07. Symbol"></a>07. Symbol</h3><p>唯一不会重复的值，是一种基础类型，所以也不能 <code>new</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = Symbol()</span><br><span class="line">let b = Symbol()</span><br><span class="line">a === b false</span><br></pre></td></tr></table></figure><p>可以有 description，Symbol(‘a’), <code>toString</code> or <code>Symbol.description</code></p><p>如果以 <code>Symbol</code> 作为方法或者属性的 <code>key</code>, 普通方法是无法遍历的</p><p>比如 <code>for...in</code>, <code>Object.keys</code>, <code>for of</code>, <code>Object.getOwnPropertyName</code>, <code>JSON.stringfly</code> 之类的。</p><p>只能从 Object.getOwnPropertySymbol(), Reflect.ownKeys 可以获取。</p><p>他还有一些内置的值，主要是 Object 或者 Class 用于指向一个内部方法。</p><ol><li>Symbol.hasInstance 可以重写 instanceof</li><li>Symbol.isConcatSpreadable </li><li>Symbol.species 改变衍生对象 instanceof 指向</li><li>Symbol.replace</li><li>Symbol.search</li><li>Symbol.split</li><li>Symbol.iterator</li><li>Symbol.toPrimitive</li><li>Symbol.toStringTag</li><li>Symbol.unscopables</li><li>Symbol.toPrimitive &#x2F;&#x2F;指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值</li><li>Symbol.toStringTag</li></ol><h3 id="08-set-map"><a href="#08-set-map" class="headerlink" title="08. set map"></a>08. set map</h3><p>Set, 本身是一个构造函数，初始化一个Set数据结构，可以传入数组或者支持iterable接口的数据.<br>本身是一个集合，内部不能有重复值</p><ul><li>add</li><li>size</li><li>delete</li><li>get</li><li>has</li><li>clear</li></ul><p>遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values</span><br></pre></td></tr></table></figure><p>所以 <code>for of</code> ok, 还可以使用 <code>forEach, set.keys(), set.values, set.entries</code> 去遍历<br>使用 Set 主要使用他去重的功能来进行操作。</p><p>WeakSet 和 Set 类似，但是他方法少了。</p><ul><li>add</li><li>delete</li><li>has</li></ul><p>区别主要在于 WeakSet 只能存对象，并且是一个弱引用。<br>弱引用需要先知道回收的机制，简单是就是如果一个对象还被引用，就不会回收，比如必包中的变量。<br>那么存放在 WeakSet 当中的对象无需考虑在里面，不计入在引用当中。<br>所以可以用来存放一些临时对象，也不用去管他的释放。</p><p>Map</p><p>Map和Object类似，都是属于Hash结构，就是键值对。</p><blockquote><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数</p></blockquote><p>所以 Map的创建可以 add 和可以构造函数传入</p><blockquote><p>terator 接口、且每个成员都是一个双元素的数组的数据结构</p></blockquote><p>Map 后面的值会覆盖前面的，Key相同的话，只要两个值严格相等，Map 将其视为一个键, 比如 +0 和 -0, 但是NaN虽然 NaN &#x3D;&#x3D;&#x3D; NaN &#x3D;&#x3D; false， 但是也视为相同健。</p><p>map的顺序就是插入的顺序，并且没有提供排序的方法。</p><ul><li>set</li><li>size</li><li>get</li><li>delete</li><li>clear</li><li>…</li></ul><p>遍历， 本身支持 Iterator, 所以 <code>Map.keys(), Map.values(), Map.entries </code> 以及本身的 <code>Map.forEach</code> 都可以，也可以直接 <code>for of</code>.</p><p>整体看下来，在不看底层代码的情况下，Map优势不明显。<br>只能说多了一层封装。</p><p><strong>WeakMap</strong>.</p><ul><li>set</li><li>delete</li><li>has</li><li>get</li></ul><p>WeakMap 也是弱引用，不过只值 key 是弱引用，并且key 只能对对象。<br>作用和 WeakSet 一样，只是结构不同<br>他们两都不能遍历，因为弱引用导致对象随时可能消失，在遍历的时候，会导致错误。<br>保存以后去验证一个对象是否还存在，是否还有引用。</p><p><strong>WeakRef</strong></p><p>WeakSet 和 WeakMap 都是在创建, add, set(key) 的时候才是弱引用。<br>WeakRef 可以把他包装一下，变成一个弱引用。</p><p>在做弱引用的测试的时候，我产生了极大的疑惑，后来还 <code>chrome</code> 核心测试成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let john = &#123; name: &quot;John&quot; &#125;;</span><br><span class="line">let weakMap = new WeakMap();</span><br><span class="line">weakMap.set(john, &quot;...&quot;);</span><br><span class="line">john = null; </span><br><span class="line"></span><br><span class="line">weakMap //无属性</span><br></pre></td></tr></table></figure><p>但是在 firefox 下不是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = null</span><br><span class="line">weakMap依然保持引用。</span><br></pre></td></tr></table></figure><h3 id="09-proxy"><a href="#09-proxy" class="headerlink" title="09. proxy"></a>09. proxy</h3><p><strong>Proxy</strong> 代理，可以理解为把原有对象包裹在里面，访问真实的对象需要先经过这个代理。</p><ol><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo &#x3D; v或proxy[‘foo’] &#x3D; v，返回一个布尔值。</li><li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ol><p><strong>Proxy</strong> 可以拦截以上操作, 可以做很多事情。</p><p>比如 Es6 没有提供 Set 数据结构, 我们要实现一个数组添加不能有重复</p><ol><li>通过 Class 重写一个对象。</li><li>或者通过统一的 handler，去代理一个 Array对象去实现特性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(arr, &#123;</span><br><span class="line">    set: function(target, propkey, value, receiver) &#123;</span><br><span class="line">        if(!target.includes(value)) &#123;</span><br><span class="line">            return Reflect.set(target, propkey, value, receiver);    </span><br><span class="line">        &#125;</span><br><span class="line">return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>比如 Array.push 是无法链式 [].push(1).push(2), Proxy get 就可以实现，还可以防止调用内部方法，形成私有变量。</p><p>Proxy 需要有几点注意的。</p><ol><li>receiver 这个参数如果在继承，原型链, <strong>proto</strong> 赋值以后，是指向当前Object，不一定是指向你在绑定 proxy 时候的 Object.</li><li>this 指向和 receiver 有相同的问题，最好不要以 this.xx 可能会出现问题。</li></ol><h3 id="10-Reflect"><a href="#10-Reflect" class="headerlink" title="10. Reflect"></a>10. Reflect</h3><blockquote><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ol></blockquote><h3 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. Promise</h3><p>promise 如果只是说语法的话，其实挺简单的。<br>首先需要明确的是 Promise 是语法糖，你通过JS可以自己写一个出来。<br>3种状态，pendding, fulfilled, rejected<br>当你调用一个 promise，就已经在 pendding 状态下。<br>then(fulfilled, rejected), 处理其他两种状态。<br>这就是最基本的语法。</p><p>链式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(result =&gt; deep(result)).then(tree =&gt; todo)</span><br></pre></td></tr></table></figure><p>其实就是包装前一个 promise 结果返回一个新的 promise</p><p>.catch </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(fulfilled, rejected)</span><br></pre></td></tr></table></figure><p>.finally </p><p>.all 全部成功才算成功fulfilled<br>.race 只要有一个成功状态就是fulfilled<br>.allSettled 全部返回就算成功，不管里面状态<br>.any 只要有一个是 fulfilled，全部rejected rejected</p><h3 id="12-Generator"><a href="#12-Generator" class="headerlink" title="12. Generator"></a>12. Generator</h3><p>语法就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function* a() &#123;</span><br><span class="line">yield 1</span><br><span class="line">yield 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回一个 iterator 对象，可以进行遍历，或者自己调用 next<br>next 对象包含 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; value: any, done: boolean &#125;</span><br></pre></td></tr></table></figure><p>done 表示是否完结</p><p>Generator 的一个特性就是，阻止代码运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* a() &#123;</span><br><span class="line">yield b();</span><br><span class="line">yield c();</span><br><span class="line">yield d();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = a(); //不执行，只是传参</span><br><span class="line">o.next(); //执行b()</span><br><span class="line">o.next(); //执行c()</span><br><span class="line">o.next(); //执行d()</span><br></pre></td></tr></table></figure><p>还有一个例子说明返回和参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function a(s) &#123;</span><br><span class="line">    console.log(&quot;a&quot;);</span><br><span class="line">    return &quot;ar&quot; + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b(s) &#123;</span><br><span class="line">    console.log(&quot;b&quot;);</span><br><span class="line">    return &quot;br&quot; + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function c(s) &#123;</span><br><span class="line">    console.log(&quot;c&quot;);</span><br><span class="line">    return &quot;cr&quot; + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* g(s) &#123;</span><br><span class="line">    let av = yield a(s);</span><br><span class="line">    let bv = yield b(av);</span><br><span class="line">    let cv = yield c(bv);</span><br><span class="line">    return cv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个说明了传参和返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = g(&quot;haha&quot;) //s = haha</span><br><span class="line">o.next() //不用传参</span><br><span class="line">o.next(&quot;h&quot;) //av = h</span><br><span class="line">o.next(&quot;hh&quot;) //bv = hh</span><br></pre></td></tr></table></figure><p>Generator.throw 可以在外部抛出错误，Generator 内部捕获错误<br>Generator.return 可以直接将 iterable 指针指向最后一个<br>yield* 表达式可以调用另外的表达式或者方法<br>this 可以在 prototype 中设置，但是不能在 function 中使用 this, 也不能 new</p><p><code>yield</code> 最牛逼的地方在于可以暂停，因此他可以有非常多扫操作</p><ol><li>状态机</li><li>异步操作同步进行</li><li>以iterable接口输出</li><li>当作一种数据结构</li><li>流程管理之类的事情</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(url) &#123; ... &#125; //异步获取数据 promise</span><br><span class="line"></span><br><span class="line">function* a(urls) &#123;</span><br><span class="line">for(let i=0; i&lt;urls.length;i++) &#123;</span><br><span class="line">let result = yield get(url);</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个result 可以做挺多事情的，实现了一个看起来同步的操作。</p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p><a href="https://es6.ruanyifeng.com/#docs/number">https://es6.ruanyifeng.com/#docs/number</a><br><a href="https://zhuanlan.zhihu.com/p/467585782">https://zhuanlan.zhihu.com/p/467585782</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 异步编程有哪些方式？</title>
      <link href="/2023/07/03/async_code/"/>
      <url>/2023/07/03/async_code/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>这里是讨论编程方式。</p><p>javascript 实现异步，本质上还是依靠</p><ol><li>setTimeout</li><li>Promise</li><li>async&#x2F;await</li><li>XMLHttpRequest</li><li>Web Workers</li><li>EventListener</li></ol><p>这几种方式去异步。</p><h3 id="01-回调"><a href="#01-回调" class="headerlink" title="01, 回调"></a>01, 回调</h3><p>回调是一种最基础的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setTimtOut</span>(fn, time)</span><br></pre></td></tr></table></figure><p>EventListener 也是靠回调解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了按钮&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-Thunk"><a href="#02-Thunk" class="headerlink" title="02. Thunk"></a>02. Thunk</h3><p>可以理解为回调的变种，或者工厂, 闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunk</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">        <span class="comment">//请求</span></span><br><span class="line">        <span class="comment">//cb</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处在于，分割参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> requestA = <span class="title function_">thunk</span>(url);</span><br><span class="line"><span class="title function_">requestA</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>你可以直接调用 <code>requestA</code>, 相当于封装了一层。</p><h3 id="03-事件驱动"><a href="#03-事件驱动" class="headerlink" title="03. 事件驱动"></a>03. 事件驱动</h3><p>就是开头提到的 EventListener。</p><p>这个涉及到 javascript 一个基础概念， JavaScript 是一种事件驱动的语言。</p><blockquote><p>它通过事件机制来响应用户的操作和系统的变化。<br>事件可以是用户操作，如鼠标点击、键盘输入、窗口滚动等，也可以是系统变化，如网页加载完成、定时器到期等。</p></blockquote><p>DOM 事件和自定义事件，它们都是异步执行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击了！&#x27;</span>, event);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;myEvent&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(myEvent);</span><br></pre></td></tr></table></figure><p>但是如果是有我们自己去触发，就是同步执行，比如通过 <code>dispatchEvent</code> 触发。</p><h3 id="04-观察者模式"><a href="#04-观察者模式" class="headerlink" title="04. 观察者模式"></a>04. 观察者模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义观察者对象</span></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">  <span class="attr">subscribers</span>: [],</span><br><span class="line">  <span class="attr">subscribe</span>: <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">unsubscribe</span>: <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">indexOf</span>(callback);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">notify</span>: <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">subscriber</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">subscriber</span>(data);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件</span></span><br><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;dataUpdated&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">message</span>: <span class="string">&#x27;Hello world!&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">observer.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received data:&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">observer.<span class="title function_">notify</span>(event.<span class="property">data</span>);</span><br></pre></td></tr></table></figure><p>例子中这个异步其实没有意义，主要是应该在 notify 通知之前来异步，比如接收到消息之类的</p><p>但是模式是这么一个模式</p><h3 id="05-promise"><a href="#05-promise" class="headerlink" title="05. promise"></a>05. promise</h3><p>异步编程前端目前来说最佳解决方案。</p><h3 id="06-async-x2F-await"><a href="#06-async-x2F-await" class="headerlink" title="06. async&#x2F;await"></a>06. async&#x2F;await</h3><p>也是 Prmoise，只是语法糖。</p><h3 id="07-yield"><a href="#07-yield" class="headerlink" title="07. yield"></a>07. yield</h3><p>因为可以暂停的机制，可以很好的批量触发异步任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">reuslts</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">request</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> r <span class="keyword">of</span> results) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要知道一个概念协程</p><blockquote><p>协程（Coroutine）是一种计算机程序组件，它可以在执行过程中暂停、恢复和传递控制权，从而支持多任务协作并发编程。简单来说，协程是一种更轻量级的线程，它可以像线程一样并发执行，但相比线程占用更少的资源，并且可以更方便地实现协作式多任务处理。</p><p>与线程不同，协程并不是由操作系统内核管理的，而是由应用程序自行管理。协程通常由一个生成器函数（Generator Function）和一个调度器（Scheduler）组成，生成器函数用于定义协程的执行流程，调度器用于控制协程的调度和协作。</p><p>协程通常具有以下特点：</p><ol><li>协程可以在执行过程中暂停和恢复执行，这种操作通常称为挂起和恢复。</li><li>协程可以保存和恢复自己的状态，包括变量、指令指针和调用栈等。</li><li>协程通常使用协作式调度，即协程之间协作执行，不需要像线程那样通过操作系统内核进行调度。</li><li>协程通常可以实现轻量级的多任务处理，支持更高效的并发编程。</li></ol></blockquote></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看 node-deep-equal</title>
      <link href="/2023/07/03/node_deep_equal/"/>
      <url>/2023/07/03/node_deep_equal/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p><a href="https://github.com/inspect-js/node-deep-equal">inspect-js&#x2F;node-deep-equal</a></p><p>这个库很有意思，因为他需要做深层次的对比，所以所有的 javascript 类型都囊括了，应该如何判断和对比</p><p>它的核心方法 <code>internalDeepEqual</code>, 传入(A,B,Opt,Channel)</p><p>A,B 是需要对比的对象， Opt用来区分 Object.is or &#x3D;&#x3D;&#x3D;, Channel 一个字典</p><ol><li>Object.is or &#x3D;&#x3D;&#x3D; 判断 A，B是否相等，相等 retrun true.</li><li>判断 A，B是否是基础类型，并且 typeof 的值是否一致，他这里处理了 new Number(1), new String(“1”) 这些情况，只是判断类型是否一致，如果不一致， return false</li><li>A,B 有一个可能是 undefined， null 或者 两边都不是 typeof A !&#x3D;&#x3D; object 的情况下，直接通过 Object.is or &#x3D;&#x3D;&#x3D; 来对比</li><li>上面3中情况直接处理了基础类型，非object的情况下</li><li>将 A，B加入字典，并且做判断</li><li>进入 objEquiv(A, B, opts, channel); 进行 Object 的对比。</li></ol><p><strong>objEquiv</strong></p><ol><li>typeof 返回值对比</li><li>Object.prototype.toString(A or B) 对比</li><li>isArguments 类型判断 </li><li>isArray 类型判断 return false</li><li>instanceof Error 类型判断 return false</li><li>如果都是Error对象，对比 name 和 message return false </li><li>isRegex 类型判断 return false </li><li>对比 Regex.source &amp; Regex.prototype.flags return false</li><li>isDate 类型判断 return false</li><li>对比 Date.prototype.getTime return false</li><li>Object.getPrototypeOf 对比原型链 return false</li><li>whichTypedArray 判断 return false</li><li>isBuffer 类型判断 return false</li><li>判断 Buffer length 或者 循环判断两个buffer内容 return true or false</li><li>isArrayBuffer 类型判断 return false</li><li>判断 ArrayBuffer 长度是否一致 return false</li><li>return typeof Uint8Array &#x3D;&#x3D;&#x3D; “function” &amp;&amp; internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel)</li><li>isSharedArrayBuffer 类型判断 和 isArrayBuffer 过程一样</li><li>objectKeys</li><li>判断长度</li><li>整理顺序 sort</li><li>循环判断</li><li>whichCollection  判断是否是 set,map,WeakMap,WeakSet 集合类型判断</li><li>类型判断</li><li>循环递归判断 Set,Map 内容，return true or false</li><li>return true;</li></ol><h3 id="01-关于-Error-的条件判断的问题"><a href="#01-关于-Error-的条件判断的问题" class="headerlink" title="01. 关于 Error 的条件判断的问题"></a>01. 关于 Error 的条件判断的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var aIsError = a instanceof Error;</span><br><span class="line">var bIsError = b instanceof Error;</span><br><span class="line">if (aIsError !== bIsError) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">if (aIsError || bIsError) &#123;</span><br><span class="line">  if (a.name !== b.name || a.message !== b.message) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;1. A other B other<br>&#x2F;&#x2F;2. A Error B other<br>&#x2F;&#x2F;3. A other B Error<br>&#x2F;&#x2F;4. A Error B Error</p><p>2,3 的情况不存在，因为直接返回 false,在之前的代码中也直接返回 false<br>1, 如果都是 other 会直接跳过<br>4, 如果 Error name &amp; message 一致，也就是不会返回 false.</p><p>为什么还需要继续进行判断，比如 isRegex, 以及之后的代码，而不是直接 return true.</p><p>因为后续并没有继续针对 <code>Error</code> 对象来进行判断的了，也就是说始始终会执行到最后一步, return true</p><p>根据 <code>javascript Error</code> 文档 <a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/error">Error</a></p><p>虽然 Error 本身还是有很多属性，但是其实值的判断的，name &amp; message &amp; stack</p><blockquote><p>Error.prototype.stack Non-standard<br>A non-standard property for a stack trace.</p></blockquote><p>所以 name &amp; message 相等的话，应该可以确定是同一种错误。</p><h3 id="02-channel的使用问题"><a href="#02-channel的使用问题" class="headerlink" title="02. channel的使用问题"></a>02. channel的使用问题</h3><p><code>side-channel</code> 是 WeakMap || Map || Object 的一种封装，根据传入参数的不一致，选择不同的字典。</p><p>看一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var hasActual = channel.has(actual);</span><br><span class="line">  var hasExpected = channel.has(expected);</span><br><span class="line">  var sentinel;</span><br><span class="line">  if (hasActual &amp;&amp; hasExpected) &#123;</span><br><span class="line">    if (channel.get(actual) === channel.get(expected)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sentinel = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!hasActual) &#123;</span><br><span class="line">    channel.set(actual, sentinel);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!hasExpected) &#123;</span><br><span class="line">    channel.set(expected, sentinel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // eslint-disable-next-line no-use-before-define</span><br><span class="line">  return objEquiv(actual, expected, opts, channel);</span><br></pre></td></tr></table></figure><p>根据代码， channel 只实例化过一次，如果一个对象，出现完全相同的 Key，那么就会出问题。</p><h3 id="03-包含基本类型的判断"><a href="#03-包含基本类型的判断" class="headerlink" title="03. 包含基本类型的判断"></a>03. 包含基本类型的判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o1 = new Number(1);</span><br><span class="line">let o2 = new Number(2);</span><br></pre></td></tr></table></figure><p>对于这个包来说是返回true的，因为没有针对这个的处理。</p><p>但是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o1 = new String(`one`) </span><br><span class="line">let o2 = new String(`two`)</span><br></pre></td></tr></table></figure><p>却可以，那是因为，其中有一个判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(o1)</span><br></pre></td></tr></table></figure><p>然后进行对比。</p><p>所以按照这个逻辑，new boolean 也是无法判断的。</p><p>其他的基础类型，因为不能 new, 所以没有问题</p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/error">Error</a></li><li><a href="https://github.com/ljharb/side-channel">side-channel</a></li><li><a href="https://www.npmjs.com/package/deep-equal">deep-equal</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 看源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue errorCaptured vs onErrorCaptured</title>
      <link href="/2023/07/02/vue_errorCaptured_onErrorCaptured/"/>
      <url>/2023/07/02/vue_errorCaptured_onErrorCaptured/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br>deactivated -&gt; onDeactivated<br><strong>errorCaptured -&gt; onErrorCaptured</strong></p><h3 id="1-onErrorCaptured"><a href="#1-onErrorCaptured" class="headerlink" title="1. onErrorCaptured"></a>1. onErrorCaptured</h3></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> errorCaptured </tag>
            
            <tag> onErrorCaptured </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue deactivated vs onDeactivated</title>
      <link href="/2023/07/02/vue_deactivated/"/>
      <url>/2023/07/02/vue_deactivated/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br><strong>deactivated -&gt; onDeactivated</strong><br>errorCaptured -&gt; onErrorCaptured</p><h3 id="1-onDeactivated"><a href="#1-onDeactivated" class="headerlink" title="1. onDeactivated"></a>1. onDeactivated</h3><p>先说说调用流程</p><p>触发 <strong>set &#x3D;&gt; trigger &#x3D;&gt; effect.scheduler() &#x3D;&gt; queueJob(update) &#x3D;&gt; queue.push(job); &#x3D;&gt; flushJobs(执行队列, 执行完成以后) &#x3D;&gt; flushPostFlushCbs &#x3D;&gt; 触发回调</strong></p><p>加入钩子 <strong>set &#x3D;&gt; trigger &#x3D;&gt; effect.scheduler() &#x3D;&gt; queueJob(update) &#x3D;&gt; queue.push(job); &#x3D;&gt; flushJobs(执行队列) &#x3D;&gt; patch(不停的递归) &#x3D;&gt; unmount &#x3D;&gt;  parentComponent.ctx.deactivate(vnode)</strong></p><p>这是另外一套 Vue3 钩子触发方法，也是我后续才注意到的，需要补充在之前的生命周期流程。</p><p><a href="/tblog/2023/06/29/vue3_keep_alive/">keep-alive</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sharedContext.<span class="property">deactivate</span> = <span class="function">(<span class="params">vnode: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//获取当前 Vnode 组件</span></span><br><span class="line">  <span class="keyword">const</span> instance = vnode.<span class="property">component</span>! </span><br><span class="line">  <span class="comment">//移动节点到 storageContainer</span></span><br><span class="line">  <span class="title function_">move</span>(vnode, storageContainer, <span class="literal">null</span>, <span class="title class_">MoveType</span>.<span class="property">LEAVE</span>, parentSuspense)</span><br><span class="line">  <span class="comment">// 加入队列</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//deactivate 钩子触发</span></span><br><span class="line">    <span class="keyword">if</span> (instance.<span class="property">da</span>) &#123;</span><br><span class="line">      <span class="title function_">invokeArrayFns</span>(instance.<span class="property">da</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//onVnodeUnmounted 钩子</span></span><br><span class="line">    <span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeUnmounted</span></span><br><span class="line">    <span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">      <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标记 deactived</span></span><br><span class="line">    instance.<span class="property">isDeactivated</span> = <span class="literal">true</span></span><br><span class="line">  &#125;, parentSuspense)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种执行模式，更新, active 等等都是这样的，但是都是完全执行完成之后，在最后调用。</p><h3 id="Vue2-x-deactivated"><a href="#Vue2-x-deactivated" class="headerlink" title="Vue2.x deactivated"></a>Vue2.x deactivated</h3><p>调用路径类似</p><p>触发 <strong>set &#x3D;&gt; dep &#x3D;&gt; watcher &#x3D;&gt; 调度队列 &#x3D;&gt; watcher.run() &#x3D;&gt; updateComponent &#x3D;&gt; patch &#x3D;&gt; removeVnodes &#x3D;&gt; invokeDestroyHook</strong> 触发 <code>hooks</code>。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> deactivated </tag>
            
            <tag> onDeactivated </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue actived vs onActivated</title>
      <link href="/2023/07/02/vue_active/"/>
      <url>/2023/07/02/vue_active/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h3 id="1-Vue3-x-onActivated"><a href="#1-Vue3-x-onActivated" class="headerlink" title="1. Vue3.x onActivated"></a>1. Vue3.x onActivated</h3><p><code>keep-alive</code>  的源码之前看了大概看过，可以看这里 <a href="/tblog/2023/06/29/vue3_keep_alive/">keep-alive</a></p><p><code>active</code> 会在 <code>processComponent</code> 当中调用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processComponent</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    n2.<span class="property">slotScopeIds</span> = slotScopeIds;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.<span class="property">shapeFlag</span> &amp; <span class="number">512</span> <span class="comment">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span>) &#123;</span><br><span class="line">            parentComponent.<span class="property">ctx</span>.<span class="title function_">activate</span>(n2, container, anchor, isSVG, optimized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">mountComponent</span>(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">updateComponent</span>(n1, n2, optimized);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是通过 component is 的触发到 update &#x3D;&gt; patch 然后可以触发到这里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sharedContext.<span class="property">activate</span> = <span class="function">(<span class="params">vnode, container, anchor, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = vnode.<span class="property">component</span>!</span><br><span class="line">  <span class="title function_">move</span>(vnode, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>, parentSuspense)</span><br><span class="line">  <span class="comment">// in case props have changed</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">    instance.<span class="property">vnode</span>,</span><br><span class="line">    vnode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    instance,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    vnode.<span class="property">slotScopeIds</span>,</span><br><span class="line">    optimized</span><br><span class="line">  )</span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    instance.<span class="property">isDeactivated</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (instance.<span class="property">a</span>) &#123;</span><br><span class="line">      <span class="title function_">invokeArrayFns</span>(instance.<span class="property">a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeMounted</span></span><br><span class="line">    <span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">      <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    <span class="comment">// Update components tree</span></span><br><span class="line">    <span class="title function_">devtoolsComponentAdded</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把当前节点移动到 <code>container</code> 当中，然后 <code>patch</code> 新旧节点，触发 <code>active hook</code>。</p><p>具体关于缓存和其他方法就看 <a href="/tblog/2023/06/29/vue3_keep_alive/">keep-alive</a></p><p>另外还有一处触发点在 setupRenderEffect</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  initialVNode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span> ||</span><br><span class="line">  (parent &amp;&amp;</span><br><span class="line">    <span class="title function_">isAsyncWrapper</span>(parent.<span class="property">vnode</span>) &amp;&amp;</span><br><span class="line">    parent.<span class="property">vnode</span>.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  instance.<span class="property">a</span> &amp;&amp; <span class="title function_">queuePostRenderEffect</span>(instance.<span class="property">a</span>, parentSuspense)</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __COMPAT__ &amp;&amp;</span><br><span class="line">    <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&#x27;hook:activated&#x27;</span>),</span><br><span class="line">      parentSuspense</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue2-x-actived"><a href="#Vue2-x-actived" class="headerlink" title="Vue2.x actived"></a>Vue2.x actived</h3><p><strong>src\core\components\keep-alive.ts</strong></p><p>就是一个组件，自定义是组建，然后自己写了一个 <code>render</code>, 方法有类似，基本逻辑一样，只是 <strong>Vue3.x</strong> 是用 <strong>setup</strong> 来写，并且是一个闭包，可是这里似乎与生命周期无关，也就是说，<code>active</code> 是在 <code>patch</code> 当中调用的全局生命周期</p><p>那么 actived 是怎么触发的 ？</p><p><strong>Vue.prototype._update</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line"><span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line"><span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">vm.<span class="property">_vnode</span> = vnode</span><br><span class="line"><span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line"><span class="comment">// based on the rendering backend used.</span></span><br><span class="line"><span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">  <span class="comment">// initial render</span></span><br><span class="line">  vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// updates</span></span><br><span class="line">  vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initComponent</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initComponent</span> (vnode, insertedVnodeQueue) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">data</span>.<span class="property">pendingInsert</span>)) &#123;</span><br><span class="line">    insertedVnodeQueue.<span class="property">push</span>.<span class="title function_">apply</span>(insertedVnodeQueue, vnode.<span class="property">data</span>.<span class="property">pendingInsert</span>);</span><br><span class="line">    vnode.<span class="property">data</span>.<span class="property">pendingInsert</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vnode.<span class="property">elm</span> = vnode.<span class="property">componentInstance</span>.<span class="property">$el</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">    <span class="title function_">invokeCreateHooks</span>(vnode, insertedVnodeQueue);</span><br><span class="line">    <span class="title function_">setScope</span>(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// empty component root.</span></span><br><span class="line">    <span class="comment">// skip all element-related modules except for ref (#3455)</span></span><br><span class="line">    <span class="title function_">registerRef</span>(vnode);</span><br><span class="line">    <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line">    insertedVnodeQueue.<span class="title function_">push</span>(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说通过 <strong>Object.defineProperty &#x3D;&gt; set &#x3D;&gt; dep &#x3D;&gt; 触发 watcher &#x3D;&gt; 触发更新 &#x3D;&gt; _update &#x3D;&gt; patch &#x3D;&gt; initComponent &#x3D;&gt; 然后加入队列</strong></p><p>最后在 patch 结束以后，统一调用.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch);</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> keep-alive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 keep-alive</title>
      <link href="/2023/06/29/vue3_keep_alive/"/>
      <url>/2023/06/29/vue3_keep_alive/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="1-Vue3-x-keep-alive-源码"><a href="#1-Vue3-x-keep-alive-源码" class="headerlink" title="1. Vue3.x keep-alive 源码"></a>1. Vue3.x keep-alive 源码</h1><p><strong>packages&#x2F;runtime-core&#x2F;src&#x2F;components&#x2F;KeepAlive.ts</strong></p><p>看源码知道 keepalive 分为以下几个功能</p><p>setup 函数，里面定义了 activate，deactivate，unmount，pruneCache，pruneCacheEntry，matches，move，以及生命周期函数注册和调用。</p><h3 id="1-1-setup"><a href="#1-1-setup" class="headerlink" title="1.1 setup"></a>1.1 setup</h3><p>setup 会在创建的时候执行，他主要包含了以下功能</p><p>定义了三个变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">cache</span>: <span class="title class_">Cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>() <span class="comment">//缓存</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">keys</span>: <span class="title class_">Keys</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">//字典，存放key</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">VNode</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">//当前的组件</span></span><br></pre></td></tr></table></figure><p>从上下文中拿到了几个方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">renderer</span>: &#123;</span><br><span class="line">    <span class="attr">p</span>: patch,</span><br><span class="line">    <span class="attr">m</span>: move,</span><br><span class="line">    <span class="attr">um</span>: _unmount,</span><br><span class="line">    <span class="attr">o</span>: &#123; createElement &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = sharedContext</span><br></pre></td></tr></table></figure><p>创建容器 <code>const storageContainer = createElement(&#39;div&#39;)</code></p><p>然后创建 <code>activate &amp; deactivate</code> 两个方法到 <code>sharedContext</code> 当中，<code>sharedContext = instance.ctx as KeepAliveContext</code>，也就是当前组件(<strong>keepalive</strong>)的上下文。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharedContext.<span class="property">activate</span> = <span class="function">(<span class="params">...</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line">sharedContext.<span class="property">deactivate</span> = <span class="function">(<span class="params">...</span>) =&gt;</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>然后创建 <code>unmount</code> 方法, 卸载组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unmount</span>(<span class="params">vnode: VNode</span>) &#123;</span><br><span class="line">  <span class="comment">// reset the shapeFlag so it can be properly unmounted</span></span><br><span class="line">  <span class="title function_">resetShapeFlag</span>(vnode)</span><br><span class="line">  <span class="title function_">_unmount</span>(vnode, instance, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pruneCache</code> 用于清理缓存中的组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pruneCache</span>(<span class="params">filter?: (name: <span class="built_in">string</span>) =&gt; <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  cache.<span class="title function_">forEach</span>(<span class="function">(<span class="params">vnode, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">getComponentName</span>(vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>)</span><br><span class="line">    <span class="keyword">if</span> (name &amp;&amp; (!filter || !<span class="title function_">filter</span>(name))) &#123;</span><br><span class="line">      <span class="title function_">pruneCacheEntry</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pruneCacheEntry</code> 清理一个指定的缓存 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pruneCacheEntry</span>(<span class="params">key: CacheKey</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache.<span class="title function_">get</span>(key) <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line">  <span class="keyword">if</span> (!current || !<span class="title function_">isSameVNodeType</span>(cached, current)) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(cached)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current) &#123;</span><br><span class="line">    <span class="comment">// current active instance should no longer be kept-alive.</span></span><br><span class="line">    <span class="comment">// we can&#x27;t unmount it now but it might be later, so reset its flag now.</span></span><br><span class="line">    <span class="title function_">resetShapeFlag</span>(current)</span><br><span class="line">  &#125;</span><br><span class="line">  cache.<span class="title function_">delete</span>(key)</span><br><span class="line">  keys.<span class="title function_">delete</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听 <code>include</code> 和 <code>exclude</code> 属性的变化，根据变化重新清理缓存</p><p>缓存子树，如果 <code>pendingCacheKey</code> 有值，在 <code>Mounted</code>, <code>Updated</code> 这两个生命周期会触发的时候调用 缓存子树的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">pendingCacheKey</span>: <span class="title class_">CacheKey</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cacheSubtree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (pendingCacheKey != <span class="literal">null</span>) &#123;</span><br><span class="line">    cache.<span class="title function_">set</span>(pendingCacheKey, <span class="title function_">getInnerChild</span>(instance.<span class="property">subTree</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">onMounted</span>(cacheSubtree)</span><br><span class="line"><span class="title function_">onUpdated</span>(cacheSubtree)</span><br></pre></td></tr></table></figure><p>然后返回一个方法，相当于一个闭包, 在放回的方法里面</p><p>拿到插槽里面的组件，组件没有或者多以一个，报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!slots.<span class="property">default</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = slots.<span class="title function_">default</span>()</span><br><span class="line"><span class="keyword">const</span> rawVNode = children[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>再拿到对应的方法 <code>const &#123; include, exclude, max &#125; = props</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  (include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">  (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">) &#123;</span><br><span class="line">  current = vnode</span><br><span class="line">  <span class="keyword">return</span> rawVNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不是很懂了，因为在我的逻辑里面，按照他的这个条件，应该是不使用或者不渲染，但是他这边的逻辑其实是，满足这个条件立刻渲染，不使用缓存。</p><p>接下来就是判断是否缓存的问题</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里拿到 key, 然后获取缓存</span></span><br><span class="line"><span class="keyword">const</span> key = vnode.<span class="property">key</span> == <span class="literal">null</span> ? comp : vnode.<span class="property">key</span></span><br><span class="line"><span class="keyword">const</span> cachedVNode = cache.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// 将当前的键赋值给待缓存的键，上面说明了，这里会触发钩子函数中的子树缓存</span></span><br><span class="line">pendingCacheKey = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cachedVNode) &#123;</span><br><span class="line">  <span class="comment">//如果有缓存，复用缓存</span></span><br><span class="line">  vnode.<span class="property">el</span> = cachedVNode.<span class="property">el</span></span><br><span class="line">  vnode.<span class="property">component</span> = cachedVNode.<span class="property">component</span></span><br><span class="line">  <span class="comment">//这里是动画的处理，触发过渡动画的钩子</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">transition</span>) &#123;</span><br><span class="line">    <span class="title function_">setTransitionHooks</span>(vnode, vnode.<span class="property">transition</span>!)</span><br><span class="line">  &#125;</span><br><span class="line">  vnode.<span class="property">shapeFlag</span> |= <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_KEPT_ALIVE</span></span><br><span class="line">  <span class="comment">//更新key</span></span><br><span class="line">  keys.<span class="title function_">delete</span>(key)</span><br><span class="line">  keys.<span class="title function_">add</span>(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//如果没有缓存，加入key，判断max数量，删除多余的缓存。</span></span><br><span class="line">  keys.<span class="title function_">add</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (max &amp;&amp; keys.<span class="property">size</span> &gt; <span class="built_in">parseInt</span>(max <span class="keyword">as</span> <span class="built_in">string</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="title function_">pruneCacheEntry</span>(keys.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是 <code>keep-alive setup</code> 的全貌了, 主要就是声明一些方法，主要是 active, deActive, 和卸载组件，缓存管理的一些方法，并且返回一个函数，用于创建处理插槽中的新组件。</p><h3 id="2-deactivate"><a href="#2-deactivate" class="headerlink" title="2. deactivate"></a>2. deactivate</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sharedContext.<span class="property">deactivate</span> = <span class="function">(<span class="params">vnode: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//获取当前 Vnode 组件</span></span><br><span class="line">  <span class="keyword">const</span> instance = vnode.<span class="property">component</span>! </span><br><span class="line">  <span class="comment">//移动节点到 storageContainer</span></span><br><span class="line">  <span class="title function_">move</span>(vnode, storageContainer, <span class="literal">null</span>, <span class="title class_">MoveType</span>.<span class="property">LEAVE</span>, parentSuspense)</span><br><span class="line">  <span class="comment">// 异步执行</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//deactivate 钩子触发</span></span><br><span class="line">    <span class="keyword">if</span> (instance.<span class="property">da</span>) &#123;</span><br><span class="line">      <span class="title function_">invokeArrayFns</span>(instance.<span class="property">da</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//onVnodeUnmounted 钩子</span></span><br><span class="line">    <span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeUnmounted</span></span><br><span class="line">    <span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">      <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标记 deactived</span></span><br><span class="line">    instance.<span class="property">isDeactivated</span> = <span class="literal">true</span></span><br><span class="line">  &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    <span class="comment">// Update components tree</span></span><br><span class="line">    <span class="title function_">devtoolsComponentAdded</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>deactivate</code> 并没有删除节点，而是移动到了 <code>storageContainer</code>, 然后调用钩子。</p><p>这里我有一个疑问, Vue 如何生成两个组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">startMeasure</span>(instance, <span class="string">`render`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> nextTree = <span class="title function_">renderComponentRoot</span>(instance)</span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">endMeasure</span>(instance, <span class="string">`render`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> prevTree = instance.<span class="property">subTree</span></span><br><span class="line">instance.<span class="property">subTree</span> = nextTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">startMeasure</span>(instance, <span class="string">`patch`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">patch</span>(</span><br><span class="line">  prevTree,</span><br><span class="line">  nextTree,</span><br><span class="line">  <span class="comment">// parent may have changed if it&#x27;s in a teleport</span></span><br><span class="line">  <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>!)!,</span><br><span class="line">  <span class="comment">// anchor may have changed if it&#x27;s in a fragment</span></span><br><span class="line">  <span class="title function_">getNextHostNode</span>(prevTree),</span><br><span class="line">  instance,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也就是说，用新生成的子树和老的子树进行对比，然后解决</p><p>总是说子树, subTree, 那么和 vnode 有什么区别？都是虚拟节点。</p><ul><li>instance.subTree 表示组件的子树的根节点的虚拟节点。</li><li>instance.vnode 表示整个组件的根节点的虚拟节点。</li></ul><p>区别在哪里？一个是子树，一个是当前节点，子树包含当前节点，也包含子组件的。</p><h3 id="3-active"><a href="#3-active" class="headerlink" title="3. active"></a>3. active</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sharedContext.<span class="property">activate</span> = <span class="function">(<span class="params">vnode, container, anchor, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = vnode.<span class="property">component</span>!</span><br><span class="line">  <span class="title function_">move</span>(vnode, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>, parentSuspense)</span><br><span class="line">  <span class="comment">// in case props have changed</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">instance.<span class="property">vnode</span>,</span><br><span class="line">vnode,</span><br><span class="line">container,</span><br><span class="line">anchor,</span><br><span class="line">instance,</span><br><span class="line">parentSuspense,</span><br><span class="line">isSVG,</span><br><span class="line">vnode.<span class="property">slotScopeIds</span>,</span><br><span class="line">optimized</span><br><span class="line">  )</span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">instance.<span class="property">isDeactivated</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (instance.<span class="property">a</span>) &#123;</span><br><span class="line">  <span class="title function_">invokeArrayFns</span>(instance.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeMounted</span></span><br><span class="line"><span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">  <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">&#125;</span><br><span class="line">  &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line"><span class="comment">// Update components tree</span></span><br><span class="line"><span class="title function_">devtoolsComponentAdded</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 instance.vnode 其实是上一个组件，vnode 是需要渲染的组件.</p><p>move 会把 <code>vnode</code> 通过 <code>dom beforeInsert</code> 到 <code>container</code></p><p>patch 会把 <code>vnode.el = instance.vnode.el</code> &amp;&amp; <code>instance.vnode = vnode</code></p><h3 id="4-include-exclude-max"><a href="#4-include-exclude-max" class="headerlink" title="4. include, exclude, max"></a>4. include, exclude, max</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">(include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">(exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">) &#123;</span><br><span class="line">current = vnode</span><br><span class="line"><span class="keyword">return</span> rawVNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>include 和 exclude, max 是在 keep-live setup 函数的返回的函数中, 根据 include，exclude 来判断是否缓存</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keys.<span class="title function_">add</span>(key)</span><br><span class="line"><span class="comment">// prune oldest entry</span></span><br><span class="line"><span class="keyword">if</span> (max &amp;&amp; keys.<span class="property">size</span> &gt; <span class="built_in">parseInt</span>(max <span class="keyword">as</span> <span class="built_in">string</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="title function_">pruneCacheEntry</span>(keys.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>max 会在需要缓存之前，判断是否需要清理缓存。</p><h3 id="5-如何缓存"><a href="#5-如何缓存" class="headerlink" title="5. 如何缓存"></a>5. 如何缓存</h3><p>关键在于 <code>pendingCacheKey</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache sub tree after render</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">pendingCacheKey</span>: <span class="title class_">CacheKey</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cacheSubtree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// fix #1621, the pendingCacheKey could be 0</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCacheKey != <span class="literal">null</span>) &#123;</span><br><span class="line">cache.<span class="title function_">set</span>(pendingCacheKey, <span class="title function_">getInnerChild</span>(instance.<span class="property">subTree</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">onMounted</span>(cacheSubtree)</span><br><span class="line"><span class="title function_">onUpdated</span>(cacheSubtree)</span><br></pre></td></tr></table></figure><p>当组件触发钩子的时候，判断是否需要触发钩子中的缓存。</p><p>如果 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">(exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br></pre></td></tr></table></figure><p>不通过的话，就无法执行 <code>pendingCacheKey = key</code> 和 <code>keys.add(key)</code>.</p><p>也就是说，在 keep-alive 下，组件渲染或者跟新完成后，会开始缓存。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> keep-alive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 reactive</title>
      <link href="/2023/06/29/vue3_reactive/"/>
      <url>/2023/06/29/vue3_reactive/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h1><p>要了解这个东西，你起码需要对 Proxy 和 Reflect 有最基本的了解</p><p>其次，我是真的讨厌三目表达式嵌套。</p><h3 id="01-createReactiveObject"><a href="#01-createReactiveObject" class="headerlink" title="01. createReactiveObject"></a>01. createReactiveObject</h3><p>入口方法是 <code>createReactiveObject</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: Target,</span></span><br><span class="line"><span class="params">  isReadonly: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment">// exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// only specific value types can be observed.</span></span><br><span class="line">  <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>!isObject(target)</code> 不是 <code>Object</code> 返回</p><p><code>target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</code><br><code>target</code> 包含 <code>ReactiveFlags.RAW</code> 并且 不是 <code>readonly</code> 或 <code>target</code> 不包含 <code>ReactiveFlags.IS_REACTIV</code> 返回 target</p><blockquote><p>target 已经是 Proxy，返回它。<br>异常：在反应对象上调用 readonly()</p></blockquote><p>接下来判断是否已经存在这个 <code>proxy</code>, 在 <code>proxyMap</code> 中查找，如果有，直接返回。</p><p>然后判断允许 proxy 的类型</p><blockquote><p>only specific value types can be observed.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">targetTypeMap</span>(<span class="params">rawType: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (rawType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Array&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COMMON</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Set&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;WeakMap&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;WeakSet&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">INVALID</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTargetType</span>(<span class="params">value: Target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>] || !<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value)</span><br><span class="line">    ? <span class="title class_">TargetType</span>.<span class="property">INVALID</span></span><br><span class="line">    : <span class="title function_">targetTypeMap</span>(<span class="title function_">toRawType</span>(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他会把传入分类，判定接收的类型，不是 <code>SKIP</code> 或者不能 操作的值，然后通过 <code>Object.toString().call</code> 判定类型，并且返回 <code>TargetType</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">)</span><br><span class="line">proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line"><span class="keyword">return</span> proxy</span><br></pre></td></tr></table></figure><p>这里比较简单就是代理，并且加入代理的 <code>Map</code></p><h3 id="02-handler"><a href="#02-handler" class="headerlink" title="02. handler"></a>02. handler</h3><p><code>reactive</code>, <code>shallowReactive</code>, <code>readonly</code>, <code>shallowReadonly</code> 都是在这里创建的, 代码都是通过 <code>createReactiveObject</code> 创建, 例如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mutableHandlers</code> &amp; <code>mutableCollectionHandlers</code>, 先看 <code>mutableHandlers</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04-haddler-get"><a href="#04-haddler-get" class="headerlink" title="04. haddler get"></a>04. haddler get</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> shallow</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">          ? shallowReactiveMap</span><br><span class="line">          : reactiveMap</span><br><span class="line">        ).<span class="title function_">get</span>(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      <span class="keyword">if</span> (targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasOwnProperty</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">      <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createSetter</span>()</span><br><span class="line"><span class="keyword">const</span> shallowSet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createSetter</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>createGetter</code> 是一个 <code>get</code> 工厂, 用于个各种 get 创建。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !isReadonly</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> isReadonly</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> shallow</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">    receiver ===</span><br><span class="line">    (isReadonly</span><br><span class="line">        ? shallow</span><br><span class="line">        ? shallowReadonlyMap</span><br><span class="line">        : readonlyMap</span><br><span class="line">        : shallow</span><br><span class="line">        ? shallowReactiveMap</span><br><span class="line">        : reactiveMap</span><br><span class="line">    ).<span class="title function_">get</span>(target)</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断是否是一些特殊值，进行特殊的返回，最后一个判断是如果通过 <code>isReadonly</code> &amp; <code>shallow</code>,来判断应该用哪个 <code>Map</code> 来判断是否需要返回缓存。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasOwnProperty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是 <code>readonly</code>, 是 <code>array</code> 并且 <code>arrayInstrumentations</code> 包含 <code>key</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br></pre></td></tr></table></figure><p>如果是 key &#x3D;&#x3D;&#x3D; ‘hasOwnProperty’, 则返回使用这个方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasOwnProperty</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">object</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="title function_">track</span>(obj, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key)</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="title function_">hasOwnProperty</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说的是 <code>arrayInstrumentations</code>, 他劫持了设计者想要代理的方法</p><blockquote><p>这个方法的主要作用是为了拦截一些对数组进行操作的方法，例如 push、pop、shift 等，以及一些查询数组的方法，例如 includes、indexOf、lastIndexOf 等。当对这些方法进行操作时，会调用 track 方法来收集数组的依赖关系，并在需要时通过 trigger 方法触发重新渲染视图。</p><p>同时，当调用这些方法时也需要注意避免无限循环的问题，因为一些数组操作可能会导致长度改变，从而导致重新触发这些方法。为了避免这种情况，对于长度变化的操作方法，例如 push、pop、shift 等，会在方法执行前暂停依赖追踪，执行完毕后再恢复依赖追踪。</p><p>最终，createArrayInstrumentations 方法会返回一个对象，该对象包含针对数组对象的代理方法，例如 push、pop、shift、unshift、splice、includes、indexOf、lastIndexOf 等。这些方法被用于在 reactive、shallowReactive、readonly 和 shallowReadonly 等响应式数据类型中对数组对象进行拦截和代理。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">instrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;&#125;</span><br><span class="line">  <span class="comment">// instrument identity-sensitive Array methods to account for possible reactive</span></span><br><span class="line">  <span class="comment">// values</span></span><br><span class="line">  ;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// we run the method using the original args first (which may be reactive)</span></span><br><span class="line">      <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">      <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// if that didn&#x27;t work, run it again using raw values.</span></span><br><span class="line">        <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class="line">  <span class="comment">// which leads to infinite loops in some cases (#2137)</span></span><br><span class="line">  ;([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">      <span class="title function_">pauseTracking</span>()</span><br><span class="line">      <span class="keyword">const</span> res = (<span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> <span class="built_in">any</span>)[key].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      <span class="title function_">resetTracking</span>()</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上半部分是将 提供 <code>[&#39;includes&#39;, &#39;indexOf&#39;, &#39;lastIndexOf&#39;]</code> 方法的劫持，添加 <code>tarck</code> 之后返回。</p><p>下半部分在 <code>[&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;]</code> 执行的时候暂停和恢复 <code>track</code> </p><p>在完成了类数组的劫持后, <code>const res = Reflect.get(target, key, receiver)</code> 通过反射获取本应该取到的值。</p><p>接下来 <code>if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</code> </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="comment">/*#__PURE__*/</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Symbol</span>)</span><br><span class="line">    <span class="comment">// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate &#x27;arguments&#x27; and &#x27;caller&#x27;</span></span><br><span class="line">    <span class="comment">// but accessing them on Symbol leads to TypeError because Symbol is a strict mode</span></span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&#x27;arguments&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;caller&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="title class_">Symbol</span> <span class="keyword">as</span> <span class="built_in">any</span>)[key])</span><br><span class="line">    .<span class="title function_">filter</span>(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isNonTrackableKeys = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(<span class="string">`__proto__,__v_isRef,__isVue`</span>)</span><br></pre></td></tr></table></figure><p>主要作用是用来判断关键字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">    <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">    <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">    <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">    <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">    <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">    <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>接下来就是判断和追踪，定义其他的返回或者返回的包装。</p><p><strong>重新回顾一下，这个方法做了什么</strong></p><ol><li>判断 key <code>IS_REACTIVE</code> or <code>IS_READONLY</code> or <code>IS_SHALLOW</code> 返回对应值</li><li>根据参数查找缓存，有缓存返回缓存</li><li>!Readonly 并且是 数组，并且是这些 key [‘includes’, ‘indexOf’, ‘lastIndexOf’]，[‘push’, ‘pop’, ‘shift’, ‘unshift’, ‘splice’] 通过 arrayInstrumentations 来劫持和追踪。</li><li>通过反射拿到值</li><li>判断 key is Symbol， 如果是属于某些 Symbol 属性或者 <code>__proto__,__v_isRef,__isVue</code>， 直接返回</li><li>!Readonly 情况加入 track</li><li>!!shallow 返回值</li><li>!!ref .value 返回值</li><li>!!object 返回值也要包装成响应式</li><li>返回</li></ol><p>通过源码分析一下差别</p><p>readonly 不加入 track, 允许 get, 返回值也要包装成 readonly(res)<br>shallow + readonly, 不加入 track, 允许get，不处理返回值<br>reactive 加入 track, 允许get, 返回值 reactive(res)<br>shallow + reactive, 加入 track, 允许get, 返回值不处理。</p><p>还可以看到关于</p><p>这里就是一个 <code>get</code>, 其他 get 大都也是由这个工厂来组成。这差不在于参数的差别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const get = /*#__PURE__*/ createGetter()</span><br><span class="line">const shallowGet = /*#__PURE__*/ createGetter(false, true)</span><br><span class="line">const readonlyGet = /*#__PURE__*/ createGetter(true)</span><br><span class="line">const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)</span><br></pre></td></tr></table></figure><p>这里有一个规则，对应着 <strong>vue</strong> 的判断</p><blockquote><p>isReadonly &amp;&amp; shallow &#x3D; shallowReadonly<br>isReadonly &amp;&amp; !shallow &#x3D; readonly<br>!isReadonly &amp;&amp; shallow &#x3D; shallow<br>!isReadonly &amp;&amp; !shallow &#x3D; reactiveMap</p></blockquote><h3 id="05-handler-set"><a href="#05-handler-set" class="headerlink" title="05. handler set"></a>05. handler set</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">    receiver: <span class="built_in">object</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value) &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">        oldValue = <span class="title function_">toRaw</span>(oldValue)</span><br><span class="line">        value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        oldValue.<span class="property">value</span> = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">      <span class="comment">// 在浅层模式下，无论反应与否，对象都按原样设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">        : <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code> 相对简单一些</p><ol><li>拿到老值</li><li>!!readonly retrun false</li><li>isRef(oldValue) &amp;&amp; !isRef(value) return false</li><li>!shallow 不是 shallow 也不是 readonly, 赋值 oldValue， value.</li><li>!shallow 不是数组，isRef(oldValue) &amp;&amp; !isRef(value) oldValue.value &#x3D; value</li><li>haskey 验证了key 是否存在，不管是数组还是object</li><li>反射set, 得到result</li><li>对比原始对象，如果不一致不触发</li><li>hadKey trigger</li><li>!hadKey &amp;&amp; 新旧值不一致 trigger</li></ol><h3 id="06-handler-other"><a href="#06-handler-other" class="headerlink" title="06. handler other"></a>06. handler other</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">  <span class="keyword">const</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isSymbol</span>(key) || !builtInSymbols.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: <span class="built_in">object</span></span>): (<span class="built_in">string</span> | <span class="built_in">symbol</span>)[] &#123;</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="title function_">isArray</span>(target) ? <span class="string">&#x27;length&#x27;</span> : <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07-问题"><a href="#07-问题" class="headerlink" title="07. 问题"></a>07. 问题</h3><p>关于 <code>toRaw</code> 我知道他是去找原生对象, 但是确实没找到赋值的地方。</p><p>还有就是不太明白代理一些遍历的属性干什么, 有什么作用？</p><p>还是需要后面带着问题去读一下。</p><h3 id="08-总结"><a href="#08-总结" class="headerlink" title="08. 总结"></a>08. 总结</h3><p>我这里并没有看 collectionHandlers.ts 代码，不然写的太长了</p><p><code>reactive</code> 不支持 <code>typeof x != object</code> 的参数， 只接受 <code>Object，Array，Map，Set，WeakMap，WeakSet</code> 类型，其他类型直接不做响应式处理。</p><p>这里说明了基础类型应该使用 ref，非基础类型应该使用 reactive, 按照之前的 ref 的源码</p><p>通过看 ref.ts 和 reactive.ts 源码知道了一些东西。</p><ol><li>ref get set 触发响应式，如果改里面的东西，通过 reactive 触发响应式。</li><li>reactive 通过 Proxy 代理触发响应式</li><li>带有 shallow 表示只处理浅层。</li><li>因为机制问题，建议 ref 用基础类型，复杂类型使用 reactive</li><li>readonly 是通过 proxy get 返回 readony(v) ，set，delete 代理来保证只读。</li><li>reactive 只支持 Object, Array, Map, Set, WeakMap, WeakSet 的响应式，其他不会劫持。</li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 源码 </tag>
            
            <tag> reactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 ref</title>
      <link href="/2023/06/29/vue3_ref/"/>
      <url>/2023/06/29/vue3_ref/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><h3 id="01-代码"><a href="#01-代码" class="headerlink" title="01. 代码"></a>01. 代码</h3><p><strong>packages\reactivity\src\ref.ts</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue =</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal)</span><br><span class="line">    newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是 <code>ref</code> 核心代码, 不管是创建 <code>ref</code> 或者 <code>shallowRef</code> 都是通过 <code>RefImpl</code> 去实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function shallowRef(value?: unknown) &#123;</span><br><span class="line">  return createRef(value, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRef(rawValue: unknown, shallow: boolean) &#123;</span><br><span class="line">  if (isRef(rawValue)) &#123;</span><br><span class="line">    return rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  return new RefImpl(rawValue, shallow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看他的<strong>构造函数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要知道 <code>toRaw</code> 和 <code>toReactive</code> 是做什么的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">ReactiveFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">SKIP</span> = <span class="string">&#x27;__v_skip&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">IS_REACTIVE</span> = <span class="string">&#x27;__v_isReactive&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">IS_READONLY</span> = <span class="string">&#x27;__v_isReadonly&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">IS_SHALLOW</span> = <span class="string">&#x27;__v_isShallow&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">RAW</span> = <span class="string">&#x27;__v_raw&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>]?: <span class="built_in">boolean</span></span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>]?: <span class="built_in">boolean</span></span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]?: <span class="built_in">boolean</span></span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>]?: <span class="built_in">boolean</span></span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]?: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SKIP：用于标记不需要代理为响应式的属性<br>IS_REACTIVE：用于标记对象是否为响应式的<br>IS_READONLY：用于标记对象是否为只读的<br>IS_SHALLOW：用于标记对象是否进行了浅层代理<br>RAW：用于存储对象的原始值，方便在需要时获取</p></blockquote><p>这里理解为一个对象有标记，比如对象是 <code>let o = &#123; a:1 &#125;</code>，那么这些标记，就是表示对象的属性，意义如上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">const</span> raw = observed &amp;&amp; (observed <span class="keyword">as</span> <span class="title class_">Target</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line">  <span class="keyword">return</span> raw ? <span class="title function_">toRaw</span>(raw) : observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toRaw</code> 就是递归获取用于存储对象的原始值。</p><p>接下来就是 <code>toReactive</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toReactive = &lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt;(<span class="attr">value</span>: T): <span class="function"><span class="params">T</span> =&gt;</span></span><br><span class="line">  <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br></pre></td></tr></table></figure><p><strong>packages\reactivity\src\reactive.ts</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是如果是一个 <code>object</code> 直接将对象响应式, 也就是 <code>reactive</code>, 会把对象转为 <code>proxy</code></p><p>现在我们回到构造函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>__v_isShallow</code> <strong>true</strong>, 也就是 <code>shallowRef</code>, 两个值会存储原始值<br>如果是 <code>__v_isShallow</code> <strong>false</strong>, 也就是 <code>ref</code></p><p>this._rawValue &#x3D; value的原始值<br>this._value &#x3D; 转换为 <code>reactive</code> 对象</p><p><strong>取值和赋值</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue =</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal)</span><br><span class="line">    newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又出来了两个新的方法，<code>trackRefValue</code> 和 <code>triggerRefValue</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    ref = <span class="title function_">toRaw</span>(ref)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()), &#123;</span><br><span class="line">        <span class="attr">target</span>: ref,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;, newVal?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  ref = <span class="title function_">toRaw</span>(ref)</span><br><span class="line">  <span class="keyword">const</span> dep = ref.<span class="property">dep</span></span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(dep, &#123;</span><br><span class="line">        <span class="attr">target</span>: ref,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">        <span class="attr">newValue</span>: newVal</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(dep)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Vue2.0当中，会在 <code>Object.defineProperty</code> 通过 <code>get</code> 和 <code>set</code> 劫持去解决响应式的核心问题，至少现在来说 <code>ref</code> 其实是通过访问器中添加代码去解决的的, <code>get trackRefValue</code> 收集依赖，<code>set triggerEffects</code> 触发依赖，然后回调。</p><p>鉴于目前，我还不是很清楚其中实现过程，先暂时简单的理解为下面内容</p><blockquote><p>trackRefValue 函数用于追踪响应式引用对象的变化依赖，将当前活动的副作用函数（即当前调用 trackRefValue 函数的函数）添加到响应式引用对象的依赖集合中。在引用对象的值被修改时，会触发相关的依赖执行回调函数。</p><p>triggerRefValue 函数用于触发响应式引用对象的依赖更新，会依次执行响应式引用对象的所有依赖，调用它们的回调函数，以实现响应式数据的自动更新。同时，它还会触发依赖于引用对象的 computed 以及 watchEffect 等响应式函数的更新。</p></blockquote><p>在大概清楚了这个概念以后，我们可以回过头看访问器。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>dep</code> 中新增一个依赖，然后返回 <code>_value</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue =</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal)</span><br><span class="line">    newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>newVal</code> ， <code>this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)</code></p><blockquote><p>IS_READONLY：用于标记对象是否为只读的<br>IS_SHALLOW：用于标记对象是否进行了浅层代理</p></blockquote><p>主要用于区分是否是浅层代理，如果是 <code>newVal</code> 等于本身，如果不是，通过 <code>toRaw</code> 返回原始值</p><p>接下来对比新的值和原始值是否一致，如果不一致</p><p>存储原始值，并且根据 useDirectValue，是否响应式处理 newVal, 最后触发追踪，更新。</p><h3 id="02-梳理"><a href="#02-梳理" class="headerlink" title="02. 梳理"></a>02. 梳理</h3><p><code>RefImpl</code> 只提供 value 访问器</p><p>如果是 shallowRef, 并不对值做响应式处理，他的响应式只是在 get，set 中进行依赖收集和触发，你输入什么，那么我接收什么，我也返回什么。</p><p>如果是 ref, 在 shallowRef 的基础之上，增加了对于值的响应式，输入值，返回响应式处理以后的值，其他一样。</p><p>所以 ref 和 shallowRef 两者的相同和不同就很明显了。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 源码 </tag>
            
            <tag> ref </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue destroyed vs onUnmounted</title>
      <link href="/2023/06/29/vue_destroyed_onUnmounted/"/>
      <url>/2023/06/29/vue_destroyed_onUnmounted/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue-destroyed-vs-onUnmounted"><a href="#vue-destroyed-vs-onUnmounted" class="headerlink" title="vue destroyed vs onUnmounted"></a>vue destroyed vs onUnmounted</h1><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br>deactivated -&gt; onDeactivated<br>errorCaptured -&gt; onErrorCaptured</p><h3 id="Vue3-x-onUnmounted"><a href="#Vue3-x-onUnmounted" class="headerlink" title="Vue3.x onUnmounted"></a>Vue3.x onUnmounted</h3><p>首先之前就知道了卸载流程怎么触发的</p><p>v-if 的话， <code>proxy set =&gt; trigger =&gt; effect =&gt; effect.scheduler() =&gt; effect.run() =&gt; componentUpdateFn =&gt; patch =&gt; unmount =&gt; 触发 unmountComponent 函数</code> </p><p>那继续看带注释的 <code>unmountComponent</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unmountComponent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  doRemove?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 检查组件是否存在热模块替换标识，如果存在则注销热模块替换</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; instance.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">    <span class="title function_">unregisterHMR</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从组件实例中获取相关属性</span></span><br><span class="line">  <span class="keyword">const</span> &#123; bum, scope, update, subTree, um &#125; = instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发组件的 beforeUnmount 钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (bum) &#123;</span><br><span class="line">    <span class="title function_">invokeArrayFns</span>(bum)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用了兼容模式，并且该组件启用了实例事件钩子（已废弃）</span></span><br><span class="line">  <span class="comment">// 触发组件的 beforeDestroy 事件</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __COMPAT__ &amp;&amp;</span><br><span class="line">    <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">  ) &#123;</span><br><span class="line">    instance.<span class="title function_">emit</span>(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止组件实例的作用域内的副作用函数的执行</span></span><br><span class="line">  scope.<span class="title function_">stop</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果组件实例的更新函数存在</span></span><br><span class="line">  <span class="keyword">if</span> (update) &#123;</span><br><span class="line">    <span class="comment">// 将更新函数的 active 属性设为 false，使调度程序不再调用它</span></span><br><span class="line">    update.<span class="property">active</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 调用 unmount 函数卸载组件的子树</span></span><br><span class="line">    <span class="title function_">unmount</span>(subTree, instance, parentSuspense, doRemove)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发组件的 unmounted 钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (um) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(um, parentSuspense)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用了兼容模式，并且该组件启用了实例事件钩子（已废弃）</span></span><br><span class="line">  <span class="comment">// 触发组件的 destroyed 事件</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __COMPAT__ &amp;&amp;</span><br><span class="line">    <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&#x27;hook:destroyed&#x27;</span>),</span><br><span class="line">      parentSuspense</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将组件实例的 isUnmounted 属性设为 true</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    instance.<span class="property">isUnmounted</span> = <span class="literal">true</span></span><br><span class="line">  &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用了 SUSPENSE 特性，并且存在父级悬挂点、挂起分支未解决、</span></span><br><span class="line">  <span class="comment">// 组件实例存在异步依赖项、异步依赖项未解决，并且该组件实例的 suspenseId 等于</span></span><br><span class="line">  <span class="comment">// 父级悬挂点的 pendingId，则处理悬挂点的依赖项</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __FEATURE_SUSPENSE__ &amp;&amp;</span><br><span class="line">    parentSuspense &amp;&amp;</span><br><span class="line">    parentSuspense.<span class="property">pendingBranch</span> &amp;&amp;</span><br><span class="line">    !parentSuspense.<span class="property">isUnmounted</span> &amp;&amp;</span><br><span class="line">    instance.<span class="property">asyncDep</span> &amp;&amp;</span><br><span class="line">    !instance.<span class="property">asyncResolved</span> &amp;&amp;</span><br><span class="line">    instance.<span class="property">suspenseId</span> === parentSuspense.<span class="property">pendingId</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    parentSuspense.<span class="property">deps</span>--</span><br><span class="line">    <span class="keyword">if</span> (parentSuspense.<span class="property">deps</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      parentSuspense.<span class="title function_">resolve</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是开发环境或者启用了生产/开发工具的特性，通知开发工具该组件已被移除</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    <span class="title function_">devtoolsComponentRemoved</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面注释其实已经说的很清楚</p><ol><li>scope.stop() &#x2F;&#x2F;停止副作用函数</li><li>unmount(subTree, instance, parentSuspense, doRemove) &#x2F;&#x2F; 调用 unmount 函数卸载组件的子树</li><li>instance.isUnmounted &#x3D; true</li></ol><p>主要就这几个，这里有一个概念 EffectScope，在 Vue2.x 中也有类似的概念</p><blockquote><p>EffectScope（效果作用域）是用于管理副作用函数（effects）的工具。它提供了一种将副作用函数组织在一起并控制其执行的机制。</p><p>在 Vue 3 中，组件内部的副作用函数（如 onMounted、onUpdated、onUnmounted 等）被称为“副作用”（effects）。副作用可以是一些具有副作用的操作，例如订阅事件、发送网络请求、操作 DOM 等。</p><p>EffectScope 提供了以下功能：</p><p>创建效果作用域：使用 createScope 函数可以创建一个新的效果作用域。</p><p>开始和停止副作用函数的执行：在组件实例中，通过调用效果作用域的 run 方法可以开始执行副作用函数，调用 stop 方法可以停止执行副作用函数。</p><p>批量执行副作用函数：EffectScope 允许将多个副作用函数分组，然后一次性启动它们的执行，这样可以确保它们按照正确的顺序执行。</p><p>嵌套效果作用域：可以在一个效果作用域内创建另一个效果作用域，形成嵌套结构。嵌套的效果作用域可以独立运行，可以在父作用域停止时自动停止。</p></blockquote><p>大概知道就行了，后面会专门看一看这个，简单理解就是管理组件上的副作用函数。</p><p>unmount 是递归去卸载子树，就是一个一个卸载，ref，KeepAliveContext，unmountComponent，处理SUSPENSE，TELEPORT，Fragment，动态子节点，并且直接删除 vnode。</p><p>还调用了各种钩子函数，这就是大概的卸载节点的过程，当然这里谈的主要是钩子函数，所以可能中间很多点是不会触发的。</p><h3 id="Vue2-x-destroyed"><a href="#Vue2-x-destroyed" class="headerlink" title="Vue2.x destroyed"></a>Vue2.x destroyed</h3><p>之前已经知道了大概触发流程 <code>patch =&gt; removeNodes =&gt; Vue.prototype.$destroy</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="line">vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// remove self from parent</span></span><br><span class="line"><span class="keyword">const</span> parent = vm.<span class="property">$parent</span></span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !parent.<span class="property">_isBeingDestroyed</span> &amp;&amp; !vm.<span class="property">$options</span>.<span class="property">abstract</span>) &#123;</span><br><span class="line">  <span class="title function_">remove</span>(parent.<span class="property">$children</span>, vm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// teardown scope. this includes both the render watcher and other</span></span><br><span class="line"><span class="comment">// watchers created</span></span><br><span class="line">vm.<span class="property">_scope</span>.<span class="title function_">stop</span>()</span><br><span class="line"><span class="comment">// remove reference from data ob</span></span><br><span class="line"><span class="comment">// frozen object may not have observer.</span></span><br><span class="line"><span class="keyword">if</span> (vm.<span class="property">_data</span>.<span class="property">__ob__</span>) &#123;</span><br><span class="line">  vm.<span class="property">_data</span>.<span class="property">__ob__</span>.<span class="property">vmCount</span>--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call the last hook...</span></span><br><span class="line">vm.<span class="property">_isDestroyed</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">vm.<span class="title function_">__patch__</span>(vm.<span class="property">_vnode</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// fire destroyed hook</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>ok, 不存在什么异步，就直接触发了， 那我们来看他做了什么？</p><p>删除 parent.$childre 关于vm的引用, remove 就是一个单纯的数组方法.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !parent.<span class="property">_isBeingDestroyed</span> &amp;&amp; !vm.<span class="property">$options</span>.<span class="property">abstract</span>) &#123;</span><br><span class="line">  <span class="title function_">remove</span>(parent.<span class="property">$children</span>, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止 watch, _scope 是 EffectScope， 然后调用 watcher.teardown(), 调用 this.cleanups 清理函数， 如果 scope 在，就遍历清理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">_scope</span>.<span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure><p>从数据对象的观察者（__ob__）中移除对组件的引用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.<span class="property">_data</span>.<span class="property">__ob__</span>) &#123;</span><br><span class="line">  vm.<span class="property">_data</span>.<span class="property">__ob__</span>.<span class="property">vmCount</span>--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 vm.<strong>patch</strong> 方法将当前组件的虚拟节点（_vnode）设置为 null，用于解除组件与虚拟 DOM 的关联</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="title function_">__patch__</span>(vm.<span class="property">_vnode</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里简单介绍了一下 Vue2,3 卸载组件的过程，都是类似的流程，只是方法换了，但是流程没有变。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> destroyed </tag>
            
            <tag> onUnmounted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue beforeDestroy vs onBeforeUnmount</title>
      <link href="/2023/06/28/vue_beforeDestroy_onBeforeUnmount/"/>
      <url>/2023/06/28/vue_beforeDestroy_onBeforeUnmount/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue-beforeDestroy-vs-onBeforeUnmount"><a href="#vue-beforeDestroy-vs-onBeforeUnmount" class="headerlink" title="vue beforeDestroy vs onBeforeUnmount"></a>vue beforeDestroy vs onBeforeUnmount</h1><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br>deactivated -&gt; onDeactivated<br>errorCaptured -&gt; onErrorCaptured</p><h3 id="vue3-x-onBeforeUnmount"><a href="#vue3-x-onBeforeUnmount" class="headerlink" title="vue3.x onBeforeUnmount"></a>vue3.x onBeforeUnmount</h3><p>这个的生命周期其实和 update 类似，注销组件我能想到的就是 v-if, component is 这两种办法。</p><p>v-if 通过 update 一样的方式触发，只是 patch 当中会调用 unmount 然后判断到是组件，调用 unmountComponent.</p><p>component is 方式不清楚，反正肯定需要调用 patch。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unmountComponent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  doRemove?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; instance.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">    <span class="title function_">unregisterHMR</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; bum, scope, update, subTree, um &#125; = instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// beforeUnmount hook</span></span><br><span class="line">  <span class="keyword">if</span> (bum) &#123;</span><br><span class="line">    <span class="title function_">invokeArrayFns</span>(bum)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///...</span></span><br></pre></td></tr></table></figure><p>这就调用了, </p><h3 id="Vue2-x-beforeDestroy"><a href="#Vue2-x-beforeDestroy" class="headerlink" title="Vue2.x beforeDestroy"></a>Vue2.x beforeDestroy</h3><p>我这边也是通过 v-if 触发 Object.defineProperty, 然后创建响应式的时候，创建了 Dep，通过 Dep 通知 watcher。</p><p>触发 patch, 然后对比</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span></span><br><span class="line">  <span class="title function_">addVnodes</span>(</span><br><span class="line">    parentElm,</span><br><span class="line">    refElm,</span><br><span class="line">    newCh,</span><br><span class="line">    newStartIdx,</span><br><span class="line">    newEndIdx,</span><br><span class="line">    insertedVnodeQueue</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  <span class="title function_">removeVnodes</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 remove 流程开始, 最后话触发到 <code>Vue.prototype.$destroy</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue3.x 通过 <code>patch =&gt; unmount =&gt; unmountComponent</code> 触发</p><p>Vue2.x 通过 <code>patch =&gt; removeVnodes =&gt; invokeDestroyHook =&gt; Vue.prototype.$destroy</code> 触发</p><p>我使用 v-if 测试，所以都是由劫持(Object.defineProperty or proxy) &#x3D;&gt; Dep &#x3D;&gt; watcher or effect &#x3D;&gt; patch &#x3D;&gt; 上面的过程。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> beforeDestroy </tag>
            
            <tag> onBeforeUnmount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue updated vs onUpdated</title>
      <link href="/2023/06/28/vue_updated_onUpdated/"/>
      <url>/2023/06/28/vue_updated_onUpdated/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue-updated-vs-onUpdated"><a href="#vue-updated-vs-onUpdated" class="headerlink" title="vue updated vs onUpdated"></a>vue updated vs onUpdated</h1><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br>deactivated -&gt; onDeactivated<br>errorCaptured -&gt; onErrorCaptured</p><h3 id="vue3-x-onUpdate"><a href="#vue3-x-onUpdate" class="headerlink" title="vue3.x onUpdate"></a>vue3.x onUpdate</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123; <span class="comment">// 如果组件实例未挂载</span></span><br><span class="line">    <span class="comment">//创建组件</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新组件</span></span><br><span class="line">    <span class="keyword">if</span> (bu) &#123; <span class="comment">// 如果 beforeUpdate 钩子存在</span></span><br><span class="line">      <span class="title function_">invokeArrayFns</span>(bu) <span class="comment">// 调用 invokeArrayFns 函数，依次执行 beforeUpdate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      prevTree,</span><br><span class="line">      nextTree,</span><br><span class="line">      <span class="comment">// parent may have changed if it&#x27;s in a teleport</span></span><br><span class="line">      <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>!)!,</span><br><span class="line">      <span class="comment">// anchor may have changed if it&#x27;s in a fragment</span></span><br><span class="line">      <span class="title function_">getNextHostNode</span>(prevTree),</span><br><span class="line">      instance,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG</span><br><span class="line">    ) <span class="comment">// 执行 patch 函数，进行 DOM 的创建或更新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u) &#123; <span class="comment">// 如果 updated 钩子存在</span></span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(u, parentSuspense) <span class="comment">// 将 updated 钩子函数添加到 post 钩子队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isAsyncWrapper</span>(vnode) &amp;&amp; (vnodeHook = next.<span class="property">props</span> &amp;&amp; next.<span class="property">props</span>.<span class="property">onVnodeUpdated</span>)) &#123; <span class="comment">// 如果不是异步组件的 VNode，并且存在 onVnodeUpdated 钩子</span></span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">        <span class="function">() =&gt;</span> <span class="title function_">invokeVNodeHook</span>(vnodeHook!, parent, next!, vnode),</span><br><span class="line">        parentSuspense</span><br><span class="line">      ) <span class="comment">// 将 onVnodeUpdated 钩子函数添加到 post 钩子队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__COMPAT__ &amp;&amp; <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)) &#123; <span class="comment">// 如果兼容模式开启，并且兼容选项 DEPRECATION.INSTANCE_EVENT_HOOKS 启用</span></span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">        <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&#x27;hook:updated&#x27;</span>),</span><br><span class="line">        parentSuspense</span><br><span class="line">      ) <span class="comment">// 将 hook:updated 事件添加到 post 钩子队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是再 <code>patch</code> 更新组件完成，然后调用 <code>beforeUpdate</code>, 这就是钩子插入的过程。</p><p>调用就要看 <code>ref or reactive</code>，会在 <code>set</code> 的时候 <code>triggerRefValue(this, newVal);</code> 然后 <code>triggerEffects</code>, 然后找到<br><code>effect2.scheduler();</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">  instance.<span class="property">scope</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>ok，现在可以来说一说基本的调用过程了，这是基本的创建</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">  instance.<span class="property">scope</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">SchedulerJob</span> = (instance.<span class="property">update</span> = <span class="function">() =&gt;</span> effect.<span class="title function_">run</span>())</span><br></pre></td></tr></table></figure><p>在写入属性的时候触发 proxy 的时候，触发 set </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triggerRefValue(this, newVal);</span><br></pre></td></tr></table></figure><p>需要知道 ref, reactive 在创建的时候是创建的 dep，用于记录关联，所以触发的时候 this.dep 可以调用找到当前的 reactvice. </p><p>然后就可以调用 <code>triggerEffect</code>, 触发 <code>effect.scheduler()</code>, 也就是 <code>queueJob(update)</code>.</p><p>这里里面会触发调度任务，会把 update 触发</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !queue.<span class="property">length</span> ||</span><br><span class="line">    !queue.<span class="title function_">includes</span>(</span><br><span class="line">      job,</span><br><span class="line">      isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (job.<span class="property">id</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(job)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue.<span class="title function_">splice</span>(<span class="title function_">findInsertionIndex</span>(job.<span class="property">id</span>), <span class="number">0</span>, job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">queueFlush</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用 <code>flushJobs</code>, 里面会不停的循环 <code>queue</code>, 执行里面的 <code>function</code>。</p><p>在全部执行完成以后执行 <code>flushPostFlushCbs(seen)</code>。</p><p>于是就触发刚才插入的钩子函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (u) &#123; <span class="comment">// 如果 updated 钩子存在</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(u, parentSuspense) <span class="comment">// 将 updated 钩子函数添加到 post 钩子队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue2-x-updated"><a href="#vue2-x-updated" class="headerlink" title="vue2.x updated"></a>vue2.x updated</h3><p>这里需要大概知道 Vue2 的一些核心概念， <code>wathcer &amp; dep</code>，也就是 <em>Vue2.x</em> 更新的核心概念</p><p><a href="/tblog/2023/06/27/vue2_watch/">watcher</a>, <a href="/tblog/2023/06/27/vue2_Dep/">dep</a> 这两篇文章是之前我看 Vue2.x 的源码的时候写的，包含代码注释。</p><p>可以简单理解为是一个发布-订阅的关系，在之前看代码中，我们知道有在创建组件的函数中 <code>mountComponent</code> 当中，会新建 <code>wathcer</code>.</p><p>在组件的创建完成以后，你访问属性，会通过 <code>Object.defineProperty</code> 劫持，然后创建 Dep。通过下面代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addDep</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 watcher 建立联系。</p><p>如果属性发生变化，通过 <code>Object.defineProperty</code> 劫持发现，然后通知 dep，然后通知 <code>watcher，watcher.update()</code>.</p><p>为什么要知道这个？ 因为这个钩子就是通过 <code>watcher.update()</code> 触发的，总得简单知道他是怎么触发的吧。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒加载就是下次获取的更新，一个同步，一个异步(队列)。</p><p><code>queueWatcher</code> 中往 <code>queue.push(watcher)</code>, 然后调用 <code>flushSchedulerQueue</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.<span class="property">length</span>; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.<span class="property">before</span>) &#123;</span><br><span class="line">      watcher.<span class="title function_">before</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.<span class="property">id</span></span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.<span class="title function_">run</span>()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; <span class="variable constant_">MAX_UPDATE_COUNT</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> +</span><br><span class="line">            (watcher.<span class="property">user</span></span><br><span class="line">              ? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span>),</span><br><span class="line">          watcher.<span class="property">vm</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line"><span class="keyword">const</span> activatedQueue = activatedChildren.<span class="title function_">slice</span>()</span><br><span class="line"><span class="keyword">const</span> updatedQueue = queue.<span class="title function_">slice</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">resetSchedulerState</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// call component updated and activated hooks</span></span><br><span class="line"><span class="title function_">callActivatedHooks</span>(activatedQueue)</span><br><span class="line"><span class="title function_">callUpdatedHooks</span>(updatedQueue) <span class="comment">//触发updated</span></span><br><span class="line"><span class="title function_">cleanupDeps</span>()</span><br></pre></td></tr></table></figure><p>这个时候就可以开始说了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(queue..) &#123;</span><br><span class="line">    <span class="keyword">if</span> (watcher.<span class="property">before</span>) &#123;</span><br><span class="line">      watcher.<span class="title function_">before</span>() <span class="comment">//触发before</span></span><br><span class="line">    &#125;</span><br><span class="line">    watcher.<span class="title function_">run</span>() <span class="comment">//触发更新函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callActivatedHooks</span>(activatedQueue) <span class="comment">//触发 active 钩子</span></span><br><span class="line"><span class="title function_">callUpdatedHooks</span>(updatedQueue) <span class="comment">//触发 update钩子</span></span><br></pre></td></tr></table></figure><p>这个就是执行的过程,</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比 Vue2 和 Vue3 的实现，其实本质上还是两个版本核心实现的差别</p><p>都是通过 <code>mountComponent</code> 实现创建更新的函数，不过一个是 <code>watcher</code> 一个是 <code>effect</code>. <code>dep</code> 功能有差异。</p><p>然后都是通过 <code>set</code> 的时候触发， 这里区别又来了。</p><p><strong>Vue2.x</strong> <code>set</code> 通过创建的 <code>dep</code> ，通知对应的 <code>watcher</code>, 然后调用 <code>watcher.update()</code>, 在触发 <code>flushSchedulerQueue</code>。</p><p><strong>Vue3.x</strong> 也是通过 <code>set</code> 触发 <code>triggerRefValue(this, newVal)</code>, 然后找到 <code>effect.scheduler()</code>, 执行 <code>update</code> 函数， 更新函数，更新完成以后调用生命周期</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> updated </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x Dep</title>
      <link href="/2023/06/27/vue2_Dep/"/>
      <url>/2023/06/27/vue2_Dep/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue2-x-Dep"><a href="#vue2-x-Dep" class="headerlink" title="vue2.x Dep"></a>vue2.x Dep</h1><h3 id="01-Dep"><a href="#01-Dep" class="headerlink" title="01. Dep"></a>01. Dep</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="comment">//静态属性 target 用来存放当前正在计算的 Watcher。</span></span><br><span class="line">  <span class="keyword">static</span> target?: <span class="title class_">DepTarget</span> | <span class="literal">null</span></span><br><span class="line">  <span class="comment">//构造函数生成，每个Dep实例的唯一ID</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">//用来存放所有订阅了该 Dep 实例的 Watcher。</span></span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">DepTarget</span> | <span class="literal">null</span>&gt;</span><br><span class="line">  <span class="comment">//pending subs cleanup</span></span><br><span class="line">  <span class="comment">//一个标志位，用来标识是否有订阅者需要被清除。</span></span><br><span class="line">  _pending = <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数，用来初始化 id 和 subs。</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加订阅者，把 Watcher 添加到 subs 中。</span></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub: DepTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除订阅者，把 Watcher 从 subs 中移除。</span></span><br><span class="line">  <span class="comment">//由于移除订阅者的操作可能会影响到遍历 subs，所以这里采用了标记位的方式，把要移除的 Watcher 标记为 null，然后在下一次 scheduler flush 的时候再进行清除。</span></span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub: DepTarget</span>) &#123;</span><br><span class="line">    <span class="comment">// #12696 deps with massive amount of subscribers are extremely slow to</span></span><br><span class="line">    <span class="comment">// clean up in Chromium</span></span><br><span class="line">    <span class="comment">// to workaround this, we unset the sub for now, and clear them on</span></span><br><span class="line">    <span class="comment">// next scheduler flush.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>[<span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">indexOf</span>(sub)] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_pending</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_pending</span> = <span class="literal">true</span></span><br><span class="line">      pendingCleanupDeps.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//收集依赖，把当前的 Watcher 添加到该 Dep 实例的 subs 中。</span></span><br><span class="line">  <span class="comment">//如果有需要调试的信息（如 onTrack 回调函数），则调用该回调函数。</span></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params">info?: DebuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; info &amp;&amp; <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="property">onTrack</span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">          <span class="attr">effect</span>: <span class="title class_">Dep</span>.<span class="property">target</span>,</span><br><span class="line">          ...info</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通知更新，当一个 Dep 实例被更新时，它会遍历 subs 中的所有 Watcher，并依次调用它们的 update 方法进行更新。</span></span><br><span class="line">  <span class="comment">//在这个过程中，如果有需要调试的信息（如 onTrigger 回调函数），则调用该回调函数。</span></span><br><span class="line">  <span class="comment">//如果配置中不是异步模式，则需要对 subs 进行排序以确保它们按正确的顺序触发更新。</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">info?: DebuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">s</span> =&gt;</span> s) <span class="keyword">as</span> <span class="title class_">DepTarget</span>[]</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs[i]</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; info) &#123;</span><br><span class="line">        sub.<span class="property">onTrigger</span> &amp;&amp;</span><br><span class="line">          sub.<span class="title function_">onTrigger</span>(&#123;</span><br><span class="line">            <span class="attr">effect</span>: subs[i],</span><br><span class="line">            ...info</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      sub.<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">pendingCleanupDeps</span>: <span class="title class_">Dep</span>[] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">cleanupDeps</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pendingCleanupDeps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = pendingCleanupDeps[i]</span><br><span class="line">    dep.<span class="property">subs</span> = dep.<span class="property">subs</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">s</span> =&gt;</span> s)</span><br><span class="line">    dep.<span class="property">_pending</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  pendingCleanupDeps.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是配合 <code>removeSub</code>, 过滤调已经被 <code>removeSub</code> 置 <code>null</code> 的 <code>subs</code>, 查询了 <strong>vue2</strong> 源码，主要在 <code>watch</code> &amp; <code>apiWatch</code> 中调用， 这个过会儿再深究</p><p>还有就是 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">targetStack</span>: <span class="title class_">Array</span>&lt;<span class="title class_">DepTarget</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt; = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span>(<span class="params">target?: DepTarget | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span>(<span class="params"></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化 <code>Dep.target = null</code>, 然后给了一个进栈出栈代码，这个看起来简单，其实很重要。</p><p>首先这个是什么？</p><blockquote><p>这段代码实现了一个全局的Watcher调度器。Vue的数据响应式机制会创建一个Watcher对象，Watcher会在数据变化时进行更新。在Vue的内部实现中，Dep（Dependency）对象用来收集Watcher，当数据发生变化时，Dep会通知收集的所有Watcher进行更新。</p><p>当一个Watcher被创建时，它会被设置为全局唯一的Dep.target。当数据变化时，Dep会通过调用Watcher的update方法来通知它进行更新。pushTarget方法将当前Watcher入栈并将Dep.target设置为该Watcher，这样在收集依赖时Dep会将该Watcher加入到其subs数组中。而popTarget方法则将Watcher出栈并恢复Dep.target为上一个Watcher，这样当数据变化时就可以通知到上一个Watcher进行更新。</p></blockquote><p>也就是说，当源码需要更新的时候</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pushTarget</span>(watcher);</span><br><span class="line"><span class="comment">//操作已经劫持过的值，触发更新</span></span><br><span class="line"><span class="title function_">popTarget</span>(watcher);</span><br></pre></td></tr></table></figure><p>另外，<code>targetStack</code> 为什么是一个数组？ 因为 Vue 响应式是可以嵌套的，层层嵌套，所以需要用到这个进栈出栈操作。</p><p>但是有些代码中，<code>pushTarget()</code> , 并没有包含 <code>watch</code>，传入值为 <code>undefined</code>, 是用于区别和判断</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>真实传入 watch 的方式是，通过 <code>watch.get</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>所以两者还是需要连起来看。</p><h3 id="02-总结"><a href="#02-总结" class="headerlink" title="02. 总结"></a>02. 总结</h3><p><code>Dep</code> 究竟干了什么。</p><p>他是一个桥梁，对象和watch之间的桥梁，每一个对象都应该有一个 Dep, 用于管理关于这个对象的依赖。</p><p>声明一个 Dep 用于管理 数据和Watch之间的依赖。</p><p>并且，也统一通过 Dep.target 来管理整个 Vue watch 的调度。</p><ol><li>addSub 添加watch，用于通知</li><li>removeSub 标记为null，scheduler flush 中清理</li><li>depend 当前 Dep 添加到 Dep.target 当中</li><li>notify 通知所有的 sub</li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Vue2 </tag>
            
            <tag> Dep </tag>
            
            <tag> 响应式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x watcher</title>
      <link href="/2023/06/27/vue2_watch/"/>
      <url>/2023/06/27/vue2_watch/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue2-x-watcher"><a href="#vue2-x-watcher" class="headerlink" title="vue2.x watcher"></a>vue2.x watcher</h1><h3 id="01-源码"><a href="#01-源码" class="headerlink" title="01. 源码"></a>01. 源码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> <span class="keyword">implements</span> <span class="title class_">DepTarget</span> &#123;</span><br><span class="line">  vm?: <span class="title class_">Component</span> | <span class="literal">null</span> <span class="comment">//组 //件实例</span></span><br><span class="line">  <span class="attr">expression</span>: <span class="built_in">string</span> <span class="comment">//监视的表达式</span></span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span> <span class="comment">//回调函数</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">//watch 唯一id</span></span><br><span class="line">  <span class="attr">deep</span>: <span class="built_in">boolean</span> <span class="comment">//是否进行深度监视</span></span><br><span class="line">  <span class="attr">user</span>: <span class="built_in">boolean</span> <span class="comment">//是否是自定义watch</span></span><br><span class="line">  <span class="attr">lazy</span>: <span class="built_in">boolean</span> <span class="comment">//是否懒执行</span></span><br><span class="line">  <span class="attr">sync</span>: <span class="built_in">boolean</span> <span class="comment">//watch 执行是同步还是异步</span></span><br><span class="line">  <span class="attr">dirty</span>: <span class="built_in">boolean</span> <span class="comment">//在 lazy = true 的前提下，值是否要重新计算</span></span><br><span class="line">  <span class="attr">active</span>: <span class="built_in">boolean</span> <span class="comment">//是否处于激活状态</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt; <span class="comment">//依赖列表</span></span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt; <span class="comment">//临时依赖列表</span></span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span> <span class="comment">//依赖的ID集合</span></span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span> <span class="comment">//临时依赖列表ID</span></span><br><span class="line">  before?: <span class="title class_">Function</span> <span class="comment">//更新之前的 hook 函数</span></span><br><span class="line">  onStop?: <span class="title class_">Function</span> <span class="comment">//当前 watch 被停止调用以后的钩子函数</span></span><br><span class="line">  noRecurse?: <span class="built_in">boolean</span> <span class="comment">//是否避免递归监视</span></span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">Function</span> <span class="comment">//获取当前监视的表达式的值</span></span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span> <span class="comment">//当前值</span></span><br><span class="line">  <span class="attr">post</span>: <span class="built_in">boolean</span> <span class="comment">//是否是后置 watcher（即渲染 watcher）？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// dev only</span></span><br><span class="line">  onTrack?: (<span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>) | <span class="literal">undefined</span></span><br><span class="line">  onTrigger?: (<span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>) | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    expOrFn: <span class="built_in">string</span> | (() =&gt; <span class="built_in">any</span>),</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: WatcherOptions | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: <span class="built_in">boolean</span> <span class="comment">//可选参数，表示这个 watcher 是否是渲染函数 watcher</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 recordEffectScope 函数记录 effect scope，其中 activeEffectScope 表示当前的激活的 effect scope。  </span></span><br><span class="line">    <span class="title function_">recordEffectScope</span>(</span><br><span class="line">      <span class="variable language_">this</span>,</span><br><span class="line">      <span class="comment">// if the active effect scope is manually created (not a component scope),</span></span><br><span class="line">      <span class="comment">// prioritize it</span></span><br><span class="line">      activeEffectScope &amp;&amp; !activeEffectScope.<span class="property">_vm</span></span><br><span class="line">        ? activeEffectScope</span><br><span class="line">        : vm</span><br><span class="line">        ? vm.<span class="property">_scope</span></span><br><span class="line">        : <span class="literal">undefined</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 vm 不为 null，且 isRenderWatcher 为 true，则将 watcher 存储在 vm 的 _watcher 属性中。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable language_">this</span>.<span class="property">vm</span> = vm) &amp;&amp; isRenderWatcher) &#123;</span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onTrack</span> = options.<span class="property">onTrack</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onTrigger</span> = options.<span class="property">onTrigger</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">post</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = __DEV__ ? expOrFn.<span class="title function_">toString</span>() : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isFunction</span>(expOrFn)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">              <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="literal">undefined</span> : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>) <span class="comment">//进栈，表示正在计算watch的值</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm) <span class="comment">//获取值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: <span class="built_in">any</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123; <span class="comment">//如果要深入监视</span></span><br><span class="line">        <span class="comment">//traverse 函数是用来遍历一个对象或数组的所有子属性，以便在进行“深度观测”（deep watch）时能够将这些子属性全部注册为依赖关系。</span></span><br><span class="line">        <span class="comment">//traverse 函数接收一个 val 参数，代表需要遍历的对象或数组。函数中首先会对 val 进行一些判断，例如如果 val 不是数组或对象，或者是被冻结的对象，或者是一个 VNode，就直接返回，不需要继续遍历。</span></span><br><span class="line">        <span class="comment">//接下来会判断 val 是否是一个响应式对象，如果是，就会将它所关联的依赖的 id 加入到 seen 集合中。这里的 seen 集合是用来去重的，它的作用是保证在遍历一个对象时不会出现循环依赖的情况。 </span></span><br><span class="line">        <span class="comment">//最后，如果 val 是一个数组，就对数组中的每个元素递归调用 _traverse 函数进行遍历；如果是一个对象，就对对象中的每个属性递归调用 _traverse 函数进行遍历。如果 val 是一个 Ref 对象，则遍历它的 value 属性。</span></span><br><span class="line">        <span class="comment">//这个方法的主要作用是遍历一个对象或者数组的所有属性或元素，并且将遍历到的所有属性或元素都收集为响应式依赖，这样当其中任意一个属性或元素发生变化时，Vue 就能够知道这个变化，并且及时通知视图进行更新。</span></span><br><span class="line">        <span class="title function_">traverse</span>(value) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>() <span class="comment">//出栈</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>() <span class="comment">//清除所有Deps</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="comment">//如果临时的ID集合没有包含这个ID</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id) <span class="comment">//加入</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep) <span class="comment">//加入临时依赖的集合</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123; <span class="comment">//如果依赖ID集合里面,没有</span></span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>) <span class="comment">//在Dep中加入这个watch</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">cleanupDeps</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历deps，如果没有在 newDepIds ，删除当前这个 watch 实例。</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">        dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 newDepIds 和 newDeps 赋值给 depIds 和 deps ，临时列表清空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">tmp</span>: <span class="built_in">any</span> = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">    tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">//判断lazy 如果是，dirty = true，表示发生了变化，但是还没有重新计算。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="comment">//如果 sync = true，同步执行，调用run</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果是异步执行，加入队列。</span></span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是 active</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 get 获取 value</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">//当 新旧 value 不一致</span></span><br><span class="line">        <span class="comment">//当 新值 是object</span></span><br><span class="line">        <span class="comment">//或者深度遍历 deep = true</span></span><br><span class="line">        value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        <span class="title function_">isObject</span>(value) ||</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里就是回调，用户自定义因为需要方便调试，所以用这种方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">          <span class="title function_">invokeWithErrorHandling</span>(</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cb</span>,</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">            [value, oldValue],</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">            info</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   * 评估 watcher 的值。</span></span><br><span class="line"><span class="comment">   * 只有懒惰的 watcher 才会调用这个方法。</span></span><br><span class="line"><span class="comment">   * 这个需要结合刚才的 upadte 来看，如果 this.lazy = true. 那么 dirty = true， 然后执行这个方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   * 把 deps 全部遍历， depends 全部执行到当前 Dep.target 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies&#x27; subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">teardown</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_isBeingDestroyed，用于标识该实例是否正在被销毁。当这个标记为 true 时，Vue 会停止继续观察数据，并且在一些钩子函数中，可能需要判断这个标记来决定是否执行一些操作，比如避免在组件已经被销毁后还执行一些异步操作，从而避免可能的内存泄漏问题。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">vm</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_isBeingDestroyed</span>) &#123;</span><br><span class="line">      <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_scope</span>.<span class="property">effects</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否是激活状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">//清除所有引用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置不激活</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//触发钩子</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-总结"><a href="#02-总结" class="headerlink" title="02. 总结"></a>02. 总结</h3><p>watch 做了什么？</p><blockquote><p>用于监听一个数据对象的变化，并在变化时执行回调函数。</p><p>在初始化时，watcher 会收集依赖，也就是将当前的 watcher 对象赋值给当前访问的数据对象的 dep 实例，从而建立数据对象和 watcher 的关联关系。当数据对象的值发生变化时，dep 实例会通知所有的 watcher，watcher 会重新执行回调函数。</p><p>在执行回调函数之前，watcher 还会进行一些优化处理，比如判断当前回调函数是否是异步执行的，如果是则将其加入到异步队列中，从而避免连续多次的更新操作，提高性能。同时，watcher 还支持一些高级特性，比如 computed、watchEffect 等。</p></blockquote><p><code>get</code> 方法主作用获取表达式的值，其中包含 Dep.target 进栈和出栈的操作，并且遍历获取的值的所有属性，将其响应式。</p><ol><li>pushTarget</li><li>获取表达式 value</li><li>traverse(value) 追种所有属性，响应式alue</li><li>popTarget() &#x2F;&#x2F;出栈</li><li>this.cleanupDeps() &#x2F;&#x2F;清理</li></ol><p><code>addDep</code> 如果临时ID的集合没有包含这个Dep，那么在临时ID集合以及临时集合中加入，继续判断，如果依赖ID集合(不是临时)没有包含这个ID，那么这个Dep.addSub(this)</p><p><code>update</code> 更新，3种更新</p><ol><li>懒更新 &#x3D;&gt; ditry &#x3D; true</li><li>!!sync &#x3D;&gt; run()</li><li>!sync &#x3D;&gt; 进入队列</li></ol><p><code>evaluate</code> 获取 value 赋值，dirty &#x3D; false。</p><p><code>run</code> 如果是否是 <code>active</code>，获取值，并且调用 callbcak</p><p><code>depend</code> 把 deps 全部遍历， depends 全部执行到当前 Dep.target 中</p><p><code>teardown</code> 清除关于这个 dep 中所有的当前 watcher。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> vue2 </tag>
            
            <tag> wather </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue beforeUpdate</title>
      <link href="/2023/06/26/vue_beforeUpdate/"/>
      <url>/2023/06/26/vue_beforeUpdate/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="beforeUpdate-vs-onBeforeUpdate"><a href="#beforeUpdate-vs-onBeforeUpdate" class="headerlink" title="beforeUpdate vs onBeforeUpdate"></a>beforeUpdate vs onBeforeUpdate</h1><p>beforeCreate -&gt; setup()<br>created -&gt; setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>activated -&gt; onActivated<br>deactivated -&gt; onDeactivated<br>errorCaptured -&gt; onErrorCaptured</p><h3 id="vue3-x-onBeforeUpdate"><a href="#vue3-x-onBeforeUpdate" class="headerlink" title="vue3.x onBeforeUpdate"></a>vue3.x onBeforeUpdate</h3><p>有两个地方可以调用 <code>onBeforeUpdate</code></p><p>第一个是在组件渲染函数中 <code>setupRenderEffect</code>, 里面创建了 <code>componentUpdateFn</code> 函数，交给副作用函数监控。</p><p>中间第一行代码就是去判断</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123; <span class="comment">// 如果组件实例未挂载</span></span><br><span class="line"><span class="comment">//创建组件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//更新组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新组件中的就是会调用 <code>beforeUpdate</code>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bu) &#123; <span class="comment">// 如果 beforeUpdate 钩子存在</span></span><br><span class="line">  <span class="title function_">invokeArrayFns</span>(bu) <span class="comment">// 调用 invokeArrayFns 函数，依次执行 beforeUpdate 钩子函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>beforeMount</code> 一样，立即触发。</p><h3 id="Vue2-x-beforeUpdate"><a href="#Vue2-x-beforeUpdate" class="headerlink" title="Vue2.x beforeUpdate"></a>Vue2.x beforeUpdate</h3><p>逻辑类似，都是在 mountComponent 的时候监视组件，然后触发更新.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  watcherOptions,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">)</span><br><span class="line">hydrating = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>updateComponent</code> 就是更新函数，其中有一个 <code>watcherOptions</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">watcherOptions</span>: <span class="title class_">WatcherOptions</span> = &#123;</span><br><span class="line">  <span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">      <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遇到更新触发，然后触发钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>都是在 <code>mountComponent</code> 创建组件的时候处理更新逻辑。</p><p><strong>Vue2.x</strong> 通过 <code>watch options before</code> 触发</p><p><strong>Vue3.x</strong> 通过 <code>effect</code> 触发 <code>updateComponent</code> 触发。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> beforeUpdate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue mounted</title>
      <link href="/2023/06/26/vue_mounted/"/>
      <url>/2023/06/26/vue_mounted/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="Vue-mounted"><a href="#Vue-mounted" class="headerlink" title="Vue mounted"></a>Vue mounted</h1><h3 id="1-Vue2-mounted"><a href="#1-Vue2-mounted" class="headerlink" title="1. Vue2 mounted"></a>1. Vue2 mounted</h3><p>在 <code>beforeMount</code> 之后做了什么？</p><ol><li>创建了 <code>updateComponent</code> 函数，调用 <code>vm._update(vm._render, hydrating);</code></li><li>创建 <code>watcher</code>, 监视<code>vm</code>, 发生变化调用 <code>updateComponent</code>， 在执行之前调用 <code>beforeUpdate</code></li><li>调用 <code>preWatchers</code></li><li>如果创建成功，调用 <code>mounted</code></li></ol><p>在这里，我们必须知道 <strong>Vue2</strong> <code>watcher</code> 是什么?</p><blockquote><p>在 Vue 2.x 中，Watcher 的作用是建立数据的响应式依赖关系并在数据发生变化时更新相关的视图。</p></blockquote><p>也就是说，会根据 vm 属性变化，调用 updateComponent，在 <code>new watcher(...)</code> 的时候，会立刻调用一次。</p><p>按照代码逻辑来说</p><p>new Wather(…) 第一次调用渲染组件, 调用 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  watcherOptions,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">watcherOptions</span>: <span class="title class_">WatcherOptions</span> = &#123;</span><br><span class="line"><span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发完成 <code>updateComponent</code> 然后顺序调用 <code>mounted</code>. 当 <code>vm</code> 触发更新，<code>_isMouted = true</code>，可以触发 <code>beforeUpdate</code>.</p><p>但是实际上，并不是这样，上面是我理解的代码逻辑，但是如果是这样顺序就有问题，而且实际测试不是这样。</p><p>所以要知道 mounted 怎么触发，就需要搞清楚 <code>render</code> 和 <code>update</code> 的详细逻辑</p><p><code>render</code> 方法就是在 <code>renderMixin</code> 当中  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123; <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>就是调用通过你模板中解析出来的 <code>render</code> 函数, 解析模板为一个 <code>vnode</code>，设置了上下文环境，设置属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">$vnode</span> = _parentVnode!</span><br><span class="line">vnode.<span class="property">parent</span> = _parentVnode</span><br></pre></td></tr></table></figure><p>总之就是返回一个 <code>vnode</code>. 并且设置了 <code>vm</code> &amp; <code>vnode</code> 属性。</p><p>继续来看 _update, 他通过调用 createElm 来创建节点。重点在创建完成以后，他通过一个队列，来调用 <code>vnode.data.hook.insert</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invokeInsertHook</span>(<span class="params">vnode, queue, initial</span>) &#123;</span><br><span class="line">  <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">  <span class="comment">// element is really inserted</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(initial) &amp;&amp; <span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) &#123;</span><br><span class="line">    vnode.<span class="property">parent</span>.<span class="property">data</span>.<span class="property">pendingInsert</span> = queue</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      queue[i].<span class="property">data</span>.<span class="property">hook</span>.<span class="title function_">insert</span>(queue[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initial</code> 是用来判断是否是第一次创建。</p><p>queue 是 insertedVnodeQueue。 insertedVnodeQueue 是已经插入了 <code>Vnode</code> 队列, 可以理解为创建完成 <code>vnode</code>，会 <code>push</code> 到里面.</p><p>然后这个组件所有的组件创建完成以后，就会开始调用这个队列 <code>insertedVnodeQueue，然后调用</code> <code>vnode.data.hook.insert</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">vnode: MountedComponentVNode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">  <span class="keyword">if</span> (!componentInstance.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">    componentInstance.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">data</span>.<span class="property">keepAlive</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">      <span class="comment">// vue-router#1212</span></span><br><span class="line">      <span class="comment">// During updates, a kept-alive component&#x27;s child components may</span></span><br><span class="line">      <span class="comment">// change, so directly walking the tree here may call activated hooks</span></span><br><span class="line">      <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></span><br><span class="line">      <span class="comment">// be processed after the whole patch process ended.</span></span><br><span class="line">      <span class="title function_">queueActivatedComponent</span>(componentInstance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">activateChildComponent</span>(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当所有的子节点都调用 insert, 然后最后调用根节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vm</span><br></pre></td></tr></table></figure><p>创建，并且渲染完成所有 vnode 以后， 依照次序调用 mounted.</p><p>所以会造成一种结果</p><h3 id="2-vue3-x-mounted"><a href="#2-vue3-x-mounted" class="headerlink" title="2. vue3.x mounted"></a>2. vue3.x mounted</h3><p>我们从前面的文章可以知道，Vue3.x 如何注册和调用生命周期的, 地址在这里 <a href="/tblog/2023/06/20/vue_lifecycle/">Vue lifecycle 实现</a>.</p><p>这里我们需要知道他在哪里调用，并且在调用之前做了什么？</p><p>在 componentUpdateFn 中调用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; bm, m, parent &#125; = instance <span class="comment">//取出需要的生命周期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bm) &#123; <span class="comment">// 如果 beforeMount 钩子存在</span></span><br><span class="line">  <span class="title function_">invokeArrayFns</span>(bm) <span class="comment">// 调用 invokeArrayFns 函数，依次执行 beforeMount 钩子函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m) &#123; <span class="comment">// 如果 mounted 钩子存在</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(m, parentSuspense) <span class="comment">// 将 mounted 钩子函数添加到 post 钩子队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queuePostRenderEffect</code> 会调用 <code>queuePostFlushCb</code>，然后向 <code>pendingPostFlushCbs.push(m)</code>.</p><p>然后会在 <code>render</code> 完成以后调用 <code>pendingPostFlushCbs</code>，循环触发事件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">render</span>: <span class="title class_">RootRenderFunction</span> = <span class="function">(<span class="params">vnode, container, isSVG</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, isSVG) <span class="comment">//创建</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flushPreFlushCbs</span>() <span class="comment">//预事件</span></span><br><span class="line"><span class="title function_">flushPostFlushCbs</span>() <span class="comment">//调用事件</span></span><br><span class="line">container.<span class="property">_vnode</span> = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>patch 就是创建或者更新 vnode 的方法。</p><p>根据上面的代码会得到的结果就是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent vnode beforeMount trigger</span><br><span class="line">child vnode beforeMount trigger</span><br><span class="line">child vnode mounted trigger</span><br><span class="line">parent vnode mounted trigger</span><br></pre></td></tr></table></figure><p>和 Vue2.x 一样，这就是 <code>onMounted</code> 的调用, 那么继续看 <code>beforeMount</code> 到 <code>Mounted</code> 之间做了什么.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bm) &#123;</span><br><span class="line">  <span class="title function_">invokeArrayFns</span>(bm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>beforeMount</code> 开始, 直接 <code>invokeArrayFns</code> 是直接调用，不存在延迟.</p><p>如果不是 ssr 的话，直接调用 patch 创建组件, 将子树的 el 属性赋值给初始 VNode 的 el 属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">patch</span>(</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">subTree,</span><br><span class="line">container,</span><br><span class="line">anchor,</span><br><span class="line">instance,</span><br><span class="line">parentSuspense,</span><br><span class="line">isSVG</span><br><span class="line">)</span><br><span class="line">initialVNode.<span class="property">el</span> = subTree.<span class="property">el</span></span><br></pre></td></tr></table></figure><p>如果钩子存在加入队列</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m) &#123; </span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(m, parentSuspense) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接调用 <code>vnode</code> 内部的 <code>mounted hook</code> 和 <strong>Vue2.x</strong> 写法的兼容性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isAsyncWrapperVNode &amp;&amp; (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeMounted</span>)) &#123; <span class="comment">// 如果不是异步组件的包装 VNode，并且存在 onVnodeMounted 钩子</span></span><br><span class="line">  <span class="keyword">const</span> scopedInitialVNode = initialVNode</span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">invokeVNodeHook</span>(vnodeHook!, parent, scopedInitialVNode),</span><br><span class="line">    parentSuspense</span><br><span class="line">  ) <span class="comment">// 将 onVnodeMounted 钩子函数添加到 post 钩子队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  __COMPAT__ &amp;&amp;</span><br><span class="line">  <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&#x27;hook:mounted&#x27;</span>),</span><br><span class="line">    parentSuspense</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来又处理了 active 事件（这个后面再讲），并且设置 <code>instance.isMounted = true</code>.</p><p>再这个过程中你会发觉，其实就是执行了 <code>patch</code> 创建或者更新了真实 dom，然后触发.</p><p>所以过程，流程就是当刚开始 mount &#x3D;&gt; render &#x3D;&gt; patch &#x3D;&gt; 然后根据 vnode 不停的判断循环，递归，不停的创建真实dom。</p><p>等真实创建完成执行后面的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">render</span>: <span class="title class_">RootRenderFunction</span> = <span class="function">(<span class="params">vnode, container, isSVG</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, isSVG)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>() <span class="comment">//</span></span><br><span class="line">  <span class="title function_">flushPostFlushCbs</span>() <span class="comment">//执行刚才插入的钩子</span></span><br><span class="line">  container.<span class="property">_vnode</span> = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>其实创建阶段的生命周期就走到这里了。</p><p>setup &#x3D;&gt; onBeforeMount &#x3D;&gt; onMounted</p><p>beforeCreate &#x3D;&gt; created &#x3D;&gt; beforeMount &#x3D;&gt; mounted</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> mounted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue beforeMount vs onBeforeMount</title>
      <link href="/2023/06/24/vue_beforeMount_onBeforeMount/"/>
      <url>/2023/06/24/vue_beforeMount_onBeforeMount/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="Vue-beforeMount-vs-onBeforeMount"><a href="#Vue-beforeMount-vs-onBeforeMount" class="headerlink" title="Vue beforeMount vs onBeforeMount"></a>Vue beforeMount vs onBeforeMount</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate -&gt; <span class="title function_">setup</span>()</span><br><span class="line">created -&gt; <span class="title function_">setup</span>()</span><br><span class="line">beforeMount -&gt; onBeforeMount</span><br><span class="line">mounted -&gt; onMounted</span><br><span class="line">beforeUpdate -&gt; onBeforeUpdate</span><br><span class="line">updated -&gt; onUpdated</span><br><span class="line">beforeDestroy -&gt; onBeforeUnmount</span><br><span class="line">destroyed -&gt; onUnmounted</span><br><span class="line">activated -&gt; onActivated</span><br><span class="line">deactivated -&gt; onDeactivated</span><br><span class="line">errorCaptured -&gt; onErrorCaptured</span><br></pre></td></tr></table></figure><h3 id="1-beforeMount"><a href="#1-beforeMount" class="headerlink" title="1. beforeMount"></a>1. beforeMount</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">    vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: <span class="built_in">string</span> | Element,</span></span><br><span class="line"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: Element | <span class="literal">null</span> | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">// @ts-expect-error invalid type</span></span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  <span class="comment">//todo...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是家查了 <code>el</code> 是否在， 检查了 <code>vm</code> 中 $<code>options</code> 中是否有 <code>render</code>, 如果没有绑定一个空节点到 <code>options</code> 当中.</p><p>首先你需要知道 render 是做什么的？</p><blockquote><p>在Vue.js中，你可以使用两种方式来定义组件的视图：</p><p>模板方式：使用Vue的模板语法，将HTML代码与Vue实例的数据进行绑定。你可以在模板中使用指令、表达式和其他特性来实现数据的渲染和交互。</p><p>render函数方式：使用JavaScript编写render函数，该函数返回一个虚拟节点（VNode），描述了组件的DOM结构。render函数提供了更灵活和动态的方式来生成组件的视图，你可以在函数中使用JavaScript的语法和逻辑来处理数据渲染。</p></blockquote><p>也就是有个方法自己来写模版类似于这种</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">      <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;Count: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">count</span>),</span><br><span class="line">      <span class="title function_">h</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&#x27;Increment&#x27;</span>)</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就是说自己去写虚拟dom节点，只是我没有在实际应用中有用到这个。</p><p>可能是比较复杂的情况，比如性能优化，特别复杂的情况，或者自定义组件吧。</p><h3 id="2-onBeforeMount"><a href="#2-onBeforeMount" class="headerlink" title="2. onBeforeMount"></a>2. onBeforeMount</h3><p>之前大概看了 <strong>Vue3</strong> 的生命周期, 地址在这里 <a href="/tblog/2023/06/20/vue_lifecycle/">Vue lifecycle 实现</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">setupRenderEffect</span>: <span class="title class_">SetupRenderEffectFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">componentUpdateFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">const</span> &#123; el, props &#125; = initialVNode</span><br><span class="line">      <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance</span><br><span class="line">      <span class="keyword">const</span> isAsyncWrapperVNode = <span class="title function_">isAsyncWrapper</span>(initialVNode)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">toggleRecurse</span>(instance, <span class="literal">false</span>)</span><br><span class="line">      <span class="comment">// beforeMount hook</span></span><br><span class="line">      <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">        <span class="title function_">invokeArrayFns</span>(bm)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><code>invokeArrayFns</code> 就是遍历然后传入参数, 这里的 <code>bm</code> 其实就是 <code>beforeMount</code> 的枚举值。</p><p>在执行完成 <code>setup</code> 函数以后，并且处理完成 <code>SUSPENSE</code> 之后，调用 <code>setupRenderEffect，就开始执行</code> <code>beforeMount</code></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>Vue 2.x 在 合并 <code>options</code>， 解析完 <code>render, evnet, data, methods</code> 之类的，并且判断完成 <code>el</code> (就是)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate =&gt; Created =&gt; beforeMount</span><br></pre></td></tr></table></figure><p>Vue3.x 在也是先合并 <code>options</code>, 执行完成 <code>setup</code> 函数，处理完成 <code>SUSPENSE，</code> 之后调用 <code>beforeMount</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup =&gt; beforeMount</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 effect</title>
      <link href="/2023/06/21/vue3_effect/"/>
      <url>/2023/06/21/vue3_effect/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="vue3-effect"><a href="#vue3-effect" class="headerlink" title="vue3 effect"></a>vue3 effect</h1><h3 id="01-track"><a href="#01-track" class="headerlink" title="01. track"></a>01. track</h3><p>以响应式代码为例子</p><p><strong>packages&#x2F;reactivity&#x2F;src&#x2F;baseHandlers.ts</strong> 中 <code>createGetter</code> 该方法为 <code>Proxy</code> 提供 <code>Getter</code> 的工厂方法</p><p>在判断，特殊返回完成之后，会进行 <code>track</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>packages&#x2F;reactivity&#x2F;src&#x2F;effect.ts 214</strong></p><p>首先会判断 <code>houldTrack &amp;&amp; activeEffect</code>, 这里默认它为true，因为要解释是否为true，需要知道创建和绑定的流程，以及它的规则。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>接下来是</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 target 查找 targetMap 获取 depsMap</span></span><br><span class="line"><span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line"><span class="comment">//如果没有，新建Map，并且赋值 depsMap</span></span><br><span class="line"><span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//depsMap 通过 Key 获取。</span></span><br><span class="line"><span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">//如果没有，创建一个新的 Dep， Dep 是 Set &amp; TrackedMarkers</span></span><br><span class="line"><span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟踪 Effects</span></span><br><span class="line"><span class="comment">//判断是否需要 track</span></span><br><span class="line"><span class="comment">//相互引用</span></span><br><span class="line"><span class="title function_">trackEffects</span>(dep, eventInfo)</span><br></pre></td></tr></table></figure><p><code>targetMap</code> </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;<span class="built_in">any</span>, <span class="title class_">Dep</span>&gt;</span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;()</span><br></pre></td></tr></table></figure><p>定义 <code>target =&gt; key =&gt; Dep</code> 的一个映射表，通过他来存储之间的关系。<br>其中 <code>KeyToDepMap</code> 就是 <code>depsMap</code>, 最终存储 <code>Dep</code></p><p>Dep 是一个 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt; &amp; <span class="title class_">TrackedMarkers</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TrackedMarkers</span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * wasTracked</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">w</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * newTracked</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">n</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>trackEffects</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dep: Dep,</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">false</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//先不用纠结他怎么算的</span></span><br><span class="line"><span class="comment">//判断是否超过最大数值</span></span><br><span class="line"><span class="comment">//如果没有超过，就是部分清理</span></span><br><span class="line"><span class="comment">//判断是否被其他 ReactiveEffect 访问</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">dep.<span class="title function_">add</span>(activeEffect!) <span class="comment">//dep增加 Effect</span></span><br><span class="line">activeEffect!.<span class="property">deps</span>.<span class="title function_">push</span>(dep) <span class="comment">//activeEffect.deps增加dep</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分就是增加 track 的代码，总之就是在 <code>dep</code> 和 <code>effect</code> 相互关联, dep 在 targetMap 中。</p><h3 id="02-triggger"><a href="#02-triggger" class="headerlink" title="02. triggger"></a>02. triggger</h3><p><code>triggger function</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果没有从 targetMap.get 获取到，没有 track</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Dep[]</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">deps</span>: (<span class="title class_">Dep</span> | <span class="literal">undefined</span>)[] = []</span><br><span class="line">  <span class="comment">//如果 type 是 CLEAR，表示清空集合，将 depsMap 中所有的依赖项都加入到 deps 中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    deps = [...depsMap.<span class="title function_">values</span>()]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果 key 是 length，并且 target 是数组，则表示数组长度发生变化，需要触发数组的依赖项更新。</span></span><br><span class="line">  <span class="comment">//找到 depsMap 中 key 等于 length 或者大于等于新长度的依赖项，并将其加入到 deps 中。</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">const</span> newLength = <span class="title class_">Number</span>(newValue)</span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= newLength) &#123;</span><br><span class="line">        deps.<span class="title function_">push</span>(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="comment">//key !== undefined</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="comment">// 对于 SET、ADD、DELETE 三种情况，根据 key 从 depsMap 中获取依赖项 dep，并将其加入到 deps 中</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          <span class="comment">//对于 ADD 操作，如果 target 不是数组，则需要触发 ITERATE_KEY 和 MAP_KEY_ITERATE_KEY 两个迭代依赖项更新</span></span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 target 是数组，且 key 是整数，则需要触发数组长度的依赖项更新。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          <span class="comment">//如果 target 不是数组，则需要触发 ITERATE_KEY</span></span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">          <span class="comment">//如果是Map，MAP_KEY_ITERATE_KEY</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eventInfo = __DEV__</span><br><span class="line">    ? &#123; target, <span class="keyword">type</span>, key, newValue, oldValue, oldTarget &#125;</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果只有一个 dep，直接更新</span></span><br><span class="line">  <span class="comment">//如果多个 则需要将所有依赖项的 ReactiveEffect 对象合并成一个新的 ReactiveEffect 对象，再更新</span></span><br><span class="line">  <span class="keyword">if</span> (deps.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deps[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>], eventInfo)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">effects</span>: <span class="title class_">ReactiveEffect</span>[] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">        effects.<span class="title function_">push</span>(...dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="title function_">createDep</span>(effects), eventInfo)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="title function_">createDep</span>(effects))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来代码很多，其实做了几件事。</p><ol><li>处理 type.clear</li><li>处理 arr &amp; key &#x3D; length or number 的问题</li><li>deps &#x3D; Dep[], 如果 Key !&#x3D; undefined 把对应 key，以及根据type 获取对应Dep</li><li>triggerEffects 处理</li></ol><p><strong>triggerEffects</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dep: Dep | ReactiveEffect[],</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// spread into array for stabilization</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历 <code>dep</code>, <code>triggerEffect(effect)</code>, 先处理 <code>computed</code>, 然后非 <code>computed</code></p><p><strong>triggerEffect</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: ReactiveEffect,</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.<span class="property">onTrigger</span>) &#123;</span><br><span class="line">      effect.<span class="title function_">onTrigger</span>(<span class="title function_">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effect.<span class="title function_">scheduler</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect.<span class="title function_">run</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发 <code>ReactiveEffect</code> 有 <code>scheduler</code> 优先 <code>scheduler</code>，没有 <code>run</code></p><h3 id="track-amp-trigger-总结"><a href="#track-amp-trigger-总结" class="headerlink" title="track &amp; trigger 总结"></a>track &amp; trigger 总结</h3><ol><li>track，创建Dep，并且放入 targetMap &amp; desMap, Dep 添加 activeEffect， activeEffect.deps.push(dep)</li><li>trigger, 获取 target 的 depsMap, 排除 type.clear &amp; key &#x3D; length &amp; number, 如果有key 从 depsMap 获取, 然后再把对应type的一些固定key，也获取出来，然后 effect.scheduler or run, computed 优先。</li></ol><h3 id="03-reactiveEffect-源码"><a href="#03-reactiveEffect-源码" class="headerlink" title="03. reactiveEffect 源码"></a>03. reactiveEffect 源码</h3><p>之前说了这么多，其实 track 和 trigger 都是为了触发 reactiveEffect 更新，那么继续看一下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactiveEffect 类定义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 是否处于活动状态，初始为 true</span></span><br><span class="line">  active = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 当前 ReactiveEffect 实例的依赖项数组</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Dep</span>[] = []</span><br><span class="line">  <span class="comment">// 当前 ReactiveEffect 实例的父级 ReactiveEffect 实例，用于解决递归调用的问题</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以在创建之后附加</span></span><br><span class="line">  computed?: <span class="title class_">ComputedRefImpl</span>&lt;T&gt;</span><br><span class="line">  <span class="comment">// 允许递归调用</span></span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 延迟停止，用于避免因删除当前 ReactiveEffect 实例时引起的并发问题</span></span><br><span class="line">  <span class="keyword">private</span> deferStop?: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 ReactiveEffect 实例停止时调用的函数</span></span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="comment">// 仅在开发环境中使用，用于跟踪依赖项追踪事件</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="comment">// 仅在开发环境中使用，用于跟踪触发事件</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ReactiveEffect 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> fn: () =&gt; T, <span class="comment">// 当前 ReactiveEffect 实例的执行函数</span></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> scheduler: EffectScheduler | <span class="literal">null</span> = <span class="literal">null</span>, <span class="comment">// 用于指定更新策略</span></span></span><br><span class="line"><span class="params">    scope?: EffectScope <span class="comment">// 用于指定作用域</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="title function_">recordEffectScope</span>(<span class="variable language_">this</span>, scope) <span class="comment">// 记录当前 ReactiveEffect 实例的作用域</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行 ReactiveEffect 实例</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经追踪了当前 ReactiveEffect 实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span> = activeEffect</span><br><span class="line">    <span class="keyword">let</span> lastShouldTrack = shouldTrack</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent === <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.<span class="property">parent</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 设置父级 ReactiveEffect 实例，并将当前实例设置为 activeEffect</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = activeEffect</span><br><span class="line">      activeEffect = <span class="variable language_">this</span></span><br><span class="line">      shouldTrack = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化 depMarkers，用于性能优化</span></span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; ++effectTrackDepth</span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="title function_">initDepMarkers</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行 ReactiveEffect 实例的函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 结束追踪 depMarkers</span></span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="title function_">finalizeDepMarkers</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; --effectTrackDepth</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 恢复上一个活动的 ReactiveEffect 实例</span></span><br><span class="line">      activeEffect = <span class="variable language_">this</span>.<span class="property">parent</span></span><br><span class="line">      shouldTrack = lastShouldTrack</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 deferStop 属性为 true，则删除当前 ReactiveEffect 实例</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deferStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">stop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前副作用函数正在执行，标记为延迟清理</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect === <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deferStop</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123; <span class="comment">// 如果当前副作用函数未执行且仍然活跃</span></span><br><span class="line">        <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>) <span class="comment">// 清除副作用函数与其依赖项之间的关联关系</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123; <span class="comment">// 如果有停止回调函数，调用停止回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span> <span class="comment">// 标记当前副作用函数为不活跃状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了3个方法，构造，<code>run</code>，<code>stop</code></p><ol><li>构造函数， 就是如果 <code>!!scope</code>, <code>scope.effects.push(this)</code>, 还有一个 <code>EffectScope</code>，就是这个 <code>scope</code>，用于管理 <code>reactiveEffect</code>, 这里把他放进管理里面去</li><li>run 可以简单的理解为执行构造函数传入的 <code>Fn</code> 函数<br>  2.1 复杂一点说，当 <code>!active</code>, 直接调用 <code>fn</code><br>  2.2 检查 parent 是否存在循环引用<br>  2.3 设置参数，<code>parent = activeEffect, activeEffect = this, shouldTrack = true</code><br>  2.4 <code>fn()</code><br>  2.5 恢复参数 <code>activeEffect = this.parent，shouldTrack = lastShouldTrack，this.parent = undefined</code></li></ol><p>这里有一个概念</p><blockquote><p>depMarkers 是一个用于追踪依赖关系的标记对象，用于在 reactive effect 中记录哪些依赖项已被追踪过。它有两个属性 w 和 n，分别代表了 “wasTracked” 和 “newTracked”。</p><p>在 reactive effect 中，depMarkers 被用来判断某个依赖项是否已被追踪，以及在追踪完所有依赖项后是否有新的依赖项被追踪。如果一个依赖项在 reactive effect 中被追踪过，它的 w 位会被设置为 1，如果在当前追踪过程中有新的依赖项被追踪，它的 n 位会被设置为 1。</p><p>通过 depMarkers 中的这些标记，Vue3 可以在 reactive effect 中跟踪依赖项的变化，并且只会在必要的时候重新运行 reactive effect。这样可以提高性能和响应速度。</p></blockquote><p>这里先不展开了</p><ol start="3"><li><code>stop</code> 就是清理 <code>effect</code> 和 <code>dep</code> 的关联，全部<code>delete</code>，<code>active</code> 设置为 <code>false</code></li></ol><h3 id="04-怎么调用-reactiveEffect"><a href="#04-怎么调用-reactiveEffect" class="headerlink" title="04. 怎么调用 reactiveEffect"></a>04. 怎么调用 reactiveEffect</h3><p>这里我产生了一个疑惑，在这个触发的过程中，activeEffect, 是什么时候实例化的？我查看了所有关于 <code>activeEffect</code> 的引用。</p><p>只有在 <code>reactiveEffect.run</code> 中才有设置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">parent</span> = activeEffect</span><br><span class="line">activeEffect = <span class="variable language_">this</span></span><br><span class="line">shouldTrack = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">activeEffect = <span class="variable language_">this</span>.<span class="property">parent</span></span><br><span class="line">shouldTrack = lastShouldTrack</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>也就是说当一个, 我们可以理解 <code>reactiveEffect</code> 是一个树，保证运行时候类似于先进后出。</p><p>这里解释了为什么 <code>activeEffect</code> 会保证有值的原因。</p><p>另外我们总是需要先调用 <code>reactiveEffect</code>, 才会有第一次的值, 这里是在初始化组件或者更新组件的时候</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create reactive effect for rendering</span></span><br><span class="line"><span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">  instance.<span class="property">scope</span> <span class="comment">// track it in component&#x27;s effect scope</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">SchedulerJob</span> = (instance.<span class="property">update</span> = <span class="function">() =&gt;</span> effect.<span class="title function_">run</span>())</span><br><span class="line">update.<span class="property">id</span> = instance.<span class="property">uid</span></span><br><span class="line"><span class="comment">// allowRecurse</span></span><br><span class="line"><span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line"><span class="title function_">toggleRecurse</span>(instance, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  effect.<span class="property">onTrack</span> = instance.<span class="property">rtc</span></span><br><span class="line">    ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtc</span>!, e)</span><br><span class="line">    : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">  effect.<span class="property">onTrigger</span> = instance.<span class="property">rtg</span></span><br><span class="line">    ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtg</span>!, e)</span><br><span class="line">    : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">  update.<span class="property">ownerInstance</span> = instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">update</span>()</span><br></pre></td></tr></table></figure><h3 id="05-总结。"><a href="#05-总结。" class="headerlink" title="05. 总结。"></a>05. 总结。</h3><p>reactiveEffect 是响应式的核心代码，所有的值都通过他来执行响应式，通过 <code>run</code> or <code>stop</code> 来控制执行或者停止。</p><p>通过 targetMap 来存储 reactiveEffect.</p><p>targetMap &#x3D;&gt; depsMap &#x3D;&gt; Dep &#x3D;&gt; reactiveEffect.</p><p>通过 track 方法来创建 Dep，并且和当前的 reactivEffect 产生关联， </p><p><code>activeEffect.deps.push(dep)</code> </p><p><code>dep.add(activeEffect)</code></p><p>通过 trigger 方法，来找到对应的 reactiveEffect, 不仅仅包含当前 key 的，还包含对用操作类型的 reactiveEffect </p><p>然后统一去触发。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> effect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章目录</title>
      <link href="/2023/06/20/category/"/>
      <url>/2023/06/20/category/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h1><h3 id="自己写的"><a href="#自己写的" class="headerlink" title="自己写的"></a>自己写的</h3><ul><li><a href="https://www.npmjs.com/package/t_valid_type">npmjs库 t_valid_type</a></li><li><a href="https://github.com/tanlanchou/indexdb_book_store">indexDB本地图书馆</a></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><a href="/tblog/2024/02/23/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/">前端埋点</a></li><li><a href="/tblog/2024/02/23/rss%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94/">rss 数据对比</a></li><li><a href="/tblog/2024/02/23/nestjs-modules-mailer/">nestjs mailer</a></li><li><a href="/tblog/2023/12/07/zaxiang/front_docker_env/">前端 docker 项目如何动态加载环境变量</a></li><li><a href="/tblog/2023/08/27/sudo_npm_install/">为什么 npm install 需要 sudo</a></li><li><a href="/tblog/2023/08/29/wsl_can_not_boot/">windows docker 安装遇到的坑</a></li></ul><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><ul><li><a href="/tblog/2023/08/27/vue3_plugin/">vue3 createVNode &amp; render</a></li><li><a href="/tblog/2023/07/31/vue3_setup/">setup源码</a></li><li><a href="/tblog/2023/07/08/nextTick/">nextTick源码</a></li><li><a href="/tblog/2023/07/08/Vue3_queue/">任务调度源码解析</a></li><li><a href="/tblog/2023/07/06/Vue3_Suspense/">defineAsyncComponent &amp; Suspense 使用和源码分析</a></li><li><a href="/tblog/2023/06/21/vue3_effect/">effect源码</a></li><li><a href="/tblog/2023/06/29/vue3_ref/">ref源码</a></li><li><a href="/tblog/2023/06/29/vue3_reactive/">reactive源码</a></li><li><a href="/tblog/2023/06/29/vue3_keep_alive/">keep-alive源码</a></li></ul><h3 id="Vue对比"><a href="#Vue对比" class="headerlink" title="Vue对比"></a>Vue对比</h3><ol><li><a href="/tblog/2023/06/20/vue_lifecycle/">Vue lifecycle 实现</a></li><li><a href="/tblog/2023/06/20/vue_setup_created_before_created/">beforeCreate, created vs setup</a></li><li><a href="/tblog/2023/06/24/vue_beforeMount_onBeforeMount/">beforeMount vs onBeforeMount</a></li><li><a href="/tblog/2023/06/26/vue_mounted/">mounted vs onMounted</a></li><li><a href="/tblog/2023/06/26/vue_beforeUpdate/">beforeUpdate vs onBeforeUpdate</a></li><li><a href="/tblog/2023/06/28/vue_updated_onUpdated/">updated vs onUpdated</a></li><li><a href="/tblog/2023/06/28/vue_beforeDestroy_onBeforeUnmount/">beforeDestroy vs onBeforeUnmount</a></li><li><a href="/tblog/2023/06/29/vue_destroyed_onUnmounted/">destroyed vs onUnmounted</a></li><li><a href="/tblog/2023/07/02/vue_active/">actived vs onActivated</a></li><li><a href="/tblog/2023/07/02/vue_deactivated/">deactivated vs onDeactivated</a></li></ol><h3 id="javascript最基础"><a href="#javascript最基础" class="headerlink" title="javascript最基础"></a>javascript最基础</h3><ul><li><a href="/tblog/2023/12/01/javascript/url_open_software/">href打开本地软件</a></li><li><a href="/tblog/2023/11/02/%5BQ103%5DIndexDB_Base/">Q102 indexDB API</a></li><li><a href="/tblog/2023/09/02/%5BQ102%5Djavascript_this_link/">Q101 this 函数指向问题</a></li><li><a href="/tblog/2023/08/20/%5BQ001%5DArrowFunctionvsFunction/">箭头函数有prototype吗？为什么？</a></li><li><a href="/tblog/2023/07/09/browser_event/">浏览器事件流</a></li><li><a href="/tblog/2023/07/08/clipboard/">浏览器复制</a></li><li><a href="/tblog/2023/07/07/web_fetch/">fetch 简单介绍</a></li><li><a href="/tblog/2023/06/15/async&defer/">async &amp; defer</a></li><li><a href="/tblog/2023/07/03/node_deep_equal/">看 node-deep-equal</a></li><li><a href="/tblog/2023/07/03/async_code/">javascript 异步编程有哪些方式？</a></li><li><a href="/tblog/2023/07/03/baseEs6/">es6 更新总结</a></li><li><a href="/tblog/2023/07/03/closures_and_scopes/">作用域和闭包</a></li><li><a href="/tblog/2023/07/03/deepClone/">深拷贝方法优缺点总结和自己写的思路</a></li><li><a href="/tblog/2023/07/03/eventLoop/">浏览器事件循环总结</a></li><li><a href="/tblog/2023/07/03/js_new/">javascript new 做了什么？</a></li><li><a href="/tblog/2023/07/03/js_type_check/">javascript 类型判断方法总结</a></li><li><a href="/tblog/2023/07/03/undefined_void_0/">为什么要用 void 0 代替 undefined</a></li><li><a href="/tblog/2023/07/12/es6_array/">Array</a></li></ul><h3 id="web基础和基础css"><a href="#web基础和基础css" class="headerlink" title="web基础和基础css"></a>web基础和基础css</h3><ul><li><a href="/tblog/2023/12/14/browser/cache/">浏览器缓存大赏</a></li><li><a href="/tblog/2023/09/01/%5BQ101%5DFlex_attr/">flex 属性详解</a></li><li><a href="/tblog/2023/07/06/web_img_lazy_loading/">图片懒加载4种方案</a></li><li><a href="/tblog/2023/06/15/browser_parsing/">浏览器解析过程</a></li><li><a href="/tblog/2023/06/15/graphql/">graphgl</a></li><li><a href="/tblog/2023/06/15/debounce_throttle/">防抖和节流</a></li><li><a href="/tblog/2023/07/03/BFC/">BFC 布局模型</a></li><li><a href="/tblog/2023/07/03/Implementation_Methods_for_Horizontal_and_Vertical_Centering/">css 垂直居中方案</a></li><li><a href="/tblog/2023/07/03/IFC/">IFC 布局模型</a></li><li><a href="/tblog/2023/07/03/repaint_reflow/">重绘和回流的基本概念</a></li></ul><h3 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h3><ul><li><a href="/tblog/2023/12/07/electron/electron_caiken_01/">electron url启动和打包</a></li></ul><h3 id="vue2-x源码"><a href="#vue2-x源码" class="headerlink" title="vue2.x源码"></a>vue2.x源码</h3><ul><li><a href="/tblog/2023/08/19/Vue_extends/">extend</a></li><li><a href="/tblog/2023/06/27/vue2_watch/">watcher</a></li><li><a href="/tblog/2023/06/27/vue2_Dep/">dep</a></li><li><a href="/tblog/2023/08/19/Vue_extends/">vue2 extend</a></li></ul><h3 id="做点题"><a href="#做点题" class="headerlink" title="做点题"></a>做点题</h3><ul><li><a href="/tblog/2023/12/07/shuati/001_bind/">001</a></li><li><a href="/tblog/2023/07/08/%5BQ017%5DHow_does_css_achieve_a_fixed_300px_on_the_left_and_an_daptive_layout_on_the_right/">css 如何实现左侧固定 300px，右侧自适应的布局</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue lifecycle 实现</title>
      <link href="/2023/06/20/vue_lifecycle/"/>
      <url>/2023/06/20/vue_lifecycle/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="Vue-lifecycle-实现"><a href="#Vue-lifecycle-实现" class="headerlink" title="Vue lifecycle 实现"></a>Vue lifecycle 实现</h1><h3 id="1-Vue2-x"><a href="#1-Vue2-x" class="headerlink" title="1. Vue2.x"></a>1. Vue2.x</h3><p>在看 Vue2.x 源码的时候，总会看到下面类似代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">false</span> <span class="comment">/* setContext */</span>)</span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>看一下 callHook 源码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">callHook</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  hook: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  args?: <span class="built_in">any</span>[],</span></span><br><span class="line"><span class="params">  setContext = <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  <span class="comment">// 推入调用栈</span></span><br><span class="line">  <span class="title function_">pushTarget</span>()</span><br><span class="line">  <span class="keyword">const</span> prev = currentInstance</span><br><span class="line">  setContext &amp;&amp; <span class="title function_">setCurrentInstance</span>(vm)</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.<span class="property">$options</span>[hook]</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span></span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="title function_">invokeWithErrorHandling</span>(handlers[i], vm, args || <span class="literal">null</span>, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_hasHookEvent</span>) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里是设置当前上下文</span></span><br><span class="line">  setContext &amp;&amp; <span class="title function_">setCurrentInstance</span>(prev)</span><br><span class="line">  <span class="comment">//设置调用栈</span></span><br><span class="line">  <span class="title function_">popTarget</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入 <code>hook</code> 名称，从当前 <code>vm</code> 获取到 <code>handlers</code>，然后遍历调用 <code>invokeWithErrorHandling</code>， 执行 <code>hook</code> 并且捕获错误</p><p>如果 ok，触发 <code>vm.$emit(&#39;hook:&#39; + hook)</code>，那么剩下的问题就是在哪里解析的？</p><p>其实就是在合并 <code>options</code> 的时候 把 <code>vm.constructor.options</code> 合并到 <code>vm.$options</code> 当中，就可以调用了</p><h3 id="2-Vue3-x"><a href="#2-Vue3-x" class="headerlink" title="2. Vue3.x"></a>2. Vue3.x</h3><p><strong>packages\runtime-core\src\apiLifecycle.ts</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onBeforeMount = <span class="title function_">createHook</span>(<span class="title class_">LifecycleHooks</span>.<span class="property">BEFORE_MOUNT</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createHook = &lt;T <span class="keyword">extends</span> <span class="title class_">Function</span> = <span class="function">() =&gt;</span> <span class="built_in">any</span>&gt;<span class="function">(<span class="params">lifecycle: LifecycleHooks</span>) =&gt;</span></span><br><span class="line">  <span class="function">(<span class="params">hook: T, target: ComponentInternalInstance | <span class="literal">null</span> = currentInstance</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span></span><br><span class="line">    (!isInSSRComponentSetup || lifecycle === <span class="title class_">LifecycleHooks</span>.<span class="property">SERVER_PREFETCH</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">injectHook</span>(lifecycle, <span class="function">(<span class="params">...args: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="title function_">hook</span>(...args), target)</span><br></pre></td></tr></table></figure><p>分一下断就是 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="attr">lifecycle</span>: <span class="title class_">LifecycleHooks</span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function">(<span class="params">hook: T, target: ComponentInternalInstance | <span class="literal">null</span> = currentInstance</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isInSSRComponentSetup || lifecycle === <span class="title class_">LifecycleHooks</span>.<span class="property">SERVER_PREFETCH</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">injectHook</span>(lifecycle, <span class="function">(<span class="params">...args: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="title function_">hook</span>(...args), target)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是闭包，或者说是工厂函数，用来调用 hook。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出函数 injectHook</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">injectHook</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 生命周期钩子的类型</span></span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span><br><span class="line"><span class="params">  <span class="comment">// 要注入的钩子函数，类型为 Function 并且具有一个可选的 __weh 属性</span></span></span><br><span class="line"><span class="params">  hook: <span class="built_in">Function</span> &amp; &#123; __weh?: <span class="built_in">Function</span> &#125;,</span></span><br><span class="line"><span class="params">  <span class="comment">// 要注入到的组件实例，类型为 ComponentInternalInstance 或者 null，默认为 currentInstance</span></span></span><br><span class="line"><span class="params">  target: ComponentInternalInstance | <span class="literal">null</span> = currentInstance,</span></span><br><span class="line"><span class="params">  <span class="comment">// 是否将钩子函数添加到钩子数组的开头，默认为 false</span></span></span><br><span class="line"><span class="params">  prepend: <span class="built_in">boolean</span> = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Function</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 target 存在，则继续执行注入逻辑，否则在开发环境下发出警告</span></span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    <span class="comment">// 获取对应生命周期类型的钩子数组 hooks，如果不存在则创建一个空数组并赋值给 target[type]</span></span><br><span class="line">    <span class="keyword">const</span> hooks = target[<span class="keyword">type</span>] || (target[<span class="keyword">type</span>] = [])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对传入的钩子函数 hook 进行封装</span></span><br><span class="line">    <span class="keyword">const</span> wrappedHook =</span><br><span class="line">      <span class="comment">// 如果钩子函数已经被封装过（存在 __weh 属性），则直接使用封装后的函数</span></span><br><span class="line">      hook.<span class="property">__weh</span> ||</span><br><span class="line">      <span class="comment">// 否则创建一个新的函数作为封装后的钩子函数</span></span><br><span class="line">      (hook.<span class="property">__weh</span> = <span class="function">(<span class="params">...args: <span class="built_in">unknown</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查 target 是否已经被卸载，如果是则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (target.<span class="property">isUnmounted</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暂停依赖追踪</span></span><br><span class="line">        <span class="title function_">pauseTracking</span>()</span><br><span class="line">        <span class="comment">// 设置当前的组件实例为 target</span></span><br><span class="line">        <span class="title function_">setCurrentInstance</span>(target)</span><br><span class="line">        <span class="comment">// 使用 callWithAsyncErrorHandling 调用钩子函数，并传入相应的参数 args</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">callWithAsyncErrorHandling</span>(hook, target, <span class="keyword">type</span>, args)</span><br><span class="line">        <span class="comment">// 取消当前组件实例的设置</span></span><br><span class="line">        <span class="title function_">unsetCurrentInstance</span>()</span><br><span class="line">        <span class="comment">// 重置依赖追踪状态</span></span><br><span class="line">        <span class="title function_">resetTracking</span>()</span><br><span class="line">        <span class="comment">// 返回钩子函数的执行结果 res</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 prepend 参数的值，将封装后的钩子函数添加到 hooks 数组的开头或末尾</span></span><br><span class="line">    <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      hooks.<span class="title function_">unshift</span>(wrappedHook)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hooks.<span class="title function_">push</span>(wrappedHook)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回封装后的钩子函数</span></span><br><span class="line">    <span class="keyword">return</span> wrappedHook</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 如果 target 不存在，且是开发环境，则发出警告</span></span><br><span class="line">    <span class="keyword">const</span> apiName = <span class="title function_">toHandlerKey</span>(<span class="title class_">ErrorTypeStrings</span>[<span class="keyword">type</span>].<span class="title function_">replace</span>(<span class="regexp">/ hook$/</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="comment">// 输出警告信息</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说， <code>inject</code> 会给 <code>target</code> 注入一个函数，函数可以直接执行 <code>hook</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeMount, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在组件挂载之前执行的逻辑</span></span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件挂载之前&#x27;</span>);</span><br><span class="line">      <span class="comment">// 执行其他操作...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ok, 到这里明白了生命周期是如何注入的，那么 <strong>Vue3</strong> 生命周期如何调用呢？，以 <code>beforeMount</code> 为例子</p><p>这个时候找到了 <code>setupRenderEffect</code> 也就是渲染 <code>setup</code> 的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">    componentUpdateFn, <span class="comment">//调用 instance.emit(&#x27;hook:beforeMount&#x27;)</span></span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">    instance.<span class="property">scope</span> <span class="comment">// track it in component&#x27;s effect scope</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">SchedulerJob</span> = (instance.<span class="property">update</span> = <span class="function">() =&gt;</span> effect.<span class="title function_">run</span>())</span><br><span class="line">update.<span class="property">id</span> = instance.<span class="property">uid</span></span><br><span class="line"><span class="title function_">update</span>()</span><br></pre></td></tr></table></figure><p>另外除了这样注册之外，还可以直接这样调用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br></pre></td></tr></table></figure><p>会直接触发，而不需要等待事件。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>Vue2.x Vue3.x 生命周期的注入和调用，本质上没什么区别。</p><p>都是挂在在当前上下文，区别只是通知方式，一个直接调用，一个通过 <code>emit</code> 来触发</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue2 </tag>
            
            <tag> typescript </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beforeCreate, created vs setup</title>
      <link href="/2023/06/20/vue_setup_created_before_created/"/>
      <url>/2023/06/20/vue_setup_created_before_created/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="beforeCreate-created-vs-setup"><a href="#beforeCreate-created-vs-setup" class="headerlink" title="beforeCreate, created vs setup"></a>beforeCreate, created vs setup</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate -&gt; <span class="title function_">setup</span>()</span><br><span class="line">created -&gt; <span class="title function_">setup</span>()</span><br><span class="line">beforeMount -&gt; onBeforeMount</span><br><span class="line">mounted -&gt; onMounted</span><br><span class="line">beforeUpdate -&gt; onBeforeUpdate</span><br><span class="line">updated -&gt; onUpdated</span><br><span class="line">beforeDestroy -&gt; onBeforeUnmount</span><br><span class="line">destroyed -&gt; onUnmounted</span><br><span class="line">activated -&gt; onActivated</span><br><span class="line">deactivated -&gt; onDeactivated</span><br><span class="line">errorCaptured -&gt; onErrorCaptured</span><br></pre></td></tr></table></figure><p>有这么多生命周期，我们一个一个对比。</p><h3 id="1-beforeCreate"><a href="#1-beforeCreate" class="headerlink" title="1. beforeCreate"></a>1. beforeCreate</h3><p>vue2.x 核心代码一直在这个位置 <strong>src\core\instance\init.ts</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initMixin</span>(<span class="params">Vue: <span class="keyword">typeof</span> Component</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to mark this as a Vue instance without having to do instanceof</span></span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// avoid instances from being observed</span></span><br><span class="line">    vm.<span class="property">__v_skip</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// effect scope</span></span><br><span class="line">    vm.<span class="property">_scope</span> = <span class="keyword">new</span> <span class="title class_">EffectScope</span>(<span class="literal">true</span> <span class="comment">/* detached */</span>)</span><br><span class="line">    vm.<span class="property">_scope</span>.<span class="property">_vm</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span> <span class="keyword">as</span> <span class="built_in">any</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">false</span> <span class="comment">/* setContext */</span>)</span><br><span class="line">    <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里包含了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">false</span> <span class="comment">/* setContext */</span>)</span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>先看 <code>beforeCreate</code> 做了什么</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge options</span></span><br><span class="line"><span class="comment">// 可以简单的理解为2种情况</span></span><br><span class="line"><span class="comment">// 1. 根组件合并，你 new Vue的参数，mixin，api 都合并为一个新的 $options</span></span><br><span class="line"><span class="comment">// 2. 子组件合并，把父组件的 event, props 需要传递的东西合并。</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    <span class="title function_">initInternalComponent</span>(vm, options <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">    <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span> <span class="keyword">as</span> <span class="built_in">any</span>),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于初始化组件生命周期的函数。它接受一个组件实例 vm 作为参数，并在该组件实例上设置一些属性和状态。</span></span><br><span class="line"><span class="comment">//总体来说就是初始化当前组件的很多属性</span></span><br><span class="line"><span class="title function_">initLifecycle</span>(vm)</span><br><span class="line"><span class="comment">//事件注册</span></span><br><span class="line"><span class="comment">//把父组件的 _parentListeners 传递给当前组件监听</span></span><br><span class="line"><span class="title function_">initEvents</span>(vm)</span><br><span class="line"><span class="comment">//解析插槽</span></span><br><span class="line"><span class="comment">//绑定createElement 组件实例</span></span><br><span class="line"><span class="comment">//获取 $attrs &amp; $listenters, 并且响应式</span></span><br><span class="line"><span class="title function_">initRender</span>(vm)</span><br></pre></td></tr></table></figure><p>也就是说 beforeCreate 之前做了 options,events,lifecycle, render的一些函数。</p><h3 id="2-beforeCreate-能做些什么？"><a href="#2-beforeCreate-能做些什么？" class="headerlink" title="2. beforeCreate 能做些什么？"></a>2. beforeCreate 能做些什么？</h3><p>能做些什么肯定是基于 options,events,lifecycle, render。</p><ol><li>访问组件实例的配置项和属性，也就是合并的 options.</li><li>因为只是加载了属性，事件等等前置的东西，所以可以进行身份验证，初始值，修改属性，加载数据之类的操作</li><li>注册事件监听器 event</li></ol><p>其他的都不能访问。</p><h3 id="3-created"><a href="#3-created" class="headerlink" title="3. created"></a>3. created</h3><p>beforeCreated 在钩子执行完成以后</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//解析vm.$options.inject</span></span><br><span class="line"><span class="comment">//defineReactive 响应式</span></span><br><span class="line"><span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (opts.props) initProps(vm, opts.props)</span></span><br><span class="line"><span class="comment">//if (opts.methods) initMethods(vm, opts.methods)</span></span><br><span class="line"><span class="comment">//if (opts.data) initData(vm)</span></span><br><span class="line"><span class="comment">//if (opts.computed) initComputed(vm, opts.computed)</span></span><br><span class="line"><span class="comment">//if (opts.watch &amp;&amp; opts.watch !== nativeWatch) initWatch(vm, opts.watch)</span></span><br><span class="line"><span class="comment">//就是把这些解析出来，然后响应式，挂载在vm上</span></span><br><span class="line"><span class="title function_">initState</span>(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 resolveProvided(vm)</span></span><br><span class="line"><span class="comment">//响应式 Object.defineProperty</span></span><br><span class="line"><span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br></pre></td></tr></table></figure><p>也就是在执行 Created 之前，解析出 <code>props, methods, data, computed, watch, inject, provide</code>.</p><p>也就是说，在 Created 之后就可以访问这些数据了。</p><h3 id="4-created-能做什么？"><a href="#4-created-能做什么？" class="headerlink" title="4. created 能做什么？"></a>4. created 能做什么？</h3><ol><li>获取组件数据。</li><li>访问组件的 DOM 元素，组件的模板已经被编译为 DOM 元素，并且可以通过 this.$el 来访问组件的根元素。你可以执行一些需要操作实际 DOM 的任务，例如操作元素属性、添加事件监听器等。</li><li>调用方法。</li></ol><h3 id="5-setup"><a href="#5-setup" class="headerlink" title="5. setup"></a>5. setup</h3><p>在看生命周期钩子之前，还是需要知道大概 Vue3 创建组件的基本流程。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取组件实例</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">instance</span>: <span class="title class_">ComponentInternalInstance</span> =</span><br><span class="line">  compatMountInstance ||</span><br><span class="line">  (initialVNode.<span class="property">component</span> = <span class="title function_">createComponentInstance</span>(</span><br><span class="line">    initialVNode,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line"><span class="comment">// inject renderer internals for keepAlive</span></span><br><span class="line"><span class="comment">// 将默认的渲染方法，加入到 KeepAliveContext 当然的 render 当中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isKeepAlive</span>(initialVNode)) &#123;</span><br><span class="line">  ;(instance.<span class="property">ctx</span> <span class="keyword">as</span> <span class="title class_">KeepAliveContext</span>).<span class="property">renderer</span> = internals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve props and slots for setup context</span></span><br><span class="line"><span class="comment">// 其实不仅仅是解析，还执行了 setup函数</span></span><br><span class="line"><span class="title function_">setupComponent</span>(instance)</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line"><span class="comment">// before proceeding</span></span><br><span class="line"><span class="comment">// 处理异步逻辑的情况，需要等待 setup() 函数完成后再继续  </span></span><br><span class="line"><span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.<span class="property">asyncDep</span>) &#123;</span><br><span class="line">  parentSuspense &amp;&amp; parentSuspense.<span class="title function_">registerDep</span>(instance, setupRenderEffect)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give it a placeholder if this is not hydration</span></span><br><span class="line">  <span class="comment">// TODO handle self-defined fallback</span></span><br><span class="line">  <span class="keyword">if</span> (!initialVNode.<span class="property">el</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> placeholder = (instance.<span class="property">subTree</span> = <span class="title function_">createVNode</span>(<span class="title class_">Comment</span>))</span><br><span class="line">    <span class="title function_">processCommentNode</span>(<span class="literal">null</span>, placeholder, container!, anchor)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行组件的渲染效果函数进行渲染</span></span><br><span class="line"><span class="title function_">setupRenderEffect</span>(</span><br><span class="line">  instance,</span><br><span class="line">  initialVNode,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  optimized</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建一个组件有什么流程？</p><ol><li>获取组件实例</li><li>将默认的渲染方法，加入到 KeepAliveContext 当然的 render 当中</li><li>解析和执行 setup</li><li>处理 setup 异步情况</li><li>渲染</li></ol><p>那我们继续看 <code>setupComponent</code> 函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setupComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  isSSR = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  isInSSRComponentSetup = isSSR</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; props, children &#125; = instance.<span class="property">vnode</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = <span class="title function_">isStatefulComponent</span>(instance)</span><br><span class="line">  <span class="comment">//解析props &amp; slots</span></span><br><span class="line">  <span class="title function_">initProps</span>(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="title function_">initSlots</span>(instance, children)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是有状态组件，执行 setup</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? <span class="title function_">setupStatefulComponent</span>(instance, isSSR)</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">  isInSSRComponentSetup = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行setup</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  isSSR: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Component</span> = instance.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ComponentOptions</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0. create render proxy property access cache</span></span><br><span class="line">  instance.<span class="property">accessCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 1. create public instance / render proxy</span></span><br><span class="line">  <span class="comment">// also mark it raw so it&#x27;s never observed</span></span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="title function_">markRaw</span>(<span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. call setup()</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = <span class="title class_">Component</span></span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.<span class="property">setupContext</span> =</span><br><span class="line">      setup.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">createSetupContext</span>(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setCurrentInstance</span>(instance)</span><br><span class="line">    <span class="title function_">pauseTracking</span>()</span><br><span class="line">    <span class="keyword">const</span> setupResult = <span class="title function_">callWithErrorHandling</span>(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      <span class="title class_">ErrorCodes</span>.<span class="property">SETUP_FUNCTION</span>,</span><br><span class="line">      [__DEV__ ? <span class="title function_">shallowReadonly</span>(instance.<span class="property">props</span>) : instance.<span class="property">props</span>, setupContext]</span><br><span class="line">    )</span><br><span class="line">    <span class="title function_">resetTracking</span>()</span><br><span class="line">    <span class="title function_">unsetCurrentInstance</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPromise</span>(setupResult)) &#123;</span><br><span class="line">      setupResult.<span class="title function_">then</span>(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">      <span class="keyword">if</span> (isSSR) &#123;</span><br><span class="line">        <span class="comment">// return the promise so server-renderer can wait on it</span></span><br><span class="line">        <span class="keyword">return</span> setupResult</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">resolvedResult: <span class="built_in">unknown</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">handleSetupResult</span>(instance, resolvedResult, isSSR)</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">handleError</span>(e, instance, <span class="title class_">ErrorCodes</span>.<span class="property">SETUP_FUNCTION</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        <span class="comment">// async setup returned Promise.</span></span><br><span class="line">        <span class="comment">// bail here and wait for re-entry.</span></span><br><span class="line">        instance.<span class="property">asyncDep</span> = setupResult</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; !instance.<span class="property">suspense</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> name = <span class="title class_">Component</span>.<span class="property">name</span> ?? <span class="string">&#x27;Anonymous&#x27;</span></span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Component &lt;<span class="subst">$&#123;name&#125;</span>&gt;: setup function returned a promise, but no `</span> +</span><br><span class="line">              <span class="string">`&lt;Suspense&gt; boundary was found in the parent component tree. `</span> +</span><br><span class="line">              <span class="string">`A component with async setup() must be nested in a &lt;Suspense&gt; `</span> +</span><br><span class="line">              <span class="string">`in order to be rendered.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`setup() returned a Promise, but the version of Vue you are using `</span> +</span><br><span class="line">            <span class="string">`does not support it yet.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">handleSetupResult</span>(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">finishComponentSetup</span>(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说就是设置上下文，执行 <code>setup，获取</code> <code>setup</code> 返回值，判断是否异步返回，调用 <code>handleSetupResult</code></p><p>&#96;&#96; 就是判断返回类型，进行不同的处理</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isFunction</span>(setupResult) <span class="comment">//返回渲染函数</span></span><br><span class="line"><span class="title function_">isObject</span>(setupResult) <span class="comment">//返回绑定对象，绑定到 setupState 当中</span></span><br></pre></td></tr></table></figure><p>然后调用 <code>finishComponentSetup</code>， 这里其实主要是处理渲染函数和兼容模式(兼容Vue2.x写法)。</p><p>在这里基本明白了组件创建期间做了什么？</p><ol><li>需要创建组件的地方调用 <code>patch</code></li><li>根据节点类型(shapeFlag &amp; 6 &#x2F;* ShapeFlags.COMPONENT *&#x2F;), 判断需要调用 <code>processComponent。</code></li><li>然后调用 <code>mountComponent</code> 创建节点</li><li>判断是否是 <code>keepAlive，写入</code> <code>keepAlive</code> 专门的 <code>render</code></li><li>执行 <code>setupComponent(instance);</code> 解析和执行 <code>setup</code><br>  5.1 解析 <code>props</code>, <code>slot</code><br>  5.2 设置 <code>setup</code> 执行上下文<br>  5.3 执行 <code>setup</code><br>  5.4 处理返回值<br>  5.5 创建 <code>render</code> 函数</li><li>处理 <code>setup</code> 异步调用情况</li><li>渲染</li></ol><h3 id="6-setup-函数能访问什么？"><a href="#6-setup-函数能访问什么？" class="headerlink" title="6. setup 函数能访问什么？"></a>6. setup 函数能访问什么？</h3><p>这里有几个问题，在刚才看 <strong>vue2.x</strong> 源码的时候，不仅仅有这些东西，</p><p>在 <code>beforeCreate</code> 的时候有 <code>options，initLifecycle，initEvents，initRender</code><br>在 <code>created</code> 的时候可以访问，<code>props, methods, data, computed, watch, inject, provide</code></p><p>这些没有可以理解 <code>methods, data, computed, watch</code>，因为他已经在 <code>setup</code> 函数当中了，那么？其他的呢？</p><p>我们应该如何访问？</p><p>拿 options 来说</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance???&#x27;</span>, instance.<span class="property">appContext</span>.<span class="property">config</span>.<span class="property">globalProperties</span>)</span><br></pre></td></tr></table></figure><p>initRender 在解析和执行 setup 会初始化。</p><p><code>$attrs</code> 在 <code>createSetupContext</code> 中解析，然后传入 <code>callWithErrorHandling</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupContext = (instance.<span class="property">setupContext</span> =</span><br><span class="line">  setup.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">createSetupContext</span>(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setCurrentInstance</span>(instance)</span><br><span class="line"><span class="title function_">pauseTracking</span>()</span><br><span class="line"><span class="keyword">const</span> setupResult = <span class="title function_">callWithErrorHandling</span>(</span><br><span class="line">  setup,</span><br><span class="line">  instance,</span><br><span class="line">  <span class="title class_">ErrorCodes</span>.<span class="property">SETUP_FUNCTION</span>,</span><br><span class="line">  [__DEV__ ? <span class="title function_">shallowReadonly</span>(instance.<span class="property">props</span>) : instance.<span class="property">props</span>, setupContext]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>initEvents</code> 主要是解决父节点和子节点的通信（通过事件通信）, </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;child v-on=<span class="string">`customEvent`</span>&gt;something&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">triggerEvent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="string">&#x27;Hello from child component!&#x27;</span>;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="string">&#x27;customEvent&#x27;</span>, payload);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>initEvents</code> &amp; <code>$attrs</code> 的源码都在 <code>createSetupContext</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">attrs</span>: <span class="title class_">Data</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="comment">// We use getters in dev in case libs like test-utils overwrite instance</span></span><br><span class="line">  <span class="comment">// properties (overwrites should not be done in prod)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">attrs</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> attrs || (attrs = <span class="title function_">createAttrsProxy</span>(instance))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">slots</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">shallowReadonly</span>(instance.<span class="property">slots</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">emit</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">event: <span class="built_in">string</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> instance.<span class="title function_">emit</span>(event, ...args)</span><br><span class="line">    &#125;,</span><br><span class="line">    expose</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">attrs</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> attrs || (attrs = <span class="title function_">createAttrsProxy</span>(instance))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">slots</span>: instance.<span class="property">slots</span>,</span><br><span class="line">    <span class="attr">emit</span>: instance.<span class="property">emit</span>,</span><br><span class="line">    expose</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inject, provide</code> </p><p><strong>packages\runtime-core\src\apiInject.ts</strong></p><p>其实就是 父组件调用 <code>provide</code>, 为当前组件的 <code>provides</code> 属性添加 <code>key value</code>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> provides = currentInstance.<span class="property">provides</span></span><br><span class="line"><span class="comment">// by default an instance inherits its parent&#x27;s provides object</span></span><br><span class="line"><span class="comment">// but when it needs to provide values of its own, it creates its</span></span><br><span class="line"><span class="comment">// own provides object using parent provides object as prototype.</span></span><br><span class="line"><span class="comment">// this way in `inject` we can simply look up injections from direct</span></span><br><span class="line"><span class="comment">// parent and let the prototype chain do the work.</span></span><br><span class="line"><span class="keyword">const</span> parentProvides =</span><br><span class="line">  currentInstance.<span class="property">parent</span> &amp;&amp; currentInstance.<span class="property">parent</span>.<span class="property">provides</span></span><br><span class="line"><span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">  provides = currentInstance.<span class="property">provides</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentProvides)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TS doesn&#x27;t allow symbol as index type</span></span><br><span class="line">provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br></pre></td></tr></table></figure><p>创建子组件的时候会调用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">provides</span>: parent ? parent.<span class="property">provides</span> : <span class="title class_">Object</span>.<span class="title function_">create</span>(appContext.<span class="property">provides</span>),</span><br></pre></td></tr></table></figure><p>如果要 <code>inject</code>，就是沿着向上找。</p><h3 id="7-差别。"><a href="#7-差别。" class="headerlink" title="7. 差别。"></a>7. 差别。</h3><p>在我看来，可以理解为没有 <code>beforeCreate</code> 这个生命周期了, 可以理解为 <code>setup = created</code>. 该解析的都解析好了.</p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p><code>beforeCreate</code> 可以访问 <code>options, event, render</code> 函数等等。</p><p><code>created</code> 可以访问到 <code>data，method，inject，provide，attrs，listener</code> 等等</p><p><code>setup</code> 等于上面的都能访问.</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> setup </tag>
            
            <tag> Vue3.x </tag>
            
            <tag> Vue2.x </tag>
            
            <tag> beforeCreate </tag>
            
            <tag> created </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async &amp; defer</title>
      <link href="/2023/06/15/async&amp;defer/"/>
      <url>/2023/06/15/async&amp;defer/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="async-amp-defer"><a href="#async-amp-defer" class="headerlink" title="async &amp; defer"></a>async &amp; defer</h1><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><p>从之前我学习的浏览器解析过程中我们知道，浏览器顺序解析，遇到javascript，就会阻塞，并且会执行 javascript, 也会阻塞</p><p>我们做一个简单的测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjBkb65gsX_AhXnQPUHHasODVkQFnoECBYQAQ&amp;url=https%3A%2F%2Fcloud.google.com%2Fcdn%3Fhl%3Dzh-cn&amp;usg=AOvVaw3iWKHtZqUXGJwR-4dEGXk8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我加入了一段 google 的连接, :)</p><p>肯定不能访问，所以说，浏览器在超时之前下面的所有代码都没有执行，所以我们一般将 script 放在 </body> 之前。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjBkb65gsX_AhXnQPUHHasODVkQFnoECBYQAQ&amp;url=https%3A%2F%2Fcloud.google.com%2Fcdn%3Fhl%3Dzh-cn&amp;usg=AOvVaw3iWKHtZqUXGJwR-4dEGXk8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好处是可以有2点</p><ol><li>预解析器可以提前加载，虽然 script 不是异步的，但是实际就是异步的。</li><li>就算阻塞了，至少前面的代码 css，html 是可以加载的</li></ol><h3 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h3><ol><li>当 script 元素使用 async 属性时，脚本的加载和执行将是异步的。</li><li>异步加载的脚本不会阻塞 HTML 页面的解析和渲染过程。</li><li>脚本的加载和执行顺序与它们在 HTML 中的顺序无关，哪个脚本先加载完成就先执行。</li><li>异步脚本加载完成后会立即执行，不管 HTML 页面的加载状态。</li><li>如果多个异步脚本相互依赖，执行顺序可能会受到影响。</li></ol><p>看了这个描述，就开始疑惑, 我们知道加载是异步的，这个我可以理解，那么执行为什么是异步的？</p><p>因为在之前的学习当中，主线程解析html，遇到 script 开始加载和执行(交给js引擎)，这个过程中是同步的，并且会停止渲染页面。</p><p>原因是因为 js引擎和渲染线程是互斥的，js中任何操作dom，css的代码，都可能导致回流或者重绘。</p><p>于是我在一段我测试的html中加入了一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./javascript/test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> d = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">200000000</span>;i++) &#123;</span><br><span class="line">     b += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>() - d);</span><br></pre></td></tr></table></figure><p>得出了一个结论，加载是异步的，执行是同步的(chatgpt害人啊…)</p><p>因为加载的时候并没有影响其他js的执行，然而加载完成立刻开始执行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19999999867108864 test.js:7</span><br><span class="line">6647 test.js:8</span><br></pre></td></tr></table></figure><p>中间这6秒并没有执行其他js代码，于是说明了一切。</p><p>再测试一下，是不是先到先得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./javascript/test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./javascript/test1.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`-------------test start---------------`</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> d = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">200000000</span>;i++) &#123;</span><br><span class="line">     b += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>() - d);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`-------------test end---------------`</span>)</span><br></pre></td></tr></table></figure><p>复制了一份 <strong>test.js</strong> 代码, 并且新增了输出，但是一直是 <strong>test.js</strong> 先执行, 又给 <strong>test.js</strong> 增加了大量注释，导致他加载速度变慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------test1 start--------------- test1.js:8 1 </span><br><span class="line">19999999867108864 test1.js:9 1 </span><br><span class="line">6677 test1.js:10 </span><br><span class="line">-------------test1 end--------------- test.js:1 </span><br><span class="line">-------------test start--------------- test.js:7 </span><br><span class="line">19999999867108864 test.js:8 </span><br><span class="line">7001 test.js:9 </span><br><span class="line">-------------test end---------------</span><br></pre></td></tr></table></figure><p>也就是说，网速决定一切，加载完成后立刻执行，先到先得，加载异步，执行同步。</p><h3 id="3-defer"><a href="#3-defer" class="headerlink" title="3. defer"></a>3. defer</h3><ul><li>当 <script> 元素使用 defer 属性时，脚本的加载和执行同步。</li><li>延迟加载的脚本不会阻塞 HTML 页面的解析，但会在 HTML 页面解析完毕后按照它们在 HTML 中的顺序依次执行。</li><li>延迟脚本在 DOMContentLoaded 事件触发之前完成加载和执行，即在文档解析期间执行。</li><li>如果多个延迟脚本相互依赖，执行顺序会按照它们在 HTML 中的顺序来执行。</li></ul><blockquote><p>HTML 页面解析完毕后</p></blockquote><p>于是我第一反应是加入一个事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里执行初始化操作和操作 DOM 的代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可惜的是，两个js在这个事件之前已经执行了, 一时半会儿想不出有什么能够测试，于是我在最后的部分加入了输出代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`end`</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>输出结果是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(`end`);</span><br><span class="line">javascript defer 输出</span><br><span class="line">console.log(`trigger DOMContentLoaded`)</span><br></pre></td></tr></table></figure><p>基本确定了是在解析完成以后解析，然后又试了试 <code>async</code>, 会在 <code>DOMContentLoaded</code> 之前触发，顺便测试了一下是否会加载完成之后中断解析，立刻执行。</p><p>于是加入了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是一个需要很长时间加载的<span class="variable constant_">HTML</span>页面&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>下面是一个非常大的文本区域：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ...大量文字</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>果然优先执行了 <code>async</code> 的 <strong>js</strong>.</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>async 和 defer 都是异步加载，async 加载完成之后立刻执行，中断主线程解析。 defer 等待主线程解析完成之后，按顺序解析。</p><p>这就是他们的作用和最大的区别，需要注意的是 <code>&lt;scrip asycn&gt;&lt;/script&gt;</code> 这样是不支持的，需要引入外部脚本.</p><h3 id="4-资料"><a href="#4-资料" class="headerlink" title="4. 资料"></a>4. 资料</h3><p><a href="https://zh.javascript.info/script-async-defer">脚本：async，defer</a></p><p>defer 属性：</p><p>当 <script> 元素使用 defer 属性时，脚本的加载和执行也是异步的。<br>延迟加载的脚本不会阻塞 HTML 页面的解析，但会在 HTML 页面解析完毕后按照它们在 HTML 中的顺序依次执行。<br>延迟脚本在 DOMContentLoaded 事件触发之前完成加载和执行，即在文档解析期间执行。<br>如果多个延迟脚本相互依赖，执行顺序会按照它们在 HTML 中的顺序来执行。<br>示例：</p><p>html<br>Copy code</p><script src="script1.js" defer></script><script src="script2.js" defer></script><p>区别：</p><p>async 属性表示脚本的加载和执行都是异步的，不会阻塞页面的渲染。脚本加载完成后立即执行，不考虑它们在 HTML 中的顺序，可能会导致脚本之间的依赖关系问题。<br>defer 属性表示脚本的加载是异步的，不会阻塞页面的渲染，但脚本的执行会在 HTML 页面解析完毕后按顺序执行，可以保持脚本之间的依赖关系。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> async </tag>
            
            <tag> defer </tag>
            
            <tag> 浏览器性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript 类型有哪些？</title>
      <link href="/2023/06/15/typescript_type/"/>
      <url>/2023/06/15/typescript_type/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="typescript-类型有哪些？"><a href="#typescript-类型有哪些？" class="headerlink" title="typescript 类型有哪些？"></a>typescript 类型有哪些？</h1><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><ul><li>number </li><li>string</li><li>null</li><li>undefined</li><li>bealean</li><li>bigInt</li><li>symbol</li></ul><p>这是基础类型，现在的 <code>javascript</code> 也支持对应类型，先不赘述了。</p><h3 id="2-数组类型"><a href="#2-数组类型" class="headerlink" title="2. 数组类型"></a>2. 数组类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">build</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">arr1</span>: T[];</span><br><span class="line">    <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;T&gt;();</span><br><span class="line">    <span class="attr">arr3</span>: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="attr">arr4</span>: <span class="built_in">symbol</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> build&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p>typescript 支持参数数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">never</span>[];</span><br></pre></td></tr></table></figure><p>是等价的。</p><p>数组还有一个特别的<strong>元组类型</strong></p><blockquote><p>[T1, T2, …]：表示具有固定长度和特定顺序的元素类型为 T1, T2, … 的元组。</p></blockquote><p>可以简单理解为，固定顺序的数组，[string, number, type, interface].</p><h3 id="3-对象类型"><a href="#3-对象类型" class="headerlink" title="3. 对象类型"></a>3. 对象类型</h3><p>object 类型，表示一切非原始类型，除了 null or undefined. 比如 {}, 比如 Date() 往大了说都是 object.</p><p>{} or Reacord&lt;k, v&gt;. 表示任意对象类型</p><p>type or interface 是自定义类型</p><h3 id="4-函数类型"><a href="#4-函数类型" class="headerlink" title="4. 函数类型"></a>4. 函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">() =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5. 枚举"></a>5. 枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> a &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-class"><a href="#6-class" class="headerlink" title="6. class"></a>6. class</h3><h3 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7. 泛型"></a>7. 泛型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>&lt;T&gt;</span><br><span class="line">T[]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">type</span> a&lt;T&gt; = ...</span><br><span class="line">inferce a&lt;T&gt; = &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型和type的很多修饰符组合起来有奇效.</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><p>any: 任意类型，他会忽略类型检查，就跟 javascript 一样使用，被官方不推荐使用。<br>unknow: 效果类似，但是更推荐使用, 因为他必须使用额外的类型检查来确定。</p><p>举个例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="built_in">any</span> = <span class="title function_">c</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">toLocaleLowerCase</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: <span class="built_in">unknown</span> = <span class="title function_">c</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">toLocaleLowerCase</span>()); <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> e === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">toLocaleLowerCase</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白差别了把，他更安全的原因在于，他必须进行一次类型检查。</p><p>void 表示方法的返回类型，虽然 typescript 允许下面代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>但是实际上不推荐。</p><p>never 表示类型通常用于表示不可到达的代码路径，例如抛出异常、死循环或类型推断失败等情况。</p><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h3><p>基础类型</p><ul><li>number</li><li>string</li><li>bealean</li><li>null</li><li>undefined</li><li>symbol</li><li>bigInt</li></ul><p>数组类型</p><ul><li>T[]</li><li>Array</li></ul><p>函数类型</p><ul><li>function() {}</li><li>() &#x3D;&gt; {}</li></ul><p>复杂类型</p><ul><li>{}</li><li>object</li><li>record</li><li>type</li><li>interface</li></ul><p>其他类型</p><ul><li>any</li><li>unknow</li><li>never</li><li>void</li></ul><p>泛型 T<br>class<br>枚举</p><p>因为最近要开始写 typescript 做一个简单的复习。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>type 和 interface 区别</title>
      <link href="/2023/06/15/type_interface/"/>
      <url>/2023/06/15/type_interface/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="type-和-interface-区别"><a href="#type-和-interface-区别" class="headerlink" title="type 和 interface 区别"></a>type 和 interface 区别</h1><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><p>interface 可以通过 implements 实现继承，然而 type 理论上不能继承。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>;</span><br><span class="line">    <span class="attr">sex</span>: <span class="title class_">Number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="attr">to</span>: <span class="built_in">number</span>): <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>, <span class="title class_">Speak</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><code>class</code> 就可以继承 <code>interface</code> 取实现方法.</p><p>type 想要继承，可以通过交叉类型可以实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal1</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>;</span><br><span class="line">    <span class="attr">sex</span>: <span class="title class_">Number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Speak1</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="attr">to</span>: <span class="built_in">number</span>): <span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person1</span> = <span class="title class_">Animal1</span> &amp; <span class="title class_">Speak1</span>;</span><br></pre></td></tr></table></figure><p>也可以实现相同效果</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a>2. 合并</h3><p>如果两个同名的 interface 可以直接合并，如果遇见重名的属性，以后面的为准，type 不行，只会报错。</p><p>type 不行，他不能实现这种操作。</p><h3 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h3><p>接口和类型都可以实现泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="title function_">getInfo</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Box1</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="title function_">getInfo</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-联合类型，交叉类型"><a href="#4-联合类型，交叉类型" class="headerlink" title="4. 联合类型，交叉类型"></a>4. 联合类型，交叉类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myVar</span>: <span class="title class_">MyType</span>;</span><br><span class="line">myVar = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 类型为 string</span></span><br><span class="line">myVar = <span class="number">123</span>; <span class="comment">// 类型为 number</span></span><br></pre></td></tr></table></figure><p>联合类型就是都可以使用，不过 interface 也可以</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IMyType</span> &#123;</span><br><span class="line">    <span class="attr">myType</span>:  <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交叉类型也一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = &#123;</span><br><span class="line">  <span class="attr">company</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">position</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmployeeWithPerson</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: <span class="title class_">EmployeeWithPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">company</span>: <span class="string">&quot;ABC Inc.&quot;</span>,</span><br><span class="line">  <span class="attr">position</span>: <span class="string">&quot;Manager&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IEmployeeWithPerson</span> &#123;</span><br><span class="line">    <span class="attr">company</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">position</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: <span class="title class_">IEmployeeWithPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">company</span>: <span class="string">&quot;ABC Inc.&quot;</span>,</span><br><span class="line">  <span class="attr">position</span>: <span class="string">&quot;Manager&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果类似，但是明显 type 更灵活，可以随意组装，任意加载。</p><h3 id="5-定义数组顺序"><a href="#5-定义数组顺序" class="headerlink" title="5. 定义数组顺序"></a>5. 定义数组顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> a &#123; <span class="title function_">a</span>(); &#125;</span><br><span class="line"><span class="keyword">interface</span> b &#123; <span class="title function_">b</span>(); &#125;</span><br><span class="line"><span class="keyword">type</span> list = [a, b];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> c &#123;</span><br><span class="line">    <span class="attr">c</span>: [a, b]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-typeof"><a href="#6-typeof" class="headerlink" title="6. typeof"></a>6. typeof</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;testA&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> d = <span class="keyword">typeof</span> element; <span class="comment">//htmlElement || null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> d1 &#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="keyword">typeof</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>其实主要区别在于继承上，还有接口合并上。</p><p>理论上 type 能够实现的 interface 都可以实现，差别只是在于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> a &#123;</span><br><span class="line">    <span class="attr">b</span>: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> b = ...</span><br></pre></td></tr></table></figure><p>从继承上来说，一个是 extends implements 继承，一个是通过联合类型，交叉类型实现，方法不一样，但是可以实现相同效果。</p><p>interface 可以使用合并， type 其实也可以使用交叉类型来解决问题。</p><p>其实最大的区别在于，interface 需要外面包一个壳子，也就是初始一个对象，但是 type 可以作为一个单独的类型存在, 也就是类型。</p><p>期间，不管是使用 字符串字面量类型模板，还是映射类型，还是 typof，条件类型 等等方式，虽然不能直接对 interface 使用，但是可以对 interface 下面的属性使用。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2023/06/15/browser_parsing/"/>
      <url>/2023/06/15/browser_parsing/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="浏览器解析过程"><a href="#浏览器解析过程" class="headerlink" title="浏览器解析过程"></a>浏览器解析过程</h1><p>用户输入网址或者点链接<br>通过DNS找到IP<br>通过TCP发起请求，三次握手<br>发起请求(get,post…)<br>获取HTTP请求的回执，拿到header,content<br>拿到Content开始解析<br>解析dom树<br>解析ccs树<br>形成 renderTree<br>执行javascript<br>回流，计算出所有dom位置<br>重绘，绘制所有dom<br>交给 GPU</p><p>这是我理解的浏览器解析过程，根据文档详细学习一下</p><h3 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1. DNS 查询"></a>1. DNS 查询</h3><blockquote><p>浏览器向名称服务器发起 DNS 查询请求，最终得到一个 IP 地址</p></blockquote><p>一般是一层一层网上找 </p><p>浏览器缓存 &#x3D;&gt; 计算机缓存 &#x3D;&gt; 本地hosts文件 &#x3D;&gt; DNS解析器 &#x3D;&gt; 根域名服务器 &#x3D;&gt; 顶级域名服务器 &#x3D;&gt; 权威域名服务器.</p><p>其实如果到了本地hosts文件这一步，就脱离了我们控制了。</p><p>我尝试在 edge 浏览器 edge:&#x2F;&#x2F;flags 中找dns选项，可惜没有找到，倒是在 firfox 中找到了选项</p><ul><li>network.dnsCacheExpiration：此配置项控制 DNS 缓存的过期时间，以秒为单位。默认值为 60 秒。您可以根据需求进行调整。</li><li>network.dnsCacheEntries：此配置项指定 DNS 缓存的最大条目数。默认值为 400。您可以根据需求进行调整。</li><li>network.dnsCacheExpirationGracePeriod：此配置项定义了 DNS 缓存的过期时间延迟，以秒为单位。默认值为 60 秒。您可以根据需求进行调整。</li></ul><p>计算机缓存</p><ul><li>Windows操作系统：DNS缓存时间可以在注册表中进行设置，路径为HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters，其中有一个键名为 MaxCacheTtl，表示最大缓存时间。</li><li>macOS操作系统：DNS缓存时间可以通过 sudo killall -HUP mDNSResponder 命令来刷新，刷新后的缓存时间由操作系统自动决定。</li><li>Linux操作系统：DNS缓存时间可以在 &#x2F;etc&#x2F;resolv.conf 文件中进行配置，其中的 options 部分可以设置缓存时间。</li></ul><p>hosts 每个操作系统都有，自己设置即可</p><h3 id="2-TCP-握手-amp-TLS-协商"><a href="#2-TCP-握手-amp-TLS-协商" class="headerlink" title="2. TCP 握手 &amp; TLS 协商"></a>2. TCP 握手 &amp; TLS 协商</h3><p>这个涉及到 http 建立请求的三次握手的问题，以及https协商的问题，可以简单理解为请求，不了解细节</p><blockquote><p>经过 8 次往返，浏览器终于可以发出请求。</p></blockquote><ul><li>第一次握手（SYN）：客户端向服务器发送一个同步（SYN）请求，表示客户端想要建立连接。这个请求包含一个随机生成的初始序列号（ISN）用于后续的数据传输。</li><li>第二次握手（SYN + ACK）：服务器收到客户端的请求后，会发送一个同步和确认（SYN + ACK）响应。服务器响应中包含了确认号（ACK）字段，用于确认客户端的初始序列号，并且也包含了自己生成的初始序列号（ISN）。</li><li>第三次握手（ACK）：客户端收到服务器的响应后，会向服务器发送一个确认（ACK）消息，确认服务器的初始序列号。</li></ul><p><strong>https</strong></p><ul><li>客户端发起连接：客户端向服务器发起HTTPS请求。URL中的协议头为”https:&#x2F;&#x2F;“，默认使用端口号443进行连接。</li><li>服务器证书验证：服务器将自己的数字证书发送给客户端。该证书包含了服务器的公钥以及其他身份验证信息。</li><li>客户端验证证书：客户端收到服务器的证书后，会进行证书的验证过程。这包括检查证书的合法性、是否过期、是否由受信任的证书颁发机构（CA）签发等。</li><li>密钥交换：如果服务器的证书验证通过，客户端会生成一个用于加密通信的随机对称密钥。该密钥用服务器的公钥进行加密后发送给服务器。</li><li>服务器解密密钥：服务器使用自己的私钥解密客户端发送的密钥，获取到对称密钥。</li><li>数据传输：客户端和服务器使用对称密钥对后续的数据进行加密和解密，确保数据在传输过程中的机密性和完整性。</li></ul><h3 id="3-tcp慢启动"><a href="#3-tcp慢启动" class="headerlink" title="3. tcp慢启动"></a>3. tcp慢启动</h3><p>慢启动是我第一次了解的概念，在不了解实现细节的前提下，大概是这样的</p><p>每个人的网络，带宽情况不一样，发送能力和接收能力不一样，</p><p>假设两台机器 A，B，</p><p>A 接收能力 30, 发送能力 50<br>B 接收能力 30, 发送能力 50.</p><p>那么这个时候 B &#x3D;&gt; A, A是会丢包的，因为他无法一次性接收50,他最大是30</p><blockquote><p>因为不清楚实时的管道传输能力，于是在刚开始传送数据的时候，从一个很小的单位值做尝试；在之后的传送过程中，逐渐翻倍增大传送数据单位值。遇到失败的情况，就立马减小传送数据单位值。 </p></blockquote><h3 id="4-构建-DOM-树"><a href="#4-构建-DOM-树" class="headerlink" title="4. 构建 DOM 树"></a>4. 构建 DOM 树</h3><p>写过html就知道，它是一种标记语言，就是一系列的标签组成，可以形成树形结构。</p><p>我们请求以后收到字节 &#x3D;&gt; 字符串 &#x3D;&gt; token &#x3D;&gt; node &#x3D;&gt; dom</p><p><code>&lt;html&gt;</code> 根节点，以他为起点开始解析，最后形成一个dom树。</p><p><a href="/img/dom.gif" title="alt text" class="gallery-item" style="box-shadow: none;"> <img src="/img/dom.gif" alt="alt text"></a></p><p>类似于上面这种结构。</p><h3 id="5-script-阻塞"><a href="#5-script-阻塞" class="headerlink" title="5. script 阻塞"></a>5. script 阻塞</h3><blockquote><p>当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于 script 标签（特别是没有 async 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。</p></blockquote><p>script 标签明确会阻止解析, 但是也有区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test_one&quot;</span>&gt;content one&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>());</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取到了 test_one`</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`test_one`</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> a = i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>());</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test_two&quot;</span>&gt;</span>content two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样就很明确是执行完成 script 以后，再继续解析，但是有区别，上面这种写法是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content one</span><br><span class="line">content two</span><br></pre></td></tr></table></figure><p>如果我新建一个 parse.js, 并且修改代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;test_one&quot;&gt;content one&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;parse.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;test_two&quot;&gt;content two&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>那么就是先出现 content one， 然后等 js 执行完成， 再出现 content two。</p><blockquote><p>阻塞渲染并不是页面不渲染，如果页面非要等到js加载执行完毕之后再渲染，那用户等待时间也太长了。浏览器的设计肯定会尽早让用户看到页面，因此遇到 script 标签时，会触发一次Paint，浏览器会将 script 标签之前的元素渲染出来。</p></blockquote><p>有点类似于强制同步布局, 就是因为 javascript 的执行，导致了强行跳过或者提前了步骤。</p><p>经过测试，script 在不加 async or defer 的前提下， 都会阻止解析，在 header，inline script 中会执行所有 js 后继续解析，如果是在 body 中引入 js，会触发 Paint.</p><h3 id="6-预加载扫描器"><a href="#6-预加载扫描器" class="headerlink" title="6. 预加载扫描器"></a>6. 预加载扫描器</h3><p>和 html解析器，有一个并行的预解析器。</p><blockquote><p>当浏览器进行 HTML 解析时，它可以启动一个额外的预测性 HTML 解析器。这个预测性解析器与普通的 HTML 解析器类似，遵循相同的规则和树构建算法。但是，预测性解析器不会影响普通解析器的状态和文档本身。</p></blockquote><p>不用去纠结他怎么解析的，但是需要知道他关注哪些节点</p><blockquote><p>A element.base</p><p>A element whose attribute is in the Content security policy state.metahttp-equiv</p><p>A element whose attribute is an ASCII case-insensitive match for “”.metanamereferrer</p><p>A element whose attribute is an ASCII case-insensitive match for “”. (This can affect whether a media query list matches the environment.) [CSSDEVICEADAPT]metanameviewport</p></blockquote><p>我很疑惑，似乎没有link or script，或者 image 之类的，但是查寻文章都说包含了 link 和 script.</p><blockquote><p>对于带有 async 属性的 script 标签，浏览器通常不会进行预解析，而是并行加载和执行。对于带有 defer 属性的脚本，浏览器可能会预解析，但不会立即执行，而是在文档解析完成后按顺序执行。</p></blockquote><p>先知道概念即可，后续可以做实验。</p><h3 id="7-CSSDOM"><a href="#7-CSSDOM" class="headerlink" title="7. CSSDOM"></a>7. CSSDOM</h3><blockquote><p>DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。</p></blockquote><p>在浏览器解析 HTML 文档时，遇到外部 CSS 样式表（通过 link 标签引入）会触发 CSSOM 的构建。浏览器会异步下载并解析外部样式表，生成对应的 CSSOM 树。同时，浏览器会继续解析 HTML，构建 DOM 树。这意味着 CSSOM 的构建和 DOM 树的构建是同时进行的，互不阻塞。</p><p>然而，在解析过程中，如果遇到内联的 style 标签或者内联样式属性，浏览器会立即处理它们，生成对应的 CSSOM 节点，并将其添加到 CSSOM 树中。因此，在遇到内联样式时，CSSOM 的构建可能会在 DOM 树构建之前完成。</p><h3 id="8-JavaScript-编译"><a href="#8-JavaScript-编译" class="headerlink" title="8. JavaScript 编译"></a>8. JavaScript 编译</h3><blockquote><p>JavaScript 被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用抽象语法树并将其传递到解释器中，输出在主线程上执行的字节码</p></blockquote><h3 id="9-构建辅助功能树"><a href="#9-构建辅助功能树" class="headerlink" title="9. 构建辅助功能树"></a>9. 构建辅助功能树</h3><h3 id="10-render-tree"><a href="#10-render-tree" class="headerlink" title="10. render tree"></a>10. render tree</h3><blockquote><p>DOM 和 CSSOM 组合成一个 Render 树, 计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点</p></blockquote><p>需要注意的是 <code>display: none</code> 是不会渲染在 render tree 当中的，但是 <code>visibility: hidden</code> 是会出现的。</p><p>在资料中说明了哪些是默认包含 <code>display:none</code>, 比如 script.</p><p>render tree 就是 dom树 每个节点都匹配上 ccsom。</p><h3 id="11-Layout-定位"><a href="#11-Layout-定位" class="headerlink" title="11. Layout(定位)"></a>11. Layout(定位)</h3><p>也就是回流，第一次叫定位</p><blockquote><p>渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</p></blockquote><h3 id="12-绘制"><a href="#12-绘制" class="headerlink" title="12. 绘制"></a>12. 绘制</h3><p>也就是重绘。</p><p>这边有一个分层的机制 </p><blockquote><p>绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括 video 和 canvas，任何 CSS 属性为 opacity 、3D transform、will-change 的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。</p></blockquote><p>然后合并给GPU。</p><blockquote><p>分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。</p></blockquote><h3 id="13-交互"><a href="#13-交互" class="headerlink" title="13. 交互"></a>13. 交互</h3><p>文档中提出了如果 javascript 如果很大或者下载时间很长，可能会导致交互无法使用。</p><blockquote><p>主线程在这段时间内完全被占用，对单击事件或屏幕点击没有响应。</p></blockquote><h3 id="14-javascript-流程。"><a href="#14-javascript-流程。" class="headerlink" title="14. javascript 流程。"></a>14. javascript 流程。</h3><p>一般来说</p><blockquote><p>JavaScript的加载、解析与执行会阻塞文档的解析，也就是说，在构造DOM时，HTML解析器若是遇到了JavaScript，那么它会暂停文档的解析，将控制权交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p></blockquote><p>理论上是这样的，但是有一个是预解析器存在，javascript的加载和解析是和 dom树解析是并行的</p><p>我做了一个简单测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test_one&quot;</span>&gt;</span>content one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test_two&quot;</span>&gt;</span>content two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200000000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> a = i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">alert</span>(<span class="string">&quot;test 02&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200000000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> a = i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">alert</span>(<span class="string">&quot;test 03&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;parse.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>结果是于加载完成了 <code>parse.js</code>, 但是执行顺序还是顺序的。</p><h3 id="15-link"><a href="#15-link" class="headerlink" title="15. link"></a>15. link</h3><blockquote><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，<br>然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，<br>如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</p><p>所以如果浏览器尚未完成 CSSOM 的下载和构建，<br>而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。<br>也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p></blockquote><h3 id="14-总结"><a href="#14-总结" class="headerlink" title="14. 总结"></a>14. 总结</h3><p>DNS查寻 &#x3D;&gt; TCP &#x3D;&gt; HTTP &#x3D;&gt; 与服务器交互(获取字节) &#x3D;&gt; 解析 &#x3D;&gt; 解析dom树(如何解析到CSS，并行解析cssom) &#x3D;&gt; 合并生成 render tree &#x3D;&gt; 定位 &#x3D;&gt; 绘制</p><p>具体性能优化后面再看</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">渲染页面：浏览器的工作原理</a></li><li><a href="https://juejin.cn/post/6844904064522649614">web性能优化(二)：针对TCP传输过程中的堵塞</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/TCP_slow_start">TCP slow start</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path">关键渲染路径</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMTokenList">DOMTokenList</a></li><li><a href="https://juejin.cn/post/6844903936877395981">script和link标签对DOM解析和渲染的影响</a></li><li><a href="https://html.spec.whatwg.org/multipage/parsing.html#speculative-html-parsing">13.2.8 Speculative HTML parsing</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphgl</title>
      <link href="/2023/06/15/graphql/"/>
      <url>/2023/06/15/graphql/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="graphgl"><a href="#graphgl" class="headerlink" title="graphgl"></a>graphgl</h1><h3 id="1-什么是-graphgl"><a href="#1-什么是-graphgl" class="headerlink" title="1. 什么是 graphgl"></a>1. 什么是 graphgl</h3><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><h3 id="2-graphgl-和-restful-区别"><a href="#2-graphgl-和-restful-区别" class="headerlink" title="2. graphgl 和 restful 区别"></a>2. graphgl 和 restful 区别</h3><p>有本质上区别，restful 更像是一种规则，一种约定。</p><p>graphgl 也不一定需要按照 restful 规则，也可以所有都使用 <code>post</code>.</p><p>所以 graphgl 查询语言，基于这种查询语言沟通数据两边，更像是虚拟dom，是一个中间层。</p><p>然而 restful 只是一种规则和约定。</p><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h3><p>sechema 描述 graphgl</p><p>在描述中定义突变，输入，查询，类型等等。</p><ol><li>mutation 突变，定义创建和更新</li><li>query 定义查询的方法</li><li>input 定义输入的类型</li><li>type Message 定义一个类型叫做 Message</li></ol><p>这些可以是字符串或者通过graphgl方法写。</p><p>字符串解析后和使用 graphgly一样</p><p>nodejs 版本的使用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  graphql,</span><br><span class="line">  GraphQLSchema,</span><br><span class="line">  GraphQLObjectType,</span><br><span class="line">  GraphQLString,</span><br><span class="line">&#125; from &#x27;graphql&#x27;;</span><br><span class="line"></span><br><span class="line">var schema = new GraphQLSchema(&#123;</span><br><span class="line">  query: new GraphQLObjectType(&#123;</span><br><span class="line">    name: &#x27;RootQueryType&#x27;,</span><br><span class="line">    fields: &#123;</span><br><span class="line">      hello: &#123;</span><br><span class="line">        type: GraphQLString,</span><br><span class="line">        resolve() &#123;</span><br><span class="line">          return &#x27;world&#x27;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>定义了一个 query, name，返回 string <code>world</code>.</p><p>这只是一个基础的例子，没有提交，更新之类的方式。</p><h3 id="4-http调用"><a href="#4-http调用" class="headerlink" title="4. http调用"></a>4. http调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@post</span><br><span class="line">http://localhost:4000/graphql</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &quot;&#123;hello&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//response</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;hello&quot;: &quot;Hello world!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@get</span><br><span class="line">http://localhost:4000/graphql?query=hello</span><br></pre></td></tr></table></figure><p>带参数的话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/info?query=&#123;getUser(id:1)&#123;name&#125;&#125;</span><br><span class="line"></span><br><span class="line">@post</span><br><span class="line">http://localhost:3000/info</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">query: &#123;</span><br><span class="line">getUser(id:1) &#123;</span><br><span class="line">name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-nodejs-完整示例"><a href="#5-nodejs-完整示例" class="headerlink" title="5. nodejs 完整示例"></a>5. nodejs 完整示例</h3><p><strong>schemaLogin.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">const &#123; buildSchema &#125; = require(&quot;graphql&quot;);</span><br><span class="line"></span><br><span class="line">let schema = buildSchema(</span><br><span class="line">  `</span><br><span class="line">        input LoginInfo &#123;</span><br><span class="line">            name: String,</span><br><span class="line">            passwd: String,</span><br><span class="line">            captcha: String</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type User &#123;</span><br><span class="line">            id: ID,</span><br><span class="line">            name: String,</span><br><span class="line">            sex: String</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type Query &#123;</span><br><span class="line">            getUser(id: ID): User</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type Mutation &#123;</span><br><span class="line">            login(user: LoginInfo): Boolean</span><br><span class="line">            register(user: LoginInfo): Int </span><br><span class="line">        &#125;</span><br><span class="line">    `</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const fakeDatabase = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">  constructor(id, name, passwd) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const root = &#123;</span><br><span class="line">  getUser: (&#123; id &#125;) =&gt; &#123;</span><br><span class="line">    let user = fakeDatabase[id];</span><br><span class="line">    if (!user) &#123;</span><br><span class="line">      throw new Error(&quot;404&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new User(user.id, user.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  login: (&#123; loginInfo &#125;) =&gt; &#123;</span><br><span class="line">    if (!loginInfo.captcha) throw new Error(&quot;captcha error&quot;);</span><br><span class="line">    if (!loginInfo.name || !loginInfo.passwd) throw new Error(&quot;params error&quot;);</span><br><span class="line"></span><br><span class="line">    for (let o in fakeDatabase) &#123;</span><br><span class="line">      if (o.name === loginInfo.name &amp;&amp; o.passwd === loginInfo.passwd)</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">  &#125;,</span><br><span class="line">  register: (&#123; loginInfo &#125;) =&gt; &#123;</span><br><span class="line">    if (!loginInfo.captcha) throw new Error(&quot;captcha error&quot;);</span><br><span class="line">    if (!loginInfo.name || !loginInfo.passwd) throw new Error(&quot;params error&quot;);</span><br><span class="line"></span><br><span class="line">    for (let o in fakeDatabase) &#123;</span><br><span class="line">      if (o.name === loginInfo.name) &#123;</span><br><span class="line">        throw new Error(&quot;name repeat&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //build id</span><br><span class="line">    var id = require(&quot;crypto&quot;).randomBytes(10).toString(&quot;hex&quot;);</span><br><span class="line">    fakeDatabase(&#123;</span><br><span class="line">      id,</span><br><span class="line">      name: loginInfo.name,</span><br><span class="line">      passwd: loginInfo.passwd,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  schema,</span><br><span class="line">  root,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>router&#x2F;index.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const &#123; schema, root &#125; = require(&quot;../common/graphql/login&quot;);</span><br><span class="line"></span><br><span class="line">router.use(</span><br><span class="line">  &quot;/info&quot;,</span><br><span class="line">  graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: true,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>graphiql</code> 调试时候开启，可以测试验证接口</p><h3 id="6-前端调用"><a href="#6-前端调用" class="headerlink" title="6. 前端调用"></a>6. 前端调用</h3><p>首先可以直接使用 axios， 然后获取数据。</p><p>如果是前端框架 可以使用 阿波罗 + graqhgl-tag.</p><p>阿波罗发起和管理请求，graqhql-tag 解析文本</p><h3 id="7-为什么要使用-graqhgl"><a href="#7-为什么要使用-graqhgl" class="headerlink" title="7. 为什么要使用 graqhgl"></a>7. 为什么要使用 graqhgl</h3><ul><li>接口数量众多维护成本高接口</li><li>扩展成本高</li><li>接口响应的数据格式无法预知</li><li>减少无用数据的请求</li><li>按需获取强类型约束（API的数据格式让前端来定义，而不是后端定义）</li></ul><p>可以方便进行测试，前端自己决定返回什么，统一的接口，跨平台，确实挺好的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.freecodecamp.org/chinese/news/a-detailed-guide-to-graphql/">https://www.freecodecamp.org/chinese/news/a-detailed-guide-to-graphql/</a><br><a href="https://www.npmjs.com/package/graphql">https://www.npmjs.com/package/graphql</a><br><a href="https://graphql.org/graphql-js/running-an-express-graphql-server/">https://graphql.org/graphql-js/running-an-express-graphql-server/</a><br><a href="https://github.com/graphql/graphql-js">https://github.com/graphql/graphql-js</a><br><a href="https://vue-apollo.netlify.app/zh-cn/guide/">https://vue-apollo.netlify.app/zh-cn/guide/</a><br><a href="https://github.com/apollographql/graphql-tag#readme">https://github.com/apollographql/graphql-tag#readme</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2023/06/15/debounce_throttle/"/>
      <url>/2023/06/15/debounce_throttle/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><blockquote><p>防抖（Debounce）和节流（Throttle）都是用于限制函数执行频率的技术，常用于优化性能、减少资源消耗和提升用户体验。</p><p>防抖的原理是在触发事件后，等待一段时间（例如100毫秒），如果在这段时间内没有再次触发该事件，才执行相应的操作。如果在等待时间内又触发了该事件，则重新计时。防抖常用于处理频繁触发的事件，如窗口调整、搜索框输入等。</p><p>节流的原理是规定一个固定的时间间隔，在该时间间隔内只会执行一次相应的操作。如果在时间间隔内触发了多次事件，只有第一次会执行操作，其余的事件会被忽略。节流常用于限制高频率触发的事件，如滚动事件、鼠标移动事件等。</p></blockquote><p>意思和明确</p><ol><li>防抖定时执行或者需要开关开始执行，但是有一个前提条件，就是需要某个标志没有执行一段时间</li><li>节流，就是我不管这些，我只认时间，到时间我就执行。</li></ol><p>这就是防抖和节流的概念。</p><h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p><strong>防抖</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="title function_">settimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(t);</span><br><span class="line">t = <span class="title function_">settimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写他蠢，用必包实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">delay, func</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(func, delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后外部调用就可以了。</p><p>同样，需要直接判断时间，也使用必包去做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - lastTime &gt; interval) &#123;</span><br><span class="line">lastTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是这样，可以写的更复杂一点，比如时间处理，比如这里也没有处理this指向，也没有处理参数，这样的简单也说清楚了。</p><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><p><strong>防抖</strong></p><blockquote><p>输入框搜索：在用户连续输入搜索关键词时，使用防抖可以避免频繁发送请求，只在用户输入完成后一段时间内执行搜索操作。<br>窗口调整：在窗口大小调整过程中，使用防抖可以确保只在用户完成调整后执行相应的操作，避免频繁触发和执行操作。<br>按钮点击：防止用户在短时间内多次点击按钮，使用防抖可以确保只响应最后一次点击。</p></blockquote><p><strong>节流</strong></p><blockquote><p>页面滚动：在滚动事件触发时，使用节流可以控制处理函数的执行频率，减少滚动事件的处理次数，提升性能。<br>鼠标移动：在鼠标移动事件触发时，使用节流可以限制事件处理函数的执行频率，减少频繁的计算和操作，提高页面响应速度。<br>页面刷新：在页面刷新时，使用节流可以限制资源加载和渲染的频率，避免一次性加载过多的资源导致页面卡顿。</p></blockquote><p>等等等等。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>其实再开头就说明了</p><blockquote><p>防抖（Debounce）和节流（Throttle）都是用于限制函数执行频率的技术，常用于优化性能、减少资源消耗和提升用户体验。</p></blockquote><p>所以当遇见可能会频繁触发的时候，就可以考虑使用。</p><p>可以直接使用 loadsh 中的方法，处理的很好，简单些可能出现一些不满足的问题，比如参数，比如异步执行调用和执行完成是不一样的，有很多细节需要处理。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 中的进制转换</title>
      <link href="/2023/06/15/conversion/"/>
      <url>/2023/06/15/conversion/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>进制转换，javascript 有哪些进制转换的方式？</p><h3 id="01-进制在-javascript-中是如何表现的？"><a href="#01-进制在-javascript-中是如何表现的？" class="headerlink" title="01. 进制在 javascript 中是如何表现的？"></a>01. 进制在 javascript 中是如何表现的？</h3><ol><li>十六进制 <code>0x</code> or <code>0X</code></li><li>八进制 <code>0o</code> or <code>0O</code></li><li>二进制 <code>0b</code> or <code>0B</code></li></ol><p>在后面跟数据就可以了，常用的最多就这些了</p><p>明白进制转换首先需要知道，什么是进制</p><h3 id="02-原生的转换"><a href="#02-原生的转换" class="headerlink" title="02. 原生的转换"></a>02. 原生的转换</h3><p>javascript 默认10进制，其他进制转10进制很方便</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseInt(v, 2 or 8 or 16...) //other =&gt; 10进制</span><br><span class="line">Number() //other =&gt; 10进制</span><br><span class="line">+() //other =&gt; 10进制</span><br><span class="line">Number.prototype.toString() //十进制 =&gt; other 支持小数。</span><br></pre></td></tr></table></figure><p>其实用法都很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const C161 = 0xaa;</span><br><span class="line">const C162 = &quot;0xAA&quot;;</span><br><span class="line"></span><br><span class="line">console.log(C161);</span><br><span class="line">console.log(C162);</span><br><span class="line">console.log(`----------------`);</span><br><span class="line"></span><br><span class="line">console.log(Number(C161));</span><br><span class="line">console.log(Number(C162));</span><br><span class="line">console.log(`----------------`);</span><br><span class="line"></span><br><span class="line">console.log(parseInt(C161));</span><br><span class="line">console.log(parseInt(C162));</span><br><span class="line">console.log(`----------------`);</span><br><span class="line"></span><br><span class="line">console.log(parseFloat(C161));</span><br><span class="line">console.log(parseFloat(C162));</span><br><span class="line">console.log(`----------------`);</span><br><span class="line"></span><br><span class="line">console.log(+C161);</span><br><span class="line">console.log(+C162);</span><br><span class="line">console.log(`----------------`);</span><br><span class="line"></span><br><span class="line">`11.11`.toString(2);</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用 parseInt 转换， 16进制ok </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(`0xAA`)</span><br><span class="line">parseInt(`0b111`)</span><br></pre></td></tr></table></figure><p>二进制不识别前面的 <code>0b</code>, 还是需要写入完整参数，最好都写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(`0xAA`, 16)</span><br><span class="line">parseInt(`0b111`, 2)</span><br></pre></td></tr></table></figure><p>相比之下, Number or + 没有这种限制。但是却又无法主动选择进制基数。</p><p>所以区分了应用场景。</p><h3 id="03-如何处理小数"><a href="#03-如何处理小数" class="headerlink" title="03. 如何处理小数"></a>03. 如何处理小数</h3><p>如果在javascript中直接写 <code>0b111.111</code> 是会报错了， 必须写 <code>&#39;0b111.111&#39;</code>.</p><p>也就是说原生 javascript 是无法处理小数的，当然可以自己去写，遵循以下原则</p><blockquote><p>从二进制数的最低位开始，每一位乘以对应的2的幂数，然后将最终的结果小数部分与整数部分分别相加<br>对应的2的幂，以个位为0，向高位依次增1，向地位依次减1；</p></blockquote><p>对应关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1010.1010</span><br></pre></td></tr></table></figure><p>0 * 2的0次方 + 1 * 2的一次方，以此类推</p><h3 id="03-如果自己去写，有什么思路"><a href="#03-如果自己去写，有什么思路" class="headerlink" title="03. 如果自己去写，有什么思路?"></a>03. 如果自己去写，有什么思路?</h3><p>首先写一个二进制的整数转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function twoToTen(str) &#123;</span><br><span class="line">  if (typeof str !== `string`) return NaN;</span><br><span class="line"></span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i&lt; str.length;i++) &#123;</span><br><span class="line">    count += Math.pow(2, i) * str.charAt(str.length - i -1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(`输入:$&#123;str&#125;`);</span><br><span class="line">  console.log(`输出:$&#123;count&#125;`);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">twoToTen(`111`);</span><br></pre></td></tr></table></figure><p>如果加入小数点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function twoToTen(str) &#123;</span><br><span class="line">  if (typeof str !== `string`) return NaN;</span><br><span class="line"></span><br><span class="line">  let arr = str.split(`.`);</span><br><span class="line">  let a = arr[0];</span><br><span class="line">  let b = arr[1];</span><br><span class="line"></span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">    count += Math.pow(2, i) * a.charAt(a.length - i - 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let count1 = 0;</span><br><span class="line">  for (let i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">    count1 += Math.pow(2, -(i + 1)) * a.charAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(`输入:$&#123;str&#125;`);</span><br><span class="line">  console.log(`输出:$&#123;count + count1&#125;`);</span><br><span class="line">  return count + count1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的百度一下就有公式，并不复杂。</p><p>我这里并没有进行检查，以及错误处理，如果需要，还是要加上的。</p><h3 id="03-link"><a href="#03-link" class="headerlink" title="03. link"></a>03. link</h3><ol><li><a href="https://juejin.cn/post/7035844421522292750">搞懂JavaScript中的进制与进制转换</a></li><li><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457?fromModule=lemma_search-box">百度百科 二进制</a></li><li><a href="https://baike.baidu.com/item/%E5%85%AB%E8%BF%9B%E5%88%B6?fromtitle=8%E8%BF%9B%E5%88%B6&fromid=17712662&fromModule=lemma_search-box">百度百科 八进制</a></li><li><a href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/4162457?fromModule=lemma_search-box">百度百科 十六进制</a></li></ol></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2023/06/15/debounce_throttle%20copy/"/>
      <url>/2023/06/15/debounce_throttle%20copy/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><blockquote><p>防抖（Debounce）和节流（Throttle）都是用于限制函数执行频率的技术，常用于优化性能、减少资源消耗和提升用户体验。</p><p>防抖的原理是在触发事件后，等待一段时间（例如100毫秒），如果在这段时间内没有再次触发该事件，才执行相应的操作。如果在等待时间内又触发了该事件，则重新计时。防抖常用于处理频繁触发的事件，如窗口调整、搜索框输入等。</p><p>节流的原理是规定一个固定的时间间隔，在该时间间隔内只会执行一次相应的操作。如果在时间间隔内触发了多次事件，只有第一次会执行操作，其余的事件会被忽略。节流常用于限制高频率触发的事件，如滚动事件、鼠标移动事件等。</p></blockquote><p>意思和明确</p><ol><li>防抖定时执行或者需要开关开始执行，但是有一个前提条件，就是需要某个标志没有执行一段时间</li><li>节流，就是我不管这些，我只认时间，到时间我就执行。</li></ol><p>这就是防抖和节流的概念。</p><h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p><strong>防抖</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="title function_">settimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(t);</span><br><span class="line">t = <span class="title function_">settimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写他蠢，用必包实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">delay, func</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(func, delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后外部调用就可以了。</p><p>同样，需要直接判断时间，也使用必包去做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - lastTime &gt; interval) &#123;</span><br><span class="line">lastTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是这样，可以写的更复杂一点，比如时间处理，比如这里也没有处理this指向，也没有处理参数，这样的简单也说清楚了。</p><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><p><strong>防抖</strong></p><blockquote><p>输入框搜索：在用户连续输入搜索关键词时，使用防抖可以避免频繁发送请求，只在用户输入完成后一段时间内执行搜索操作。<br>窗口调整：在窗口大小调整过程中，使用防抖可以确保只在用户完成调整后执行相应的操作，避免频繁触发和执行操作。<br>按钮点击：防止用户在短时间内多次点击按钮，使用防抖可以确保只响应最后一次点击。</p></blockquote><p><strong>节流</strong></p><blockquote><p>页面滚动：在滚动事件触发时，使用节流可以控制处理函数的执行频率，减少滚动事件的处理次数，提升性能。<br>鼠标移动：在鼠标移动事件触发时，使用节流可以限制事件处理函数的执行频率，减少频繁的计算和操作，提高页面响应速度。<br>页面刷新：在页面刷新时，使用节流可以限制资源加载和渲染的频率，避免一次性加载过多的资源导致页面卡顿。</p></blockquote><p>等等等等。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>其实再开头就说明了</p><blockquote><p>防抖（Debounce）和节流（Throttle）都是用于限制函数执行频率的技术，常用于优化性能、减少资源消耗和提升用户体验。</p></blockquote><p>所以当遇见可能会频繁触发的时候，就可以考虑使用。</p><p>可以直接使用 loadsh 中的方法，处理的很好，简单些可能出现一些不满足的问题，比如参数，比如异步执行调用和执行完成是不一样的，有很多细节需要处理。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>restful</title>
      <link href="/2023/06/15/restful/"/>
      <url>/2023/06/15/restful/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><h1 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h1><p>restful 在我之前基础的理解之下其实就是对资源的增删查改。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/list/1</span><br><span class="line">/user/abcdefg</span><br></pre></td></tr></table></figure><p>get 对应获取<br>post 对应创建和更新<br>put 更新<br>delete 删除</p><p>http 的四种类型对应四种动作。</p><p>理解基本上是正确的。</p><h3 id="01-语义解释"><a href="#01-语义解释" class="headerlink" title="01. 语义解释"></a>01. 语义解释</h3><p>restful &#x3D; Representational State Transfer &#x3D; 表现层状态转化.</p><p>这里少了一个主语资源，这个理论都是为了资源服务，可以把网上的一切理解为资源，图片，文本，文件，视频，api接口，获取的列表等等</p><p>然而通过 uri 来解释这个资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /user/abcdefg</span><br></pre></td></tr></table></figure><p>获取名字叫abcdefg的用户信息</p><h3 id="02-状态转换"><a href="#02-状态转换" class="headerlink" title="02. 状态转换"></a>02. 状态转换</h3><p>表现层状态转化的意思是 http 是无状态的，如果需要状态，就需要借助 <code>get</code>,<code>post</code>,<code>delete</code>,<code>put</code> 来操作服务器，这个就叫做状态转化。</p><h3 id="03-总结"><a href="#03-总结" class="headerlink" title="03. 总结"></a>03. 总结</h3><ol><li>每个 uri 都代表一种资源</li><li>可以通过 http 的不同 type，来表达动作，也就是对服务器资源进行操作</li></ol><h3 id="04-误区"><a href="#04-误区" class="headerlink" title="04. 误区"></a>04. 误区</h3><ol><li>不能新增的动作</li><li>不要加无用信息，要精准描述资源和操作</li></ol><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/2.0/user/1</span><br><span class="line">/tommy/msg/liya</span><br></pre></td></tr></table></figure><p>版本号应该放在 http 请求里面<br><strong>msg</strong> 属于新的动作，应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post /msg</span><br></pre></td></tr></table></figure><p>在 data 中表明数据。</p><p>这里是参考阮一峰的文章</p><p><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></p><p>其他文章里，对于是否加入 api 版本号之类的方式是ok的，并且强调使用状态码。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>todo</title>
      <link href="/2023/01/14/todo/"/>
      <url>/2023/01/14/todo/</url>
      
        <content type="html"><![CDATA[<div class=".article-gallery"><p>触发布局 <a href="https://juejin.cn/post/7070092857754779661">https://juejin.cn/post/7070092857754779661</a><br>同步布局 <a href="https://juejin.cn/post/7070092857754779661">https://juejin.cn/post/7070092857754779661</a></p><p>tcp 慢启动</p><p>字母’x’在CSS世界中的角色和故事<br><a href="https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/">https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/</a></p><p>iterator &amp; generator</p><p>Proxy 对比 Object.define 优点</p><p>Transition</p><p>setup 是怎么运行的？</p><p>vue3 diff 算法区别</p><p>watch &amp; comput</p><p>vue3 PatchFlags</p><p>解决跨域问题的方法</p><p>浏览器的存储有哪些及它们间的区别</p><p>微前端</p><p>前端低代码的认识</p><p>Promise</p><p>无样式内容的闪光（FOUC） <a href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content">https://en.wikipedia.org/wiki/Flash_of_unstyled_content</a></p><p>visibility: hidden 和 display: none 的区别。</p><p>css will-change 属性</p><p>如何利用绘制（重绘）分层机制，进行性能优化。</p><p>浏览器性能优化</p><p>迭代协议 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></p><p>javascript 数组，set，map 等集合或者字典 在遍历的时候，如果出现了变化，怎么应付？</p><p>自己写数组的所有方法</p><p>Object.create</p><p>instanceof vs. Array.isArray()<br>当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。<br>要知道这个究竟会有什么影响？</p><p>稀疏数组的作用是什么？</p><p>堆内存</p><p>执行上下文栈</p><p>MutationObserver,queueMicrotask</p><p>module</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Performance">https://developer.mozilla.org/zh-CN/docs/Learn/Performance</a> web性能专题</p><p>JavaScript Fetch API</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a> </p><p>Intersection_Observer_API</p><p>getBoundingClientRect</p><p>Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。这是什么？Form Submission Interception</p><p>new window.AudioContext();</p><p>AbortController</p><p>Life of a frame &amp; requestIdleCallback 这个建议花点时间看看<br> <a href="https://juejin.cn/post/6844903592831238157">https://juejin.cn/post/6844903592831238157</a><br> <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/life_of_a_frame.md">https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/life_of_a_frame.md</a></p><p> <a href="https://zh.javascript.info/arraybuffer-binary-arrays">https://zh.javascript.info/arraybuffer-binary-arrays</a></p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
